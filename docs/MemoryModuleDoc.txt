操作系统启动后第一件事情是什么？自然是管理内存
本操作系统采用uefi启动，传入的参数有之前启动时服务保留的内存表，我们就基于这个表来管理内存
0.kpoolmemmgr_t内存池管理器
首先给定堆单元的定义，就是一大段内存再加之管理数据结构，是能够对外分配内存的基本单元
而本系统使用HCB_v2类定义堆单元，在堆单元之上才是kpoolmemmgr_t管理各个堆单元
堆单元里面通过位图管理空闲内存，在每个被分配的内存前加入一个元信息头保存信息，以及通过魔术校验是否存在越界，若存在越界就会立马内核恐慌
在编译阶段就在内核映像中定义了static HCB_v2 first_linekd_heap，使之在任意模块之前都可以用new/delete进行内存管理
在后续gKspacePgsMemMgr以及gPhyPgsMemMgr这两个依赖加载好之后可以开启多hcb拓展位，就可以分配多个hcb，不过kpoolmemmgr_t层面设计的是一个HCB必然绑定到一个核心，但是HCB本身多线程安全
不过由于cpp new/delete的关键字abi行为，若是分配失败返回nullptr会无条件尝试用nullptr作为this进行构造，这是极其危险的
cpp用户态行为是抛出异常，放在内核里面应该采取panic的政策
1.gBaseMemMgr 基本物理内存管理器(已实现)
对传入的efi内存表进行排序裁剪，回收启动时服务内存，标记内核内存，再回收loader内存，
去除尾巴上的多余保留无效项，复制一份物理内存表，就可以基于物理内存表开展恒等映射的物理内存管理
2.MemoryAccsesor访问器(部分实现，只做了基本VM_DESC，还没有遇到需要缓存VM_DESC的地步)
提供对物理地址的基础原子读写接口，提供8,16,32,64物理地址读写的接口
内部原理有两种，
2.1.缓存VM_DESC+基本VM_DESC模式:若物理地址落在对应VM_DESC则计算出对应的虚拟地址然后虚拟地址访问
对于物理地址会优先尝试使用基本VM_DESC，
物理地址没有落在基本VM_DESC的物理地址段内，则尝试缓存VM_DESC，
实在不行先PhyPgsMemMgr查询对应PHYSEG，再新建一个VM_DESC，然后驱逐一个频次最低的VM_DESC
2.2.初始化页表模式：
在kernel_entry.asm里面配置了个特殊页表，如果使用的是特殊页表，则说明具有0~512gb物理地址空间恒等映射的能力，可以直接访问物理地址
两种模式的采取是静默提取cr3校验是否是初始化页表，然后静默自动选择：初始化页表直接用恒等映射，非初始化页表则使用VM_DESC
这样设计避免了在gKspacePgsMemMgr和Addressapce里面访问物理地址时若基本VM_DESC不存在然后无限递归的怪圈，
但是如果那两个类分配的页框如果超过基本VM_DESC还是有无限递归的风险
我决定此静态类不考虑构造/初始化函数，显然基本VM_DESC是依赖于PhyPgsMemMgr物理页管理器的，基本VM_DESC的初始化由gPhyPgsMemMgr完成
3.PhyPgsMemMgr物理页管理器（已实现，但是还没有对FreePagesAllocator的适配）
通过根1GB稀疏数组以及下级2mb/4kb表管理物理内存，类似于多级分页结构
由此可以在这个表的视角下构建出一个原子页视图，而页框管理器则是标记了这些原子页的类型，是否可分配（在dram里面），是不是mmio
在根1GB稀疏数组中最初始的状态是没有任何物理地址段被认领，也就是所有的内存处于BLACK_HOLE状态
而本类提供BLACK_HOLE_ALLCIAM_**系列接口，专门负责从BLACK_HOLE中注册物理地址段状态，
BLACK_HOLE_ALLCIAM_**成功后会在原子页视图上的所有页框都改为非BLACK_HOLE
同时也有辅助数据结构，是一个以起始物理地址正序的数组存储占用的物理段，BLACK_HOLE_ALLCIAM_**成功后会保证顺序的条件下增加条目
BLACK_HOLE_DEALLCIAM_**要求在原子页视图上段下所有页框为BLACK_HOLE_ALLCIAM_**成功后的初始状态下才可能成功
并且同时在原子页视角上恢复BLACK_HOLE状态
显然BLACK_HOLE_ALLCIAM_**时首先校验段表中地址段是否冲突，而后在原子页层面一个一个设置的时候不能遇见非BLACK_HOLE才会成功
具有分配/回收/注册/注销处于dram中的物理页框，
注册/注销mmio用途页框，
//上面两项很明显必须在非BLOACK_HOLE的物理段下进行
报告各项统计信息（dram大小，mmio大小，dram物理地址段数，mmio物理地址段数，等等）的功能
根据物理地址查询返回对应物理段的功能
MemoryAccsesor的基本VM_DESC如果有内存热插拔这种事件很可能需要通知gKspacePgsMemMgr更新VM_DESC,或者说最简单省事的方法，
给这个机器的最大内存乘一个值
4.FreePagesAllocator
类似linux的伙伴系统的页框分配器，但是是以free_pages_in_seg_control_block下面才是一个伙伴系统
而FreePagesAllocator是管理这些BCB的上层，其中低4GB有一个位图数据结构已经准备好的的BCB
BCB内部实现参见BCB_doc.txt这个文档
5.gKspacePgsMemMgr内核空间页管理器
这个管理器专职负责高一半虚拟地址的映射/取消映射，核心数据结构是VM_DESC，通过红黑树保存映射的虚拟地址
只保证VM_DESC间地址不重叠，不保证映射的物理地址的合理性
优先从最后一个段的结束地址开始分配
这个类的页表结构页框分配统一用PhyPgsMemMgr，访问修改页表项统一用MemoryAccsesor
但是记得在MemoryAccsesor里面声明的基本VM_DESC必须在KspacePgsMemMgr初始化过程中初始化，否则切换之后必然无限递归
6.Addressapce管理器
此类只负责管理下一半虚拟地址空间的映射/取消映射，需要外部自行管理映射了什么虚拟地址空间，如果试图重复映射虚拟地址则行为未定义
此类提供加载对应地址空间的功能，而内核中定义了AddressSpace gKernelSpace专门用于承载内核空间虚拟地址并加载，而gKernelSpace的加载到bsp意味着内存模块的正式完毕
提供加载Addressapce到cr3的功能，但是必须给出对应的pcid,并且不对pcid进行检查，内部是通过把uint16_t的pcid或运算，本类只负责加载，pcid的管理不在本类的范围内
Addressapce提供gKernelSpace专门用于内核映射，gKernelSpace由于固件要求特殊使用低64gb恒等映射，主要是uefi运行时服务所依赖的环境
但是gKernelSpace必须占用所有核心的0号pcid