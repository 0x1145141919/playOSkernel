
kernel.elf：     文件格式 elf64-x86-64


Disassembly of section .text:

0000000004000000 <__cxa_atexit>:
 extern "C" {
    // DSO句柄，对于静态链接的内核，可以简单定义为空
    void* __dso_handle = 0;
    
    // 用于注册析构函数的函数，这里提供一个空实现
    int __cxa_atexit(void (*func)(void*), void* arg, void* dso) {
 4000000:	55                   	push   %rbp
 4000001:	48 89 e5             	mov    %rsp,%rbp
 4000004:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
 4000008:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
 400000c:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
        (void)func;
        (void)arg;
        (void)dso;
        return 0;
 4000010:	b8 00 00 00 00       	mov    $0x0,%eax
    }
 4000015:	5d                   	pop    %rbp
 4000016:	c3                   	ret

0000000004000017 <_kernel_Init>:
extern "C" int _kernel_Init(void* TransferPage,
    int numofpages,
    EFI_MEMORY_DESCRIPTORX64*memDescript,
    int numofDiscriptors,
     EFI_SYSTEM_TABLE*gST) 
{
 4000017:	55                   	push   %rbp
 4000018:	48 89 e5             	mov    %rsp,%rbp
 400001b:	48 83 ec 40          	sub    $0x40,%rsp
 400001f:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
 4000023:	89 75 d4             	mov    %esi,-0x2c(%rbp)
 4000026:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
 400002a:	89 4d d0             	mov    %ecx,-0x30(%rbp)
 400002d:	4c 89 45 c0          	mov    %r8,-0x40(%rbp)
    //asm volatile("cli   ");
    int  Status=0;
 4000031:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
    /* uint32_t low, high;
   
    // 内联汇编读取 IA32_PAT (MSR 0x277)
    asm volatile (
 4000038:	b8 77 02 00 00       	mov    $0x277,%eax
 400003d:	89 c1                	mov    %eax,%ecx
 400003f:	0f 32                	rdmsr
 4000041:	89 45 f8             	mov    %eax,-0x8(%rbp)
 4000044:	89 55 f4             	mov    %edx,-0xc(%rbp)
        "rdmsr"                     // 执行 RDMSR 指令
        : "=a"(low), "=d"(high)     // 输出：EAX → low, EDX → high
        : "c"(0x277)                // 输入：ECX = MSR 地址 (0x277)
    );*/
    GlobalBasicGraphicInfoType* TFG=(GlobalBasicGraphicInfoType*)TransferPage;
 4000047:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 400004b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    Status = InitialGlobalBasicGraphicInfo(
 400004f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4000053:	44 8b 40 18          	mov    0x18(%rax),%r8d
 4000057:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 400005b:	48 8b 78 10          	mov    0x10(%rax),%rdi
 400005f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4000063:	8b 48 0c             	mov    0xc(%rax),%ecx
 4000066:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 400006a:	8b 50 08             	mov    0x8(%rax),%edx
 400006d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4000071:	8b 70 04             	mov    0x4(%rax),%esi
 4000074:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4000078:	8b 00                	mov    (%rax),%eax
 400007a:	45 89 c1             	mov    %r8d,%r9d
 400007d:	49 89 f8             	mov    %rdi,%r8
 4000080:	89 c7                	mov    %eax,%edi
 4000082:	e8 27 94 00 00       	call   40094ae <InitialGlobalBasicGraphicInfo>
 4000087:	89 45 fc             	mov    %eax,-0x4(%rbp)
        TFG->pixelFormat,
        TFG->PixelsPerScanLine,
        TFG->FrameBufferBase,
        TFG->FrameBufferSize
    );
    serial_init();
 400008a:	e8 17 a7 00 00       	call   400a7a6 <serial_init>
    gkcirclebufflogMgr.Init();
 400008f:	48 8d 05 7a ff 7f 00 	lea    0x7fff7a(%rip),%rax        # 4800010 <gkcirclebufflogMgr>
 4000096:	48 89 c7             	mov    %rax,%rdi
 4000099:	e8 28 01 00 00       	call   40001c6 <kcirclebufflogMgr::Init()>
    if (Status!=OS_SUCCESS)
 400009e:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
 40000a2:	74 17                	je     40000bb <_kernel_Init+0xa4>
    {
        serial_puts("InitialGlobalBasicGraphicInfo Failed\n");
 40000a4:	48 8d 05 85 f2 00 00 	lea    0xf285(%rip),%rax        # 400f330 <NullPgControlBlockHeader+0x10>
 40000ab:	48 89 c7             	mov    %rax,%rdi
 40000ae:	e8 9c a7 00 00       	call   400a84f <serial_puts>
        return Status;
 40000b3:	8b 45 fc             	mov    -0x4(%rbp),%eax
 40000b6:	e9 09 01 00 00       	jmp    40001c4 <_kernel_Init+0x1ad>
    }
    gKpoolmemmgr.Init();
 40000bb:	48 8d 05 be ff 7f 00 	lea    0x7fffbe(%rip),%rax        # 4800080 <gKpoolmemmgr>
 40000c2:	48 89 c7             	mov    %rax,%rdi
 40000c5:	e8 ee 34 00 00       	call   40035b8 <kpoolmemmgr_t::Init()>
    Status =InitialGlobalCharacterSetBitmapControler(
 40000ca:	48 8d 05 2f af 00 00 	lea    0xaf2f(%rip),%rax        # 400b000 <ter16x32_data>
 40000d1:	48 83 ec 08          	sub    $0x8,%rsp
 40000d5:	6a 00                	push   $0x0
 40000d7:	41 b9 00 00 00 00    	mov    $0x0,%r9d
 40000dd:	49 89 c0             	mov    %rax,%r8
 40000e0:	b9 ff ff ff 00       	mov    $0xffffff,%ecx
 40000e5:	ba 00 00 00 00       	mov    $0x0,%edx
 40000ea:	be 10 00 00 00       	mov    $0x10,%esi
 40000ef:	bf 20 00 00 00       	mov    $0x20,%edi
 40000f4:	e8 71 94 00 00       	call   400956a <InitialGlobalCharacterSetBitmapControler>
 40000f9:	48 83 c4 10          	add    $0x10,%rsp
 40000fd:	89 45 fc             	mov    %eax,-0x4(%rbp)
        FALSE,
        NULL
    );
    Status=InitialKernelShellControler(
        GlobalBasicGraphicInfo.verticalResolution,
        GlobalBasicGraphicInfo.horizentalResolution,
 4000100:	8b 05 1a f1 80 00    	mov    0x80f11a(%rip),%eax        # 480f220 <GlobalBasicGraphicInfo>
    Status=InitialKernelShellControler(
 4000106:	0f b7 f0             	movzwl %ax,%esi
        GlobalBasicGraphicInfo.verticalResolution,
 4000109:	8b 05 15 f1 80 00    	mov    0x80f115(%rip),%eax        # 480f224 <GlobalBasicGraphicInfo+0x4>
    Status=InitialKernelShellControler(
 400010f:	0f b7 c0             	movzwl %ax,%eax
 4000112:	6a 00                	push   $0x0
 4000114:	6a 00                	push   $0x0
 4000116:	68 00 10 00 00       	push   $0x1000
 400011b:	48 8d 15 be f0 80 00 	lea    0x80f0be(%rip),%rdx        # 480f1e0 <GlobalCharacterSetBitmapControler>
 4000122:	52                   	push   %rdx
 4000123:	68 00 10 00 00       	push   $0x1000
 4000128:	48 8d 15 b1 e0 80 00 	lea    0x80e0b1(%rip),%rdx        # 480e1e0 <GlobalKernelShellOutputBuffer>
 400012f:	52                   	push   %rdx
 4000130:	48 8d 15 a9 d0 80 00 	lea    0x80d0a9(%rip),%rdx        # 480d1e0 <GlobalKernelShellInputBuffer>
 4000137:	52                   	push   %rdx
 4000138:	6a 00                	push   $0x0
 400013a:	41 b9 00 00 00 00    	mov    $0x0,%r9d
 4000140:	41 b8 00 00 00 00    	mov    $0x0,%r8d
 4000146:	b9 00 00 00 00       	mov    $0x0,%ecx
 400014b:	ba 00 00 00 00       	mov    $0x0,%edx
 4000150:	89 c7                	mov    %eax,%edi
 4000152:	e8 bd 8f 00 00       	call   4009114 <InitialKernelShellControler>
 4000157:	48 83 c4 40          	add    $0x40,%rsp
 400015b:	89 45 fc             	mov    %eax,-0x4(%rbp)
        GlobalKernelShellOutputBuffer,
        4096,
        &GlobalCharacterSetBitmapControler,
        4096,0,0
    );
    if (Status!=OS_SUCCESS)
 400015e:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
 4000162:	74 14                	je     4000178 <_kernel_Init+0x161>
    {
        serial_puts("InitialKernelShellControler Failed\n");
 4000164:	48 8d 05 ed f1 00 00 	lea    0xf1ed(%rip),%rax        # 400f358 <NullPgControlBlockHeader+0x38>
 400016b:	48 89 c7             	mov    %rax,%rdi
 400016e:	e8 dc a6 00 00       	call   400a84f <serial_puts>
        return Status;
 4000173:	8b 45 fc             	mov    -0x4(%rbp),%eax
 4000176:	eb 4c                	jmp    40001c4 <_kernel_Init+0x1ad>
    }
    
    // 初始化全局Ascii位图控制器
    kputsSecure("Welcome to PlayOSKernelShell\n");
 4000178:	48 8d 05 fd f1 00 00 	lea    0xf1fd(%rip),%rax        # 400f37c <NullPgControlBlockHeader+0x5c>
 400017f:	48 89 c7             	mov    %rax,%rdi
 4000182:	e8 3e a0 00 00       	call   400a1c5 <kputsSecure>
    gBaseMemMgr.Init(memDescript,numofDiscriptors);
 4000187:	8b 45 d0             	mov    -0x30(%rbp),%eax
 400018a:	48 63 d0             	movslq %eax,%rdx
 400018d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 4000191:	48 8d 0d a8 fe 7f 00 	lea    0x7ffea8(%rip),%rcx        # 4800040 <gBaseMemMgr>
 4000198:	48 89 c6             	mov    %rax,%rsi
 400019b:	48 89 cf             	mov    %rcx,%rdi
 400019e:	e8 e1 09 00 00       	call   4000b84 <GlobalMemoryPGlevelMgr_t::Init(EFI_MEMORY_DESCRIPTORX64*, unsigned long)>
    gBaseMemMgr.printPhyMemDesTb();
 40001a3:	48 8d 05 96 fe 7f 00 	lea    0x7ffe96(%rip),%rax        # 4800040 <gBaseMemMgr>
 40001aa:	48 89 c7             	mov    %rax,%rdi
 40001ad:	e8 80 28 00 00       	call   4002a32 <GlobalMemoryPGlevelMgr_t::printPhyMemDesTb()>
    gKspacePgsMemMgr.Init();
 40001b2:	48 8d 05 47 bf 80 00 	lea    0x80bf47(%rip),%rax        # 480c100 <gKspacePgsMemMgr>
 40001b9:	48 89 c7             	mov    %rax,%rdi
 40001bc:	e8 e3 45 00 00       	call   40047a4 <KernelSpacePgsMemMgr::Init()>
    asm volatile("hlt");    
 40001c1:	f4                   	hlt
 40001c2:	0f 0b                	ud2
 40001c4:	c9                   	leave
 40001c5:	c3                   	ret

00000000040001c6 <kcirclebufflogMgr::Init()>:
    extern char __klog_start;
    extern uint64_t __KLOG_SIZE;
}
 kcirclebufflogMgr gkcirclebufflogMgr;
void kcirclebufflogMgr::Init()
{
 40001c6:	55                   	push   %rbp
 40001c7:	48 89 e5             	mov    %rsp,%rbp
 40001ca:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    buff= &__klog_start;
 40001ce:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 40001d2:	48 8d 15 27 fe 5f 00 	lea    0x5ffe27(%rip),%rdx        # 4600000 <__heap_end>
 40001d9:	48 89 10             	mov    %rdx,(%rax)
    buffSize=__KLOG_SIZE;
 40001dc:	48 8b 15 1d fe 1f fc 	mov    -0x3e001e3(%rip),%rdx        # 200000 <__KLOG_SIZE>
 40001e3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 40001e7:	48 89 50 08          	mov    %rdx,0x8(%rax)

    tailIndex=0;
 40001eb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 40001ef:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
 40001f6:	00 
}
 40001f7:	90                   	nop
 40001f8:	5d                   	pop    %rbp
 40001f9:	c3                   	ret

00000000040001fa <kcirclebufflogMgr::putsk(char*, unsigned long)>:

// 在文档2中更新putsk函数实现
void kcirclebufflogMgr::putsk(char *str, uint64_t len_in_bytes) {
 40001fa:	55                   	push   %rbp
 40001fb:	48 89 e5             	mov    %rsp,%rbp
 40001fe:	48 83 ec 30          	sub    $0x30,%rsp
 4000202:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
 4000206:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
 400020a:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
    if (len_in_bytes == 0 || buffSize == 0) return;
 400020e:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
 4000213:	0f 84 20 01 00 00    	je     4000339 <kcirclebufflogMgr::putsk(char*, unsigned long)+0x13f>
 4000219:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 400021d:	48 8b 40 08          	mov    0x8(%rax),%rax
 4000221:	48 85 c0             	test   %rax,%rax
 4000224:	0f 84 0f 01 00 00    	je     4000339 <kcirclebufflogMgr::putsk(char*, unsigned long)+0x13f>

    // 处理超长数据（保留最后buffSize字节）
    if (len_in_bytes > buffSize) {
 400022a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 400022e:	48 8b 40 08          	mov    0x8(%rax),%rax
 4000232:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
 4000236:	73 1f                	jae    4000257 <kcirclebufflogMgr::putsk(char*, unsigned long)+0x5d>
        str += (len_in_bytes - buffSize);
 4000238:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 400023c:	48 8b 40 08          	mov    0x8(%rax),%rax
 4000240:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
 4000244:	48 29 c2             	sub    %rax,%rdx
 4000247:	48 01 55 e0          	add    %rdx,-0x20(%rbp)
        len_in_bytes = buffSize;
 400024b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 400024f:	48 8b 40 08          	mov    0x8(%rax),%rax
 4000253:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    }

    // 计算尾部连续空间
    uint64_t remaining = buffSize - tailIndex;
 4000257:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 400025b:	48 8b 50 08          	mov    0x8(%rax),%rdx
 400025f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4000263:	48 8b 40 10          	mov    0x10(%rax),%rax
 4000267:	48 29 c2             	sub    %rax,%rdx
 400026a:	48 89 55 f8          	mov    %rdx,-0x8(%rbp)
    
    if (len_in_bytes <= remaining) {
 400026e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4000272:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
 4000276:	72 3f                	jb     40002b7 <kcirclebufflogMgr::putsk(char*, unsigned long)+0xbd>
        // 单次拷贝即可完成
        ksystemramcpy(str, buff + tailIndex, len_in_bytes);
 4000278:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 400027c:	48 8b 10             	mov    (%rax),%rdx
 400027f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4000283:	48 8b 40 10          	mov    0x10(%rax),%rax
 4000287:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
 400028b:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
 400028f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4000293:	48 89 ce             	mov    %rcx,%rsi
 4000296:	48 89 c7             	mov    %rax,%rdi
 4000299:	e8 88 80 00 00       	call   4008326 <ksystemramcpy(void*, void*, unsigned long)>
        tailIndex += len_in_bytes;
 400029e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 40002a2:	48 8b 50 10          	mov    0x10(%rax),%rdx
 40002a6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 40002aa:	48 01 c2             	add    %rax,%rdx
 40002ad:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 40002b1:	48 89 50 10          	mov    %rdx,0x10(%rax)
 40002b5:	eb 5f                	jmp    4000316 <kcirclebufflogMgr::putsk(char*, unsigned long)+0x11c>
        // 无需取模，因为remaining确保不会越界
    } else {
        // 分两段拷贝（跨越缓冲区末尾）
        ksystemramcpy(str, buff + tailIndex, remaining);
 40002b7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 40002bb:	48 8b 10             	mov    (%rax),%rdx
 40002be:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 40002c2:	48 8b 40 10          	mov    0x10(%rax),%rax
 40002c6:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
 40002ca:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
 40002ce:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 40002d2:	48 89 ce             	mov    %rcx,%rsi
 40002d5:	48 89 c7             	mov    %rax,%rdi
 40002d8:	e8 49 80 00 00       	call   4008326 <ksystemramcpy(void*, void*, unsigned long)>
        uint64_t secondPart = len_in_bytes - remaining;
 40002dd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 40002e1:	48 2b 45 f8          	sub    -0x8(%rbp),%rax
 40002e5:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        ksystemramcpy(str + remaining, buff, secondPart);
 40002e9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 40002ed:	48 8b 00             	mov    (%rax),%rax
 40002f0:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
 40002f4:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
 40002f8:	48 01 d1             	add    %rdx,%rcx
 40002fb:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
 40002ff:	48 89 c6             	mov    %rax,%rsi
 4000302:	48 89 cf             	mov    %rcx,%rdi
 4000305:	e8 1c 80 00 00       	call   4008326 <ksystemramcpy(void*, void*, unsigned long)>
        tailIndex = secondPart;  // 尾部指针回绕到开头
 400030a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 400030e:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
 4000312:	48 89 50 10          	mov    %rdx,0x10(%rax)
    }

    // 确保尾部指针不越界（当remaining恰好相等时）
    if (tailIndex >= buffSize) {
 4000316:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 400031a:	48 8b 50 10          	mov    0x10(%rax),%rdx
 400031e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4000322:	48 8b 40 08          	mov    0x8(%rax),%rax
 4000326:	48 39 c2             	cmp    %rax,%rdx
 4000329:	72 0f                	jb     400033a <kcirclebufflogMgr::putsk(char*, unsigned long)+0x140>
        tailIndex = 0;
 400032b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 400032f:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
 4000336:	00 
 4000337:	eb 01                	jmp    400033a <kcirclebufflogMgr::putsk(char*, unsigned long)+0x140>
    if (len_in_bytes == 0 || buffSize == 0) return;
 4000339:	90                   	nop
    }
}
 400033a:	c9                   	leave
 400033b:	c3                   	ret

000000000400033c <kcirclebufflogMgr::putsk(char*)>:
// 在源文件(kcirclebufflogMgr.cpp)中实现重载函数
void kcirclebufflogMgr::putsk(char *str) {
 400033c:	55                   	push   %rbp
 400033d:	48 89 e5             	mov    %rsp,%rbp
 4000340:	48 83 ec 30          	sub    $0x30,%rsp
 4000344:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
 4000348:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
    // 安全处理空指针
    if (str == nullptr) return;
 400034c:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
 4000351:	74 59                	je     40003ac <kcirclebufflogMgr::putsk(char*)+0x70>
    
    // 手动计算字符串长度（不依赖标准库strlen）
    uint64_t len = 0;
 4000353:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
 400035a:	00 
    char *p = str;
 400035b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
 400035f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    
    // 设置最大长度保护（防止无限循环）
    const uint64_t maxLen = buffSize * 2; // 允许最多2倍缓冲区长度
 4000363:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4000367:	48 8b 40 08          	mov    0x8(%rax),%rax
 400036b:	48 01 c0             	add    %rax,%rax
 400036e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    
    while (*p != '\0' && len < maxLen) {
 4000372:	eb 0a                	jmp    400037e <kcirclebufflogMgr::putsk(char*)+0x42>
        len++;
 4000374:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
        p++;
 4000379:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
    while (*p != '\0' && len < maxLen) {
 400037e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 4000382:	0f b6 00             	movzbl (%rax),%eax
 4000385:	84 c0                	test   %al,%al
 4000387:	74 0a                	je     4000393 <kcirclebufflogMgr::putsk(char*)+0x57>
 4000389:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 400038d:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
 4000391:	72 e1                	jb     4000374 <kcirclebufflogMgr::putsk(char*)+0x38>
    }
    
    // 调用原始实现写入数据
    putsk(str, len);
 4000393:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
 4000397:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
 400039b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 400039f:	48 89 ce             	mov    %rcx,%rsi
 40003a2:	48 89 c7             	mov    %rax,%rdi
 40003a5:	e8 50 fe ff ff       	call   40001fa <kcirclebufflogMgr::putsk(char*, unsigned long)>
 40003aa:	eb 01                	jmp    40003ad <kcirclebufflogMgr::putsk(char*)+0x71>
    if (str == nullptr) return;
 40003ac:	90                   	nop
}
 40003ad:	c9                   	leave
 40003ae:	c3                   	ret
 40003af:	90                   	nop

00000000040003b0 <kcirclebufflogMgr::~kcirclebufflogMgr()>:
kcirclebufflogMgr::~kcirclebufflogMgr()
 40003b0:	55                   	push   %rbp
 40003b1:	48 89 e5             	mov    %rsp,%rbp
 40003b4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
{
 40003b8:	90                   	nop
 40003b9:	5d                   	pop    %rbp
 40003ba:	c3                   	ret

00000000040003bb <__static_initialization_and_destruction_0()>:
 40003bb:	55                   	push   %rbp
 40003bc:	48 89 e5             	mov    %rsp,%rbp
 kcirclebufflogMgr gkcirclebufflogMgr;
 40003bf:	48 8d 05 4a fc 7f 00 	lea    0x7ffc4a(%rip),%rax        # 4800010 <gkcirclebufflogMgr>
 40003c6:	48 89 c7             	mov    %rax,%rdi
 40003c9:	e8 e2 ff ff ff       	call   40003b0 <kcirclebufflogMgr::~kcirclebufflogMgr()>
 40003ce:	90                   	nop
 40003cf:	5d                   	pop    %rbp
 40003d0:	c3                   	ret

00000000040003d1 <_GLOBAL__sub_D_gkcirclebufflogMgr>:
 40003d1:	55                   	push   %rbp
 40003d2:	48 89 e5             	mov    %rsp,%rbp
 40003d5:	e8 e1 ff ff ff       	call   40003bb <__static_initialization_and_destruction_0()>
 40003da:	5d                   	pop    %rbp
 40003db:	c3                   	ret

00000000040003dc <LocalCPU::set_bit(unsigned long, unsigned char) const>:
#include    "stdint.h"
#include "processor_self_manage.h"
uint64_t LocalCPU::set_bit(uint64_t value, uint8_t bit_position) const {
 40003dc:	55                   	push   %rbp
 40003dd:	48 89 e5             	mov    %rsp,%rbp
 40003e0:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
 40003e4:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
 40003e8:	89 d0                	mov    %edx,%eax
 40003ea:	88 45 ec             	mov    %al,-0x14(%rbp)
    return value | (1ULL << bit_position);
 40003ed:	0f b6 45 ec          	movzbl -0x14(%rbp),%eax
 40003f1:	ba 01 00 00 00       	mov    $0x1,%edx
 40003f6:	89 c1                	mov    %eax,%ecx
 40003f8:	48 d3 e2             	shl    %cl,%rdx
 40003fb:	48 89 d0             	mov    %rdx,%rax
 40003fe:	48 0b 45 f0          	or     -0x10(%rbp),%rax
}
 4000402:	5d                   	pop    %rbp
 4000403:	c3                   	ret

0000000004000404 <LocalCPU::clear_bit(unsigned long, unsigned char) const>:

uint64_t LocalCPU::clear_bit(uint64_t value, uint8_t bit_position) const {
 4000404:	55                   	push   %rbp
 4000405:	48 89 e5             	mov    %rsp,%rbp
 4000408:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
 400040c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
 4000410:	89 d0                	mov    %edx,%eax
 4000412:	88 45 ec             	mov    %al,-0x14(%rbp)
    return value & ~(1ULL << bit_position);
 4000415:	0f b6 45 ec          	movzbl -0x14(%rbp),%eax
 4000419:	ba 01 00 00 00       	mov    $0x1,%edx
 400041e:	89 c1                	mov    %eax,%ecx
 4000420:	48 d3 e2             	shl    %cl,%rdx
 4000423:	48 89 d0             	mov    %rdx,%rax
 4000426:	48 f7 d0             	not    %rax
 4000429:	48 23 45 f0          	and    -0x10(%rbp),%rax
}
 400042d:	5d                   	pop    %rbp
 400042e:	c3                   	ret
 400042f:	90                   	nop

0000000004000430 <LocalCPU::get_cr3_address_mask() const>:

uint64_t LocalCPU::get_cr3_address_mask() const {
 4000430:	55                   	push   %rbp
 4000431:	48 89 e5             	mov    %rsp,%rbp
 4000434:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    // 计算物理地址位宽 (MAXPHYADDR)
    const uint8_t addr_bits = max_phy_addr;
 4000438:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 400043c:	0f b6 80 c0 00 00 00 	movzbl 0xc0(%rax),%eax
 4000443:	88 45 ff             	mov    %al,-0x1(%rbp)
    
    // 生成掩码：bits [M-1:12] 为1，其余为0
    if (addr_bits <= 12) return 0;
 4000446:	80 7d ff 0c          	cmpb   $0xc,-0x1(%rbp)
 400044a:	77 07                	ja     4000453 <LocalCPU::get_cr3_address_mask() const+0x23>
 400044c:	b8 00 00 00 00       	mov    $0x0,%eax
 4000451:	eb 2e                	jmp    4000481 <LocalCPU::get_cr3_address_mask() const+0x51>
    const uint64_t addr_mask = ((1ULL << (addr_bits - 12)) - 1) << 12;
 4000453:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
 4000457:	83 e8 0c             	sub    $0xc,%eax
 400045a:	ba 01 00 00 00       	mov    $0x1,%edx
 400045f:	89 c1                	mov    %eax,%ecx
 4000461:	48 d3 e2             	shl    %cl,%rdx
 4000464:	48 89 d0             	mov    %rdx,%rax
 4000467:	48 83 e8 01          	sub    $0x1,%rax
 400046b:	48 c1 e0 0c          	shl    $0xc,%rax
 400046f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    
    // 确保不覆盖保留位和LAM位
    return addr_mask & ~CR3_LAM_MASK & ~CR3_RESERVED_MASK;
 4000473:	48 b8 ff ff ff ff ff 	movabs $0x1fffffffffffffff,%rax
 400047a:	ff ff 1f 
 400047d:	48 23 45 f0          	and    -0x10(%rbp),%rax
}
 4000481:	5d                   	pop    %rbp
 4000482:	c3                   	ret
 4000483:	90                   	nop

0000000004000484 <LocalCPU::LocalCPU()>:

LocalCPU::LocalCPU()
 4000484:	55                   	push   %rbp
 4000485:	48 89 e5             	mov    %rsp,%rbp
 4000488:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
 400048c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4000490:	c6 80 c0 00 00 00 34 	movb   $0x34,0xc0(%rax)
{
    // 读取控制寄存器
        asm volatile("mov %%cr0, %0" : "=r"(cr0));
 4000497:	0f 20 c2             	mov    %cr0,%rdx
 400049a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 400049e:	48 89 10             	mov    %rdx,(%rax)
        asm volatile("mov %%cr2, %0" : "=r"(cr2));
 40004a1:	0f 20 d2             	mov    %cr2,%rdx
 40004a4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 40004a8:	48 89 50 08          	mov    %rdx,0x8(%rax)
        asm volatile("mov %%cr3, %0" : "=r"(cr3));
 40004ac:	0f 20 da             	mov    %cr3,%rdx
 40004af:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 40004b3:	48 89 50 10          	mov    %rdx,0x10(%rax)
        asm volatile("mov %%cr4, %0" : "=r"(cr4));
 40004b7:	0f 20 e2             	mov    %cr4,%rdx
 40004ba:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 40004be:	48 89 50 18          	mov    %rdx,0x18(%rax)
        asm volatile("mov %%cr8, %0" : "=r"(cr8));
 40004c2:	44 0f 20 c2          	mov    %cr8,%rdx
 40004c6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 40004ca:	48 89 50 20          	mov    %rdx,0x20(%rax)
        
        // 读取 RFLAGS
        asm volatile("pushfq; pop %0" : "=r"(rflags));
 40004ce:	9c                   	pushf
 40004cf:	5a                   	pop    %rdx
 40004d0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 40004d4:	48 89 50 28          	mov    %rdx,0x28(%rax)
        struct {
            uint16_t limit;
            uint64_t base;
        } __attribute__((packed)) idtr_temp, gdtr_temp;
        
        asm volatile("sidt %0" : "=m"(idtr_temp));
 40004d8:	0f 01 4d f6          	sidt   -0xa(%rbp)
        asm volatile("sgdt %0" : "=m"(gdtr_temp));
 40004dc:	0f 01 45 ec          	sgdt   -0x14(%rbp)
        
        idtr.base = idtr_temp.base;
 40004e0:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
 40004e4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 40004e8:	48 89 50 30          	mov    %rdx,0x30(%rax)
        idtr.limit = idtr_temp.limit;
 40004ec:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
 40004f0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 40004f4:	66 89 50 38          	mov    %dx,0x38(%rax)
        gdtr.base = gdtr_temp.base;
 40004f8:	48 8b 55 ee          	mov    -0x12(%rbp),%rdx
 40004fc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4000500:	48 89 50 40          	mov    %rdx,0x40(%rax)
        gdtr.limit = gdtr_temp.limit;
 4000504:	0f b7 55 ec          	movzwl -0x14(%rbp),%edx
 4000508:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 400050c:	66 89 50 48          	mov    %dx,0x48(%rax)
        
        // 其他寄存器初始化为0（暂时不初始化）
        tr = 0;
 4000510:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4000514:	66 c7 40 50 00 00    	movw   $0x0,0x50(%rax)
        dr0 = dr1 = dr2 = dr3 = dr6 = dr7 = 0;
 400051a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 400051e:	48 c7 80 80 00 00 00 	movq   $0x0,0x80(%rax)
 4000525:	00 00 00 00 
 4000529:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 400052d:	48 8b 90 80 00 00 00 	mov    0x80(%rax),%rdx
 4000534:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4000538:	48 89 50 78          	mov    %rdx,0x78(%rax)
 400053c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4000540:	48 8b 50 78          	mov    0x78(%rax),%rdx
 4000544:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4000548:	48 89 50 70          	mov    %rdx,0x70(%rax)
 400054c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4000550:	48 8b 50 70          	mov    0x70(%rax),%rdx
 4000554:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4000558:	48 89 50 68          	mov    %rdx,0x68(%rax)
 400055c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4000560:	48 8b 50 68          	mov    0x68(%rax),%rdx
 4000564:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4000568:	48 89 50 60          	mov    %rdx,0x60(%rax)
 400056c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4000570:	48 8b 50 60          	mov    0x60(%rax),%rdx
 4000574:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4000578:	48 89 50 58          	mov    %rdx,0x58(%rax)
        ia32_efer = ia32_fs_base = ia32_gs_base = ia32_kernel_gs_base = ia32_lstar = 0;
 400057c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4000580:	48 c7 80 a8 00 00 00 	movq   $0x0,0xa8(%rax)
 4000587:	00 00 00 00 
 400058b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 400058f:	48 8b 90 a8 00 00 00 	mov    0xa8(%rax),%rdx
 4000596:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 400059a:	48 89 90 a0 00 00 00 	mov    %rdx,0xa0(%rax)
 40005a1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 40005a5:	48 8b 90 a0 00 00 00 	mov    0xa0(%rax),%rdx
 40005ac:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 40005b0:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
 40005b7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 40005bb:	48 8b 90 98 00 00 00 	mov    0x98(%rax),%rdx
 40005c2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 40005c6:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
 40005cd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 40005d1:	48 8b 90 90 00 00 00 	mov    0x90(%rax),%rdx
 40005d8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 40005dc:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
        mxcsr = 0;
 40005e3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 40005e7:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%rax)
 40005ee:	00 00 00 
        xcr0 = 0;
 40005f1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 40005f5:	48 c7 80 b8 00 00 00 	movq   $0x0,0xb8(%rax)
 40005fc:	00 00 00 00 
}
 4000600:	90                   	nop
 4000601:	5d                   	pop    %rbp
 4000602:	c3                   	ret
 4000603:	90                   	nop

0000000004000604 <LocalCPU::~LocalCPU()>:
LocalCPU::~LocalCPU()
 4000604:	55                   	push   %rbp
 4000605:	48 89 e5             	mov    %rsp,%rbp
 4000608:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
{
}
 400060c:	90                   	nop
 400060d:	5d                   	pop    %rbp
 400060e:	c3                   	ret
 400060f:	90                   	nop

0000000004000610 <LocalCPU::set_cr0_bit(CR0Bits, bool)>:
void LocalCPU::set_cr0_bit(CR0Bits bit, bool enable)
{
 4000610:	55                   	push   %rbp
 4000611:	48 89 e5             	mov    %rsp,%rbp
 4000614:	48 83 ec 10          	sub    $0x10,%rsp
 4000618:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
 400061c:	89 f1                	mov    %esi,%ecx
 400061e:	89 d0                	mov    %edx,%eax
 4000620:	89 ca                	mov    %ecx,%edx
 4000622:	88 55 f4             	mov    %dl,-0xc(%rbp)
 4000625:	88 45 f0             	mov    %al,-0x10(%rbp)
    if (enable) {
 4000628:	80 7d f0 00          	cmpb   $0x0,-0x10(%rbp)
 400062c:	74 23                	je     4000651 <LocalCPU::set_cr0_bit(CR0Bits, bool)+0x41>
        cr0 = set_bit(cr0, static_cast<uint8_t>(bit));
 400062e:	0f b6 55 f4          	movzbl -0xc(%rbp),%edx
 4000632:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4000636:	48 8b 08             	mov    (%rax),%rcx
 4000639:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 400063d:	48 89 ce             	mov    %rcx,%rsi
 4000640:	48 89 c7             	mov    %rax,%rdi
 4000643:	e8 94 fd ff ff       	call   40003dc <LocalCPU::set_bit(unsigned long, unsigned char) const>
 4000648:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
 400064c:	48 89 02             	mov    %rax,(%rdx)
    } else {
        cr0 = clear_bit(cr0, static_cast<uint8_t>(bit));
    }
}
 400064f:	eb 21                	jmp    4000672 <LocalCPU::set_cr0_bit(CR0Bits, bool)+0x62>
        cr0 = clear_bit(cr0, static_cast<uint8_t>(bit));
 4000651:	0f b6 55 f4          	movzbl -0xc(%rbp),%edx
 4000655:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4000659:	48 8b 08             	mov    (%rax),%rcx
 400065c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4000660:	48 89 ce             	mov    %rcx,%rsi
 4000663:	48 89 c7             	mov    %rax,%rdi
 4000666:	e8 99 fd ff ff       	call   4000404 <LocalCPU::clear_bit(unsigned long, unsigned char) const>
 400066b:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
 400066f:	48 89 02             	mov    %rax,(%rdx)
}
 4000672:	90                   	nop
 4000673:	c9                   	leave
 4000674:	c3                   	ret
 4000675:	90                   	nop

0000000004000676 <LocalCPU::set_cr4_bit(CR4Bits, bool)>:

void LocalCPU::set_cr4_bit(CR4Bits bit, bool enable) {
 4000676:	55                   	push   %rbp
 4000677:	48 89 e5             	mov    %rsp,%rbp
 400067a:	48 83 ec 10          	sub    $0x10,%rsp
 400067e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
 4000682:	89 f1                	mov    %esi,%ecx
 4000684:	89 d0                	mov    %edx,%eax
 4000686:	89 ca                	mov    %ecx,%edx
 4000688:	88 55 f4             	mov    %dl,-0xc(%rbp)
 400068b:	88 45 f0             	mov    %al,-0x10(%rbp)
    if (enable) {
 400068e:	80 7d f0 00          	cmpb   $0x0,-0x10(%rbp)
 4000692:	74 25                	je     40006b9 <LocalCPU::set_cr4_bit(CR4Bits, bool)+0x43>
        cr4 = set_bit(cr4, static_cast<uint8_t>(bit));
 4000694:	0f b6 55 f4          	movzbl -0xc(%rbp),%edx
 4000698:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 400069c:	48 8b 48 18          	mov    0x18(%rax),%rcx
 40006a0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 40006a4:	48 89 ce             	mov    %rcx,%rsi
 40006a7:	48 89 c7             	mov    %rax,%rdi
 40006aa:	e8 2d fd ff ff       	call   40003dc <LocalCPU::set_bit(unsigned long, unsigned char) const>
 40006af:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
 40006b3:	48 89 42 18          	mov    %rax,0x18(%rdx)
    } else {
        cr4 = clear_bit(cr4, static_cast<uint8_t>(bit));
    }
}
 40006b7:	eb 23                	jmp    40006dc <LocalCPU::set_cr4_bit(CR4Bits, bool)+0x66>
        cr4 = clear_bit(cr4, static_cast<uint8_t>(bit));
 40006b9:	0f b6 55 f4          	movzbl -0xc(%rbp),%edx
 40006bd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 40006c1:	48 8b 48 18          	mov    0x18(%rax),%rcx
 40006c5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 40006c9:	48 89 ce             	mov    %rcx,%rsi
 40006cc:	48 89 c7             	mov    %rax,%rdi
 40006cf:	e8 30 fd ff ff       	call   4000404 <LocalCPU::clear_bit(unsigned long, unsigned char) const>
 40006d4:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
 40006d8:	48 89 42 18          	mov    %rax,0x18(%rdx)
}
 40006dc:	90                   	nop
 40006dd:	c9                   	leave
 40006de:	c3                   	ret
 40006df:	90                   	nop

00000000040006e0 <LocalCPU::get_cr4_bit(CR4Bits) const>:

bool LocalCPU::get_cr4_bit(CR4Bits bit) const {
 40006e0:	55                   	push   %rbp
 40006e1:	48 89 e5             	mov    %rsp,%rbp
 40006e4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
 40006e8:	89 f0                	mov    %esi,%eax
 40006ea:	88 45 f4             	mov    %al,-0xc(%rbp)
    return (cr4 >> static_cast<uint8_t>(bit)) & 1;
 40006ed:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 40006f1:	48 8b 50 18          	mov    0x18(%rax),%rdx
 40006f5:	0f b6 45 f4          	movzbl -0xc(%rbp),%eax
 40006f9:	89 c1                	mov    %eax,%ecx
 40006fb:	48 d3 ea             	shr    %cl,%rdx
 40006fe:	48 89 d0             	mov    %rdx,%rax
 4000701:	83 e0 01             	and    $0x1,%eax
 4000704:	83 e0 01             	and    $0x1,%eax
}
 4000707:	5d                   	pop    %rbp
 4000708:	c3                   	ret
 4000709:	90                   	nop

000000000400070a <LocalCPU::set_cr3_base_address(unsigned long)>:

void LocalCPU::set_cr3_base_address(uint64_t base_addr) {
 400070a:	55                   	push   %rbp
 400070b:	48 89 e5             	mov    %rsp,%rbp
 400070e:	48 83 ec 20          	sub    $0x20,%rsp
 4000712:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
 4000716:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
    const uint64_t addr_mask = get_cr3_address_mask();
 400071a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 400071e:	48 89 c7             	mov    %rax,%rdi
 4000721:	e8 0a fd ff ff       	call   4000430 <LocalCPU::get_cr3_address_mask() const>
 4000726:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    
    // 4KB对齐处理
    base_addr &= ~0xFFFULL;
 400072a:	48 81 65 e0 00 f0 ff 	andq   $0xfffffffffffff000,-0x20(%rbp)
 4000731:	ff 
    
    // 根据PCIDE状态选择处理方式
    if (get_cr4_bit(CR4Bits::PCIDE)) {
 4000732:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4000736:	be 11 00 00 00       	mov    $0x11,%esi
 400073b:	48 89 c7             	mov    %rax,%rdi
 400073e:	e8 9d ff ff ff       	call   40006e0 <LocalCPU::get_cr4_bit(CR4Bits) const>
 4000743:	84 c0                	test   %al,%al
 4000745:	74 2a                	je     4000771 <LocalCPU::set_cr3_base_address(unsigned long)+0x67>
        // PCIDE=1模式：保留PCID部分
        cr3 = (cr3 & ~CR3_PCIDE1_ADDR_MASK) | (base_addr & addr_mask);
 4000747:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 400074b:	48 8b 40 10          	mov    0x10(%rax),%rax
 400074f:	48 ba ff 0f 00 00 00 	movabs $0xfff0000000000fff,%rdx
 4000756:	00 f0 ff 
 4000759:	48 21 c2             	and    %rax,%rdx
 400075c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4000760:	48 23 45 f8          	and    -0x8(%rbp),%rax
 4000764:	48 09 c2             	or     %rax,%rdx
 4000767:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 400076b:	48 89 50 10          	mov    %rdx,0x10(%rax)
 400076f:	eb 44                	jmp    40007b5 <LocalCPU::set_cr3_base_address(unsigned long)+0xab>
    } else {
        // PCIDE=0模式：保留PWT/PCD部分
        const uint64_t attr_mask = (1ULL << (uint8_t)CR3Bits::PWT) | (1ULL << (uint8_t)CR3Bits::PCD);
 4000771:	48 c7 45 f0 18 00 00 	movq   $0x18,-0x10(%rbp)
 4000778:	00 
        cr3 = (cr3 & ~addr_mask & ~CR3_PCIDE0_IGNORED_MASK) 
 4000779:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 400077d:	48 8b 50 10          	mov    0x10(%rax),%rdx
 4000781:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4000785:	48 f7 d0             	not    %rax
 4000788:	48 21 d0             	and    %rdx,%rax
 400078b:	48 25 1f f0 ff ff    	and    $0xfffffffffffff01f,%rax
 4000791:	48 89 c2             	mov    %rax,%rdx
            | (base_addr & addr_mask)
 4000794:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4000798:	48 23 45 f8          	and    -0x8(%rbp),%rax
 400079c:	48 09 c2             	or     %rax,%rdx
            | (cr3 & attr_mask);
 400079f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 40007a3:	48 8b 40 10          	mov    0x10(%rax),%rax
 40007a7:	83 e0 18             	and    $0x18,%eax
 40007aa:	48 09 c2             	or     %rax,%rdx
        cr3 = (cr3 & ~addr_mask & ~CR3_PCIDE0_IGNORED_MASK) 
 40007ad:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 40007b1:	48 89 50 10          	mov    %rdx,0x10(%rax)
    }
    
    // 强制保留位为0
    cr3 &= ~CR3_RESERVED_MASK;
 40007b5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 40007b9:	48 8b 40 10          	mov    0x10(%rax),%rax
 40007bd:	48 ba ff ff ff ff ff 	movabs $0x7fffffffffffffff,%rdx
 40007c4:	ff ff 7f 
 40007c7:	48 21 c2             	and    %rax,%rdx
 40007ca:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 40007ce:	48 89 50 10          	mov    %rdx,0x10(%rax)
}
 40007d2:	90                   	nop
 40007d3:	c9                   	leave
 40007d4:	c3                   	ret
 40007d5:	90                   	nop

00000000040007d6 <LocalCPU::set_cr3_pcid(unsigned short)>:

void LocalCPU::set_cr3_pcid(uint16_t pcid) {
 40007d6:	55                   	push   %rbp
 40007d7:	48 89 e5             	mov    %rsp,%rbp
 40007da:	48 83 ec 10          	sub    $0x10,%rsp
 40007de:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
 40007e2:	89 f0                	mov    %esi,%eax
 40007e4:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
    if (get_cr4_bit(CR4Bits::PCIDE)) {
 40007e8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 40007ec:	be 11 00 00 00       	mov    $0x11,%esi
 40007f1:	48 89 c7             	mov    %rax,%rdi
 40007f4:	e8 e7 fe ff ff       	call   40006e0 <LocalCPU::get_cr4_bit(CR4Bits) const>
 40007f9:	84 c0                	test   %al,%al
 40007fb:	74 42                	je     400083f <LocalCPU::set_cr3_pcid(unsigned short)+0x69>
        cr3 = (cr3 & ~CR3_PCID_MASK) | (pcid & 0xFFF);
 40007fd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4000801:	48 8b 40 10          	mov    0x10(%rax),%rax
 4000805:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
 400080b:	48 89 c2             	mov    %rax,%rdx
 400080e:	0f b7 45 f4          	movzwl -0xc(%rbp),%eax
 4000812:	25 ff 0f 00 00       	and    $0xfff,%eax
 4000817:	48 09 c2             	or     %rax,%rdx
 400081a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 400081e:	48 89 50 10          	mov    %rdx,0x10(%rax)
        cr3 &= ~CR3_RESERVED_MASK; // 确保保留位为0
 4000822:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4000826:	48 8b 40 10          	mov    0x10(%rax),%rax
 400082a:	48 ba ff ff ff ff ff 	movabs $0x7fffffffffffffff,%rdx
 4000831:	ff ff 7f 
 4000834:	48 21 c2             	and    %rax,%rdx
 4000837:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 400083b:	48 89 50 10          	mov    %rdx,0x10(%rax)
    }
    // PCIDE=0时忽略操作
}
 400083f:	90                   	nop
 4000840:	c9                   	leave
 4000841:	c3                   	ret

0000000004000842 <LocalCPU::set_cr3_bit(CR3Bits, bool)>:

void LocalCPU::set_cr3_bit(CR3Bits bit, bool enable) {
 4000842:	55                   	push   %rbp
 4000843:	48 89 e5             	mov    %rsp,%rbp
 4000846:	48 83 ec 20          	sub    $0x20,%rsp
 400084a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
 400084e:	89 f1                	mov    %esi,%ecx
 4000850:	89 d0                	mov    %edx,%eax
 4000852:	89 ca                	mov    %ecx,%edx
 4000854:	88 55 e4             	mov    %dl,-0x1c(%rbp)
 4000857:	88 45 e0             	mov    %al,-0x20(%rbp)
    const uint8_t pos = static_cast<uint8_t>(bit);
 400085a:	0f b6 45 e4          	movzbl -0x1c(%rbp),%eax
 400085e:	88 45 ff             	mov    %al,-0x1(%rbp)
    
    // 特殊处理：LAM48在LAM57启用时忽略
    if (bit == CR3Bits::LAM48 && (cr3 & (1ULL << (uint8_t)CR3Bits::LAM57))) {
 4000861:	80 7d e4 3e          	cmpb   $0x3e,-0x1c(%rbp)
 4000865:	75 1e                	jne    4000885 <LocalCPU::set_cr3_bit(CR3Bits, bool)+0x43>
 4000867:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 400086b:	48 8b 40 10          	mov    0x10(%rax),%rax
 400086f:	48 ba 00 00 00 00 00 	movabs $0x2000000000000000,%rdx
 4000876:	00 00 20 
 4000879:	48 21 d0             	and    %rdx,%rax
 400087c:	48 85 c0             	test   %rax,%rax
 400087f:	0f 85 ca 00 00 00    	jne    400094f <LocalCPU::set_cr3_bit(CR3Bits, bool)+0x10d>
        return; // 忽略设置
    }
    
    // 通用位设置
    if (enable) {
 4000885:	80 7d e0 00          	cmpb   $0x0,-0x20(%rbp)
 4000889:	74 26                	je     40008b1 <LocalCPU::set_cr3_bit(CR3Bits, bool)+0x6f>
        cr3 |= (1ULL << pos);
 400088b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 400088f:	48 8b 50 10          	mov    0x10(%rax),%rdx
 4000893:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
 4000897:	be 01 00 00 00       	mov    $0x1,%esi
 400089c:	89 c1                	mov    %eax,%ecx
 400089e:	48 d3 e6             	shl    %cl,%rsi
 40008a1:	48 89 f0             	mov    %rsi,%rax
 40008a4:	48 09 c2             	or     %rax,%rdx
 40008a7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 40008ab:	48 89 50 10          	mov    %rdx,0x10(%rax)
 40008af:	eb 27                	jmp    40008d8 <LocalCPU::set_cr3_bit(CR3Bits, bool)+0x96>
    } else {
        cr3 &= ~(1ULL << pos);
 40008b1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 40008b5:	48 8b 50 10          	mov    0x10(%rax),%rdx
 40008b9:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
 40008bd:	be 01 00 00 00       	mov    $0x1,%esi
 40008c2:	89 c1                	mov    %eax,%ecx
 40008c4:	48 d3 e6             	shl    %cl,%rsi
 40008c7:	48 89 f0             	mov    %rsi,%rax
 40008ca:	48 f7 d0             	not    %rax
 40008cd:	48 21 c2             	and    %rax,%rdx
 40008d0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 40008d4:	48 89 50 10          	mov    %rdx,0x10(%rax)
    }
    
    // 特殊处理：PWT/PCD仅在PCIDE=0时有效
    if ((bit == CR3Bits::PWT || bit == CR3Bits::PCD) && 
 40008d8:	80 7d e4 03          	cmpb   $0x3,-0x1c(%rbp)
 40008dc:	74 06                	je     40008e4 <LocalCPU::set_cr3_bit(CR3Bits, bool)+0xa2>
 40008de:	80 7d e4 04          	cmpb   $0x4,-0x1c(%rbp)
 40008e2:	75 1c                	jne    4000900 <LocalCPU::set_cr3_bit(CR3Bits, bool)+0xbe>
        get_cr4_bit(CR4Bits::PCIDE)) 
 40008e4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 40008e8:	be 11 00 00 00       	mov    $0x11,%esi
 40008ed:	48 89 c7             	mov    %rax,%rdi
 40008f0:	e8 eb fd ff ff       	call   40006e0 <LocalCPU::get_cr4_bit(CR4Bits) const>
    if ((bit == CR3Bits::PWT || bit == CR3Bits::PCD) && 
 40008f5:	84 c0                	test   %al,%al
 40008f7:	74 07                	je     4000900 <LocalCPU::set_cr3_bit(CR3Bits, bool)+0xbe>
 40008f9:	b8 01 00 00 00       	mov    $0x1,%eax
 40008fe:	eb 05                	jmp    4000905 <LocalCPU::set_cr3_bit(CR3Bits, bool)+0xc3>
 4000900:	b8 00 00 00 00       	mov    $0x0,%eax
 4000905:	84 c0                	test   %al,%al
 4000907:	74 27                	je     4000930 <LocalCPU::set_cr3_bit(CR3Bits, bool)+0xee>
    {
        cr3 &= ~(1ULL << pos); // 强制清除
 4000909:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 400090d:	48 8b 50 10          	mov    0x10(%rax),%rdx
 4000911:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
 4000915:	be 01 00 00 00       	mov    $0x1,%esi
 400091a:	89 c1                	mov    %eax,%ecx
 400091c:	48 d3 e6             	shl    %cl,%rsi
 400091f:	48 89 f0             	mov    %rsi,%rax
 4000922:	48 f7 d0             	not    %rax
 4000925:	48 21 c2             	and    %rax,%rdx
 4000928:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 400092c:	48 89 50 10          	mov    %rdx,0x10(%rax)
    }
    
    // 强制保留位为0
    cr3 &= ~CR3_RESERVED_MASK;
 4000930:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4000934:	48 8b 40 10          	mov    0x10(%rax),%rax
 4000938:	48 ba ff ff ff ff ff 	movabs $0x7fffffffffffffff,%rdx
 400093f:	ff ff 7f 
 4000942:	48 21 c2             	and    %rax,%rdx
 4000945:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4000949:	48 89 50 10          	mov    %rdx,0x10(%rax)
 400094d:	eb 01                	jmp    4000950 <LocalCPU::set_cr3_bit(CR3Bits, bool)+0x10e>
        return; // 忽略设置
 400094f:	90                   	nop
}
 4000950:	c9                   	leave
 4000951:	c3                   	ret

0000000004000952 <LocalCPU::get_cr3_base_address() const>:

uint64_t LocalCPU::get_cr3_base_address() const {
 4000952:	55                   	push   %rbp
 4000953:	48 89 e5             	mov    %rsp,%rbp
 4000956:	53                   	push   %rbx
 4000957:	48 83 ec 08          	sub    $0x8,%rsp
 400095b:	48 89 7d f0          	mov    %rdi,-0x10(%rbp)
    return cr3 & get_cr3_address_mask();
 400095f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 4000963:	48 8b 58 10          	mov    0x10(%rax),%rbx
 4000967:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 400096b:	48 89 c7             	mov    %rax,%rdi
 400096e:	e8 bd fa ff ff       	call   4000430 <LocalCPU::get_cr3_address_mask() const>
 4000973:	48 21 d8             	and    %rbx,%rax
}
 4000976:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
 400097a:	c9                   	leave
 400097b:	c3                   	ret

000000000400097c <LocalCPU::get_cr3_pcid() const>:

uint16_t LocalCPU::get_cr3_pcid() const {
 400097c:	55                   	push   %rbp
 400097d:	48 89 e5             	mov    %rsp,%rbp
 4000980:	48 83 ec 08          	sub    $0x8,%rsp
 4000984:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    return (get_cr4_bit(CR4Bits::PCIDE)) ? (cr3 & 0xFFF) : 0;
 4000988:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 400098c:	be 11 00 00 00       	mov    $0x11,%esi
 4000991:	48 89 c7             	mov    %rax,%rdi
 4000994:	e8 47 fd ff ff       	call   40006e0 <LocalCPU::get_cr4_bit(CR4Bits) const>
 4000999:	84 c0                	test   %al,%al
 400099b:	74 0e                	je     40009ab <LocalCPU::get_cr3_pcid() const+0x2f>
 400099d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 40009a1:	48 8b 40 10          	mov    0x10(%rax),%rax
 40009a5:	66 25 ff 0f          	and    $0xfff,%ax
 40009a9:	eb 05                	jmp    40009b0 <LocalCPU::get_cr3_pcid() const+0x34>
 40009ab:	b8 00 00 00 00       	mov    $0x0,%eax
}
 40009b0:	c9                   	leave
 40009b1:	c3                   	ret

00000000040009b2 <LocalCPU::get_cr0() const>:
// 辅助函数实现

// CR0 相关接口实现
uint64_t LocalCPU::get_cr0() const {
 40009b2:	55                   	push   %rbp
 40009b3:	48 89 e5             	mov    %rsp,%rbp
 40009b6:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    return cr0;
 40009ba:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 40009be:	48 8b 00             	mov    (%rax),%rax
}
 40009c1:	5d                   	pop    %rbp
 40009c2:	c3                   	ret
 40009c3:	90                   	nop

00000000040009c4 <LocalCPU::set_cr0(unsigned long)>:

void LocalCPU::set_cr0(uint64_t value) {
 40009c4:	55                   	push   %rbp
 40009c5:	48 89 e5             	mov    %rsp,%rbp
 40009c8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
 40009cc:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
    // 在实际内核中，这里可以添加权限检查
    cr0 = value;
 40009d0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 40009d4:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
 40009d8:	48 89 10             	mov    %rdx,(%rax)
}
 40009db:	90                   	nop
 40009dc:	5d                   	pop    %rbp
 40009dd:	c3                   	ret

00000000040009de <LocalCPU::load_cr0()>:

void LocalCPU::load_cr0() {
 40009de:	55                   	push   %rbp
 40009df:	48 89 e5             	mov    %rsp,%rbp
 40009e2:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    // 内联汇编实现将cr0加载到物理寄存器
    asm volatile (
        "mov %0, %%cr0"
        : // 无输出
        : "r" (cr0)
 40009e6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 40009ea:	48 8b 00             	mov    (%rax),%rax
    asm volatile (
 40009ed:	0f 22 c0             	mov    %rax,%cr0
        : "memory"
    );
}
 40009f0:	90                   	nop
 40009f1:	5d                   	pop    %rbp
 40009f2:	c3                   	ret
 40009f3:	90                   	nop

00000000040009f4 <LocalCPU::get_cr0_bit(CR0Bits) const>:

bool LocalCPU::get_cr0_bit(CR0Bits bit) const {
 40009f4:	55                   	push   %rbp
 40009f5:	48 89 e5             	mov    %rsp,%rbp
 40009f8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
 40009fc:	89 f0                	mov    %esi,%eax
 40009fe:	88 45 e4             	mov    %al,-0x1c(%rbp)
    uint8_t bit_pos = static_cast<uint8_t>(bit);
 4000a01:	0f b6 45 e4          	movzbl -0x1c(%rbp),%eax
 4000a05:	88 45 ff             	mov    %al,-0x1(%rbp)
    return (cr0 & (1ULL << bit_pos)) != 0;
 4000a08:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4000a0c:	48 8b 10             	mov    (%rax),%rdx
 4000a0f:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
 4000a13:	89 c1                	mov    %eax,%ecx
 4000a15:	48 d3 ea             	shr    %cl,%rdx
 4000a18:	48 89 d0             	mov    %rdx,%rax
 4000a1b:	83 e0 01             	and    $0x1,%eax
 4000a1e:	83 e0 01             	and    $0x1,%eax
}
 4000a21:	5d                   	pop    %rbp
 4000a22:	c3                   	ret
 4000a23:	90                   	nop

0000000004000a24 <LocalCPU::get_cr4() const>:

// CR4 相关接口实现
uint64_t LocalCPU::get_cr4() const {
 4000a24:	55                   	push   %rbp
 4000a25:	48 89 e5             	mov    %rsp,%rbp
 4000a28:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    return cr4;
 4000a2c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4000a30:	48 8b 40 18          	mov    0x18(%rax),%rax
}
 4000a34:	5d                   	pop    %rbp
 4000a35:	c3                   	ret

0000000004000a36 <LocalCPU::set_cr4(unsigned long)>:

void LocalCPU::set_cr4(uint64_t value) {
 4000a36:	55                   	push   %rbp
 4000a37:	48 89 e5             	mov    %rsp,%rbp
 4000a3a:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
 4000a3e:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
    // 在实际内核中，这里可以添加权限检查
    cr4 = value;
 4000a42:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4000a46:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
 4000a4a:	48 89 50 18          	mov    %rdx,0x18(%rax)
}
 4000a4e:	90                   	nop
 4000a4f:	5d                   	pop    %rbp
 4000a50:	c3                   	ret
 4000a51:	90                   	nop

0000000004000a52 <LocalCPU::load_cr4()>:

void LocalCPU::load_cr4() {
 4000a52:	55                   	push   %rbp
 4000a53:	48 89 e5             	mov    %rsp,%rbp
 4000a56:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    // 内联汇编实现将cr4加载到物理寄存器
    asm volatile (
        "mov %0, %%cr4"
        : // 无输出
        : "r" (cr4)
 4000a5a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4000a5e:	48 8b 40 18          	mov    0x18(%rax),%rax
    asm volatile (
 4000a62:	0f 22 e0             	mov    %rax,%cr4
        : "memory"
    );
}
 4000a65:	90                   	nop
 4000a66:	5d                   	pop    %rbp
 4000a67:	c3                   	ret

0000000004000a68 <LocalCPU::get_cr3() const>:

// CR3 相关接口实现
uint64_t LocalCPU::get_cr3() const {
 4000a68:	55                   	push   %rbp
 4000a69:	48 89 e5             	mov    %rsp,%rbp
 4000a6c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    return cr3;
 4000a70:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4000a74:	48 8b 40 10          	mov    0x10(%rax),%rax
}
 4000a78:	5d                   	pop    %rbp
 4000a79:	c3                   	ret

0000000004000a7a <LocalCPU::set_cr3(unsigned long)>:

void LocalCPU::set_cr3(uint64_t value) {
 4000a7a:	55                   	push   %rbp
 4000a7b:	48 89 e5             	mov    %rsp,%rbp
 4000a7e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
 4000a82:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
    // 在实际内核中，这里可以添加权限检查
    cr3 = value;
 4000a86:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4000a8a:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
 4000a8e:	48 89 50 10          	mov    %rdx,0x10(%rax)
}
 4000a92:	90                   	nop
 4000a93:	5d                   	pop    %rbp
 4000a94:	c3                   	ret
 4000a95:	90                   	nop

0000000004000a96 <LocalCPU::load_cr3()>:

void LocalCPU::load_cr3() {
 4000a96:	55                   	push   %rbp
 4000a97:	48 89 e5             	mov    %rsp,%rbp
 4000a9a:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    // 内联汇编实现将cr3加载到物理寄存器
    asm volatile (
        "mov %0, %%cr3"
        : // 无输出
        : "r" (cr3)
 4000a9e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4000aa2:	48 8b 40 10          	mov    0x10(%rax),%rax
    asm volatile (
 4000aa6:	0f 22 d8             	mov    %rax,%cr3
        : "memory"
    );
}
 4000aa9:	90                   	nop
 4000aaa:	5d                   	pop    %rbp
 4000aab:	c3                   	ret

0000000004000aac <LocalCPU::get_cr2() const>:




// CR2 相关接口实现
uint64_t LocalCPU::get_cr2() const {
 4000aac:	55                   	push   %rbp
 4000aad:	48 89 e5             	mov    %rsp,%rbp
 4000ab0:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    return cr2;
 4000ab4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4000ab8:	48 8b 40 08          	mov    0x8(%rax),%rax
}
 4000abc:	5d                   	pop    %rbp
 4000abd:	c3                   	ret

0000000004000abe <LocalCPU::set_cr2(unsigned long)>:

void LocalCPU::set_cr2(uint64_t value) {
 4000abe:	55                   	push   %rbp
 4000abf:	48 89 e5             	mov    %rsp,%rbp
 4000ac2:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
 4000ac6:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
    // 在实际内核中，这里可以添加权限检查
    cr2 = value;
 4000aca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4000ace:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
 4000ad2:	48 89 50 08          	mov    %rdx,0x8(%rax)
}
 4000ad6:	90                   	nop
 4000ad7:	5d                   	pop    %rbp
 4000ad8:	c3                   	ret
 4000ad9:	90                   	nop

0000000004000ada <LocalCPU::load_cr2()>:

void LocalCPU::load_cr2() {
 4000ada:	55                   	push   %rbp
 4000adb:	48 89 e5             	mov    %rsp,%rbp
 4000ade:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    // 内联汇编实现将cr2加载到物理寄存器
    asm volatile (
        "mov %0, %%cr2"
        : // 无输出
        : "r" (cr2)
 4000ae2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4000ae6:	48 8b 40 08          	mov    0x8(%rax),%rax
    asm volatile (
 4000aea:	0f 22 d0             	mov    %rax,%cr2
        : "memory"
    );
}
 4000aed:	90                   	nop
 4000aee:	5d                   	pop    %rbp
 4000aef:	c3                   	ret

0000000004000af0 <LocalCPU::get_cr8() const>:

// CR8 相关接口实现
uint64_t LocalCPU::get_cr8() const {
 4000af0:	55                   	push   %rbp
 4000af1:	48 89 e5             	mov    %rsp,%rbp
 4000af4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    return cr8;
 4000af8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4000afc:	48 8b 40 20          	mov    0x20(%rax),%rax
}
 4000b00:	5d                   	pop    %rbp
 4000b01:	c3                   	ret

0000000004000b02 <LocalCPU::set_cr8(unsigned long)>:

void LocalCPU::set_cr8(uint64_t value) {
 4000b02:	55                   	push   %rbp
 4000b03:	48 89 e5             	mov    %rsp,%rbp
 4000b06:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
 4000b0a:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
    // 在实际内核中，这里可以添加权限检查
    cr8 = value;
 4000b0e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4000b12:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
 4000b16:	48 89 50 20          	mov    %rdx,0x20(%rax)
}
 4000b1a:	90                   	nop
 4000b1b:	5d                   	pop    %rbp
 4000b1c:	c3                   	ret
 4000b1d:	90                   	nop

0000000004000b1e <LocalCPU::load_cr8()>:

void LocalCPU::load_cr8() {
 4000b1e:	55                   	push   %rbp
 4000b1f:	48 89 e5             	mov    %rsp,%rbp
 4000b22:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    // 内联汇编实现将cr8加载到物理寄存器
    asm volatile (
        "mov %0, %%cr8"
        : // 无输出
        : "r" (cr8)
 4000b26:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4000b2a:	48 8b 40 20          	mov    0x20(%rax),%rax
    asm volatile (
 4000b2e:	44 0f 22 c0          	mov    %rax,%cr8
        : "memory"
    );
 4000b32:	90                   	nop
 4000b33:	5d                   	pop    %rbp
 4000b34:	c3                   	ret
 4000b35:	90                   	nop

0000000004000b36 <GlobalMemoryPGlevelMgr_t::GlobalMemoryPGlevelMgr_t()>:
#define PAGE_SIZE 0x1000
#define PAGE_SIZE_4KB 0x1000
GlobalMemoryPGlevelMgr_t gBaseMemMgr;
//efi内存描述符表id为0,操作系统自己维护的内存描述符表id为1
// 默认构造函数
GlobalMemoryPGlevelMgr_t::GlobalMemoryPGlevelMgr_t() {
 4000b36:	55                   	push   %rbp
 4000b37:	48 89 e5             	mov    %rsp,%rbp
 4000b3a:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    // 初始化成员变量
    rootPhyMemDscptTbBsPtr = nullptr;
 4000b3e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4000b42:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    EfiMemMapEntryCount = 0;
 4000b49:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4000b4d:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
 4000b54:	00 

}
 4000b55:	90                   	nop
 4000b56:	5d                   	pop    %rbp
 4000b57:	c3                   	ret

0000000004000b58 <GlobalMemoryPGlevelMgr_t::GlobalMemoryPGlevelMgr_t(EFI_MEMORY_DESCRIPTORX64*, unsigned long)>:



GlobalMemoryPGlevelMgr_t::GlobalMemoryPGlevelMgr_t(EFI_MEMORY_DESCRIPTORX64* gEfiMemdescriptromap, uint64_t entryCount) {
 4000b58:	55                   	push   %rbp
 4000b59:	48 89 e5             	mov    %rsp,%rbp
 4000b5c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
 4000b60:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
 4000b64:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
    EfiMemMap = gEfiMemdescriptromap;
 4000b68:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4000b6c:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
 4000b70:	48 89 50 08          	mov    %rdx,0x8(%rax)
    EfiMemMapEntryCount = entryCount;
 4000b74:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4000b78:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
 4000b7c:	48 89 50 10          	mov    %rdx,0x10(%rax)
    // KSCR3 需要通过其他方式初始化
}
 4000b80:	90                   	nop
 4000b81:	5d                   	pop    %rbp
 4000b82:	c3                   	ret
 4000b83:	90                   	nop

0000000004000b84 <GlobalMemoryPGlevelMgr_t::Init(EFI_MEMORY_DESCRIPTORX64*, unsigned long)>:
void GlobalMemoryPGlevelMgr_t::Init(EFI_MEMORY_DESCRIPTORX64* gEfiMemdescriptromap, uint64_t entryCount)

{
 4000b84:	55                   	push   %rbp
 4000b85:	48 89 e5             	mov    %rsp,%rbp
 4000b88:	48 83 ec 30          	sub    $0x30,%rsp
 4000b8c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
 4000b90:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
 4000b94:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
    EfiMemMap = gEfiMemdescriptromap;
 4000b98:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4000b9c:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
 4000ba0:	48 89 50 08          	mov    %rdx,0x8(%rax)
    EfiMemMapEntryCount = entryCount;
 4000ba4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4000ba8:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
 4000bac:	48 89 50 10          	mov    %rdx,0x10(%rax)
    for (int i = entryCount-1; i >=0; i--)
 4000bb0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4000bb4:	83 e8 01             	sub    $0x1,%eax
 4000bb7:	89 45 fc             	mov    %eax,-0x4(%rbp)
 4000bba:	eb 61                	jmp    4000c1d <GlobalMemoryPGlevelMgr_t::Init(EFI_MEMORY_DESCRIPTORX64*, unsigned long)+0x99>
    {
       if (gEfiMemdescriptromap[i].NumberOfPages==0&&gEfiMemdescriptromap[i].Type==EfiReservedMemoryType)
 4000bbc:	8b 45 fc             	mov    -0x4(%rbp),%eax
 4000bbf:	48 63 d0             	movslq %eax,%rdx
 4000bc2:	48 89 d0             	mov    %rdx,%rax
 4000bc5:	48 01 c0             	add    %rax,%rax
 4000bc8:	48 01 d0             	add    %rdx,%rax
 4000bcb:	48 c1 e0 04          	shl    $0x4,%rax
 4000bcf:	48 89 c2             	mov    %rax,%rdx
 4000bd2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4000bd6:	48 01 d0             	add    %rdx,%rax
 4000bd9:	48 8b 40 18          	mov    0x18(%rax),%rax
 4000bdd:	48 85 c0             	test   %rax,%rax
 4000be0:	75 41                	jne    4000c23 <GlobalMemoryPGlevelMgr_t::Init(EFI_MEMORY_DESCRIPTORX64*, unsigned long)+0x9f>
 4000be2:	8b 45 fc             	mov    -0x4(%rbp),%eax
 4000be5:	48 63 d0             	movslq %eax,%rdx
 4000be8:	48 89 d0             	mov    %rdx,%rax
 4000beb:	48 01 c0             	add    %rax,%rax
 4000bee:	48 01 d0             	add    %rdx,%rax
 4000bf1:	48 c1 e0 04          	shl    $0x4,%rax
 4000bf5:	48 89 c2             	mov    %rax,%rdx
 4000bf8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4000bfc:	48 01 d0             	add    %rdx,%rax
 4000bff:	8b 00                	mov    (%rax),%eax
 4000c01:	85 c0                	test   %eax,%eax
 4000c03:	75 1e                	jne    4000c23 <GlobalMemoryPGlevelMgr_t::Init(EFI_MEMORY_DESCRIPTORX64*, unsigned long)+0x9f>
       {
        EfiMemMapEntryCount--;
 4000c05:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4000c09:	48 8b 40 10          	mov    0x10(%rax),%rax
 4000c0d:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
 4000c11:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4000c15:	48 89 50 10          	mov    %rdx,0x10(%rax)
    for (int i = entryCount-1; i >=0; i--)
 4000c19:	83 6d fc 01          	subl   $0x1,-0x4(%rbp)
 4000c1d:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
 4000c21:	79 99                	jns    4000bbc <GlobalMemoryPGlevelMgr_t::Init(EFI_MEMORY_DESCRIPTORX64*, unsigned long)+0x38>
       }else{
        break;
       }
    }//删除那些留有冗余的表

    reclaimBootTimeMemoryonEfiTb();
 4000c23:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4000c27:	48 89 c7             	mov    %rax,%rdi
 4000c2a:	e8 a1 04 00 00       	call   40010d0 <GlobalMemoryPGlevelMgr_t::reclaimBootTimeMemoryonEfiTb()>
    InitrootPhyMemDscptTbBsPtr();
 4000c2f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4000c33:	48 89 c7             	mov    %rax,%rdi
 4000c36:	e8 bd 06 00 00       	call   40012f8 <GlobalMemoryPGlevelMgr_t::InitrootPhyMemDscptTbBsPtr()>
    //再正式回收loadercode,loaderdata类型的内存（只对PhyMemDscptTb这个表回收），参照reclaimBootTimeMemoryonEfiTb()这个函数，注意回收不标记为Runtime参数的项
    for (int i = rootPhymemTbentryCount-1; i >=0; i--)
 4000c3b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4000c3f:	48 8b 40 18          	mov    0x18(%rax),%rax
 4000c43:	83 e8 01             	sub    $0x1,%eax
 4000c46:	89 45 f8             	mov    %eax,-0x8(%rbp)
 4000c49:	eb 3b                	jmp    4000c86 <GlobalMemoryPGlevelMgr_t::Init(EFI_MEMORY_DESCRIPTORX64*, unsigned long)+0x102>
    {
       if (rootPhyMemDscptTbBsPtr[i].Type==EfiReservedMemoryType)
 4000c4b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4000c4f:	48 8b 08             	mov    (%rax),%rcx
 4000c52:	8b 45 f8             	mov    -0x8(%rbp),%eax
 4000c55:	48 63 d0             	movslq %eax,%rdx
 4000c58:	48 89 d0             	mov    %rdx,%rax
 4000c5b:	48 01 c0             	add    %rax,%rax
 4000c5e:	48 01 d0             	add    %rdx,%rax
 4000c61:	48 c1 e0 04          	shl    $0x4,%rax
 4000c65:	48 01 c8             	add    %rcx,%rax
 4000c68:	8b 00                	mov    (%rax),%eax
 4000c6a:	85 c0                	test   %eax,%eax
 4000c6c:	75 20                	jne    4000c8e <GlobalMemoryPGlevelMgr_t::Init(EFI_MEMORY_DESCRIPTORX64*, unsigned long)+0x10a>
       {
        rootPhymemTbentryCount--;
 4000c6e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4000c72:	48 8b 40 18          	mov    0x18(%rax),%rax
 4000c76:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
 4000c7a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4000c7e:	48 89 50 18          	mov    %rdx,0x18(%rax)
    for (int i = rootPhymemTbentryCount-1; i >=0; i--)
 4000c82:	83 6d f8 01          	subl   $0x1,-0x8(%rbp)
 4000c86:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
 4000c8a:	79 bf                	jns    4000c4b <GlobalMemoryPGlevelMgr_t::Init(EFI_MEMORY_DESCRIPTORX64*, unsigned long)+0xc7>
 4000c8c:	eb 01                	jmp    4000c8f <GlobalMemoryPGlevelMgr_t::Init(EFI_MEMORY_DESCRIPTORX64*, unsigned long)+0x10b>
        
       }else{
        break;
 4000c8e:	90                   	nop
       }
    }
    max_phy_addr=rootPhyMemDscptTbBsPtr[rootPhymemTbentryCount-1].PhysicalStart+\
 4000c8f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4000c93:	48 8b 08             	mov    (%rax),%rcx
 4000c96:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4000c9a:	48 8b 50 18          	mov    0x18(%rax),%rdx
 4000c9e:	48 89 d0             	mov    %rdx,%rax
 4000ca1:	48 01 c0             	add    %rax,%rax
 4000ca4:	48 01 d0             	add    %rdx,%rax
 4000ca7:	48 c1 e0 04          	shl    $0x4,%rax
 4000cab:	48 83 e8 30          	sub    $0x30,%rax
 4000caf:	48 01 c8             	add    %rcx,%rax
 4000cb2:	48 8b 48 08          	mov    0x8(%rax),%rcx
    rootPhyMemDscptTbBsPtr[rootPhymemTbentryCount-1].NumberOfPages*PAGE_SIZE_4KB;
 4000cb6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4000cba:	48 8b 30             	mov    (%rax),%rsi
 4000cbd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4000cc1:	48 8b 50 18          	mov    0x18(%rax),%rdx
 4000cc5:	48 89 d0             	mov    %rdx,%rax
 4000cc8:	48 01 c0             	add    %rax,%rax
 4000ccb:	48 01 d0             	add    %rdx,%rax
 4000cce:	48 c1 e0 04          	shl    $0x4,%rax
 4000cd2:	48 83 e8 30          	sub    $0x30,%rax
 4000cd6:	48 01 f0             	add    %rsi,%rax
 4000cd9:	48 8b 40 18          	mov    0x18(%rax),%rax
 4000cdd:	48 c1 e0 0c          	shl    $0xc,%rax
    max_phy_addr=rootPhyMemDscptTbBsPtr[rootPhymemTbentryCount-1].PhysicalStart+\
 4000ce1:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
 4000ce5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4000ce9:	48 89 50 28          	mov    %rdx,0x28(%rax)
    //删除那些留有冗余的表
    Statusflags=1;
 4000ced:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4000cf1:	48 c7 40 20 01 00 00 	movq   $0x1,0x20(%rax)
 4000cf8:	00 
}
 4000cf9:	90                   	nop
 4000cfa:	c9                   	leave
 4000cfb:	c3                   	ret

0000000004000cfc <GlobalMemoryPGlevelMgr_t::getGlobalPhysicalMemoryInfo()>:
phy_memDesriptor *GlobalMemoryPGlevelMgr_t::getGlobalPhysicalMemoryInfo()
{
 4000cfc:	55                   	push   %rbp
 4000cfd:	48 89 e5             	mov    %rsp,%rbp
 4000d00:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    return rootPhyMemDscptTbBsPtr;
 4000d04:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4000d08:	48 8b 00             	mov    (%rax),%rax
}
 4000d0b:	5d                   	pop    %rbp
 4000d0c:	c3                   	ret
 4000d0d:	90                   	nop

0000000004000d0e <GlobalMemoryPGlevelMgr_t::getRootPhysicalMemoryDescriptorTableEntryCount()>:
uint64_t GlobalMemoryPGlevelMgr_t::getRootPhysicalMemoryDescriptorTableEntryCount()
{
 4000d0e:	55                   	push   %rbp
 4000d0f:	48 89 e5             	mov    %rsp,%rbp
 4000d12:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    return rootPhymemTbentryCount;
 4000d16:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4000d1a:	48 8b 40 18          	mov    0x18(%rax),%rax
}
 4000d1e:	5d                   	pop    %rbp
 4000d1f:	c3                   	ret

0000000004000d20 <GlobalMemoryPGlevelMgr_t::queryPhysicalMemoryUsage(unsigned long)>:
phy_memDesriptor *GlobalMemoryPGlevelMgr_t::queryPhysicalMemoryUsage(uint64_t addr)
{
 4000d20:	55                   	push   %rbp
 4000d21:	48 89 e5             	mov    %rsp,%rbp
 4000d24:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
 4000d28:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
    for(int i = 0; i < rootPhymemTbentryCount; i++)
 4000d2c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
 4000d33:	e9 99 00 00 00       	jmp    4000dd1 <GlobalMemoryPGlevelMgr_t::queryPhysicalMemoryUsage(unsigned long)+0xb1>
    {
        if (rootPhyMemDscptTbBsPtr[i].PhysicalStart<=addr&&addr<
 4000d38:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4000d3c:	48 8b 08             	mov    (%rax),%rcx
 4000d3f:	8b 45 fc             	mov    -0x4(%rbp),%eax
 4000d42:	48 63 d0             	movslq %eax,%rdx
 4000d45:	48 89 d0             	mov    %rdx,%rax
 4000d48:	48 01 c0             	add    %rax,%rax
 4000d4b:	48 01 d0             	add    %rdx,%rax
 4000d4e:	48 c1 e0 04          	shl    $0x4,%rax
 4000d52:	48 01 c8             	add    %rcx,%rax
 4000d55:	48 8b 40 08          	mov    0x8(%rax),%rax
 4000d59:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
 4000d5d:	72 6e                	jb     4000dcd <GlobalMemoryPGlevelMgr_t::queryPhysicalMemoryUsage(unsigned long)+0xad>
            rootPhyMemDscptTbBsPtr[i].PhysicalStart+rootPhyMemDscptTbBsPtr[i].NumberOfPages*PAGE_SIZE_4KB)
 4000d5f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4000d63:	48 8b 08             	mov    (%rax),%rcx
 4000d66:	8b 45 fc             	mov    -0x4(%rbp),%eax
 4000d69:	48 63 d0             	movslq %eax,%rdx
 4000d6c:	48 89 d0             	mov    %rdx,%rax
 4000d6f:	48 01 c0             	add    %rax,%rax
 4000d72:	48 01 d0             	add    %rdx,%rax
 4000d75:	48 c1 e0 04          	shl    $0x4,%rax
 4000d79:	48 01 c8             	add    %rcx,%rax
 4000d7c:	48 8b 48 08          	mov    0x8(%rax),%rcx
 4000d80:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4000d84:	48 8b 30             	mov    (%rax),%rsi
 4000d87:	8b 45 fc             	mov    -0x4(%rbp),%eax
 4000d8a:	48 63 d0             	movslq %eax,%rdx
 4000d8d:	48 89 d0             	mov    %rdx,%rax
 4000d90:	48 01 c0             	add    %rax,%rax
 4000d93:	48 01 d0             	add    %rdx,%rax
 4000d96:	48 c1 e0 04          	shl    $0x4,%rax
 4000d9a:	48 01 f0             	add    %rsi,%rax
 4000d9d:	48 8b 40 18          	mov    0x18(%rax),%rax
 4000da1:	48 c1 e0 0c          	shl    $0xc,%rax
 4000da5:	48 01 c8             	add    %rcx,%rax
        if (rootPhyMemDscptTbBsPtr[i].PhysicalStart<=addr&&addr<
 4000da8:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
 4000dac:	73 1f                	jae    4000dcd <GlobalMemoryPGlevelMgr_t::queryPhysicalMemoryUsage(unsigned long)+0xad>
        {
            return rootPhyMemDscptTbBsPtr+i;
 4000dae:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4000db2:	48 8b 08             	mov    (%rax),%rcx
 4000db5:	8b 45 fc             	mov    -0x4(%rbp),%eax
 4000db8:	48 63 d0             	movslq %eax,%rdx
 4000dbb:	48 89 d0             	mov    %rdx,%rax
 4000dbe:	48 01 c0             	add    %rax,%rax
 4000dc1:	48 01 d0             	add    %rdx,%rax
 4000dc4:	48 c1 e0 04          	shl    $0x4,%rax
 4000dc8:	48 01 c8             	add    %rcx,%rax
 4000dcb:	eb 20                	jmp    4000ded <GlobalMemoryPGlevelMgr_t::queryPhysicalMemoryUsage(unsigned long)+0xcd>
    for(int i = 0; i < rootPhymemTbentryCount; i++)
 4000dcd:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
 4000dd1:	8b 45 fc             	mov    -0x4(%rbp),%eax
 4000dd4:	48 63 d0             	movslq %eax,%rdx
 4000dd7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4000ddb:	48 8b 40 18          	mov    0x18(%rax),%rax
 4000ddf:	48 39 c2             	cmp    %rax,%rdx
 4000de2:	0f 82 50 ff ff ff    	jb     4000d38 <GlobalMemoryPGlevelMgr_t::queryPhysicalMemoryUsage(unsigned long)+0x18>
        }
        
    }
    return NULL;
 4000de8:	b8 00 00 00 00       	mov    $0x0,%eax
}
 4000ded:	5d                   	pop    %rbp
 4000dee:	c3                   	ret
 4000def:	90                   	nop

0000000004000df0 <GlobalMemoryPGlevelMgr_t::dirtyentrydelete(unsigned long)>:
void GlobalMemoryPGlevelMgr_t::dirtyentrydelete(uint64_t tbid)
{//双指针法从尾部删除脏项
 4000df0:	55                   	push   %rbp
 4000df1:	48 89 e5             	mov    %rsp,%rbp
 4000df4:	48 83 ec 20          	sub    $0x20,%rsp
 4000df8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
 4000dfc:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
     switch (tbid)
 4000e00:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
 4000e05:	74 10                	je     4000e17 <GlobalMemoryPGlevelMgr_t::dirtyentrydelete(unsigned long)+0x27>
 4000e07:	48 83 7d e0 01       	cmpq   $0x1,-0x20(%rbp)
 4000e0c:	0f 84 64 01 00 00    	je     4000f76 <GlobalMemoryPGlevelMgr_t::dirtyentrydelete(unsigned long)+0x186>
                if(slowindex_stop==false&&slow_index>0)slow_index--;
            }
            }
        break;
    default:
        break;
 4000e12:	e9 b5 02 00 00       	jmp    40010cc <GlobalMemoryPGlevelMgr_t::dirtyentrydelete(unsigned long)+0x2dc>
        fast_index=slow_index=EfiMemMapEntryCount-1;    
 4000e17:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4000e1b:	48 8b 40 10          	mov    0x10(%rax),%rax
 4000e1f:	83 e8 01             	sub    $0x1,%eax
 4000e22:	89 45 f8             	mov    %eax,-0x8(%rbp)
 4000e25:	8b 45 f8             	mov    -0x8(%rbp),%eax
 4000e28:	89 45 fc             	mov    %eax,-0x4(%rbp)
            if(fast_index==0&&slow_index==0)break;
 4000e2b:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
 4000e2f:	75 0a                	jne    4000e3b <GlobalMemoryPGlevelMgr_t::dirtyentrydelete(unsigned long)+0x4b>
 4000e31:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
 4000e35:	0f 84 35 01 00 00    	je     4000f70 <GlobalMemoryPGlevelMgr_t::dirtyentrydelete(unsigned long)+0x180>
            bool fastindex_stop=EfiMemMap[fast_index].ReservedUnion.TmpChainList.Flags==DIRTY_ENTRY\
 4000e3b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4000e3f:	48 8b 48 08          	mov    0x8(%rax),%rcx
 4000e43:	8b 45 fc             	mov    -0x4(%rbp),%eax
 4000e46:	48 63 d0             	movslq %eax,%rdx
 4000e49:	48 89 d0             	mov    %rdx,%rax
 4000e4c:	48 01 c0             	add    %rax,%rax
 4000e4f:	48 01 d0             	add    %rdx,%rax
 4000e52:	48 c1 e0 04          	shl    $0x4,%rax
 4000e56:	48 01 c8             	add    %rcx,%rax
 4000e59:	0f b7 40 06          	movzwl 0x6(%rax),%eax
            &&EfiMemMap[fast_index-1].ReservedUnion.TmpChainList.Flags==CLEAN_ENTRY;
 4000e5d:	66 83 f8 01          	cmp    $0x1,%ax
 4000e61:	75 32                	jne    4000e95 <GlobalMemoryPGlevelMgr_t::dirtyentrydelete(unsigned long)+0xa5>
 4000e63:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4000e67:	48 8b 48 08          	mov    0x8(%rax),%rcx
 4000e6b:	8b 45 fc             	mov    -0x4(%rbp),%eax
 4000e6e:	48 63 d0             	movslq %eax,%rdx
 4000e71:	48 89 d0             	mov    %rdx,%rax
 4000e74:	48 01 c0             	add    %rax,%rax
 4000e77:	48 01 d0             	add    %rdx,%rax
 4000e7a:	48 c1 e0 04          	shl    $0x4,%rax
 4000e7e:	48 83 e8 30          	sub    $0x30,%rax
 4000e82:	48 01 c8             	add    %rcx,%rax
 4000e85:	0f b7 40 06          	movzwl 0x6(%rax),%eax
 4000e89:	66 85 c0             	test   %ax,%ax
 4000e8c:	75 07                	jne    4000e95 <GlobalMemoryPGlevelMgr_t::dirtyentrydelete(unsigned long)+0xa5>
 4000e8e:	b8 01 00 00 00       	mov    $0x1,%eax
 4000e93:	eb 05                	jmp    4000e9a <GlobalMemoryPGlevelMgr_t::dirtyentrydelete(unsigned long)+0xaa>
 4000e95:	b8 00 00 00 00       	mov    $0x0,%eax
            bool fastindex_stop=EfiMemMap[fast_index].ReservedUnion.TmpChainList.Flags==DIRTY_ENTRY\
 4000e9a:	88 45 f5             	mov    %al,-0xb(%rbp)
            bool slowindex_stop=EfiMemMap[slow_index].ReservedUnion.TmpChainList.Flags==CLEAN_ENTRY\
 4000e9d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4000ea1:	48 8b 48 08          	mov    0x8(%rax),%rcx
 4000ea5:	8b 45 f8             	mov    -0x8(%rbp),%eax
 4000ea8:	48 63 d0             	movslq %eax,%rdx
 4000eab:	48 89 d0             	mov    %rdx,%rax
 4000eae:	48 01 c0             	add    %rax,%rax
 4000eb1:	48 01 d0             	add    %rdx,%rax
 4000eb4:	48 c1 e0 04          	shl    $0x4,%rax
 4000eb8:	48 01 c8             	add    %rcx,%rax
 4000ebb:	0f b7 40 06          	movzwl 0x6(%rax),%eax
            &&EfiMemMap[slow_index-1].ReservedUnion.TmpChainList.Flags==DIRTY_ENTRY;
 4000ebf:	66 85 c0             	test   %ax,%ax
 4000ec2:	75 33                	jne    4000ef7 <GlobalMemoryPGlevelMgr_t::dirtyentrydelete(unsigned long)+0x107>
 4000ec4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4000ec8:	48 8b 48 08          	mov    0x8(%rax),%rcx
 4000ecc:	8b 45 f8             	mov    -0x8(%rbp),%eax
 4000ecf:	48 63 d0             	movslq %eax,%rdx
 4000ed2:	48 89 d0             	mov    %rdx,%rax
 4000ed5:	48 01 c0             	add    %rax,%rax
 4000ed8:	48 01 d0             	add    %rdx,%rax
 4000edb:	48 c1 e0 04          	shl    $0x4,%rax
 4000edf:	48 83 e8 30          	sub    $0x30,%rax
 4000ee3:	48 01 c8             	add    %rcx,%rax
 4000ee6:	0f b7 40 06          	movzwl 0x6(%rax),%eax
 4000eea:	66 83 f8 01          	cmp    $0x1,%ax
 4000eee:	75 07                	jne    4000ef7 <GlobalMemoryPGlevelMgr_t::dirtyentrydelete(unsigned long)+0x107>
 4000ef0:	b8 01 00 00 00       	mov    $0x1,%eax
 4000ef5:	eb 05                	jmp    4000efc <GlobalMemoryPGlevelMgr_t::dirtyentrydelete(unsigned long)+0x10c>
 4000ef7:	b8 00 00 00 00       	mov    $0x0,%eax
            bool slowindex_stop=EfiMemMap[slow_index].ReservedUnion.TmpChainList.Flags==CLEAN_ENTRY\
 4000efc:	88 45 f4             	mov    %al,-0xc(%rbp)
            if (fastindex_stop&&slowindex_stop)
 4000eff:	80 7d f5 00          	cmpb   $0x0,-0xb(%rbp)
 4000f03:	74 3a                	je     4000f3f <GlobalMemoryPGlevelMgr_t::dirtyentrydelete(unsigned long)+0x14f>
 4000f05:	80 7d f4 00          	cmpb   $0x0,-0xc(%rbp)
 4000f09:	74 34                	je     4000f3f <GlobalMemoryPGlevelMgr_t::dirtyentrydelete(unsigned long)+0x14f>
                linearTBSerialDelete(&EfiMemMapEntryCount,fast_index,slow_index-1,(void*)EfiMemMap,sizeof(EFI_MEMORY_DESCRIPTORX64));
 4000f0b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4000f0f:	48 8b 48 08          	mov    0x8(%rax),%rcx
 4000f13:	8b 45 f8             	mov    -0x8(%rbp),%eax
 4000f16:	83 e8 01             	sub    $0x1,%eax
 4000f19:	48 63 d0             	movslq %eax,%rdx
 4000f1c:	8b 45 fc             	mov    -0x4(%rbp),%eax
 4000f1f:	48 98                	cltq
 4000f21:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
 4000f25:	48 8d 7e 10          	lea    0x10(%rsi),%rdi
 4000f29:	41 b8 30 00 00 00    	mov    $0x30,%r8d
 4000f2f:	48 89 c6             	mov    %rax,%rsi
 4000f32:	e8 6a 75 00 00       	call   40084a1 <linearTBSerialDelete(unsigned long*, unsigned long, unsigned long, void*, unsigned int)>
                slow_index=fast_index;
 4000f37:	8b 45 fc             	mov    -0x4(%rbp),%eax
 4000f3a:	89 45 f8             	mov    %eax,-0x8(%rbp)
 4000f3d:	eb 2c                	jmp    4000f6b <GlobalMemoryPGlevelMgr_t::dirtyentrydelete(unsigned long)+0x17b>
                if (fastindex_stop==false&&fast_index>0)fast_index--;
 4000f3f:	0f b6 45 f5          	movzbl -0xb(%rbp),%eax
 4000f43:	85 c0                	test   %eax,%eax
 4000f45:	75 0a                	jne    4000f51 <GlobalMemoryPGlevelMgr_t::dirtyentrydelete(unsigned long)+0x161>
 4000f47:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
 4000f4b:	7e 04                	jle    4000f51 <GlobalMemoryPGlevelMgr_t::dirtyentrydelete(unsigned long)+0x161>
 4000f4d:	83 6d fc 01          	subl   $0x1,-0x4(%rbp)
                if(slowindex_stop==false&&slow_index>0)slow_index--;
 4000f51:	0f b6 45 f4          	movzbl -0xc(%rbp),%eax
 4000f55:	85 c0                	test   %eax,%eax
 4000f57:	0f 85 ce fe ff ff    	jne    4000e2b <GlobalMemoryPGlevelMgr_t::dirtyentrydelete(unsigned long)+0x3b>
 4000f5d:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
 4000f61:	0f 8e c4 fe ff ff    	jle    4000e2b <GlobalMemoryPGlevelMgr_t::dirtyentrydelete(unsigned long)+0x3b>
 4000f67:	83 6d f8 01          	subl   $0x1,-0x8(%rbp)
            }
 4000f6b:	e9 bb fe ff ff       	jmp    4000e2b <GlobalMemoryPGlevelMgr_t::dirtyentrydelete(unsigned long)+0x3b>
            if(fast_index==0&&slow_index==0)break;
 4000f70:	90                   	nop
            break;
 4000f71:	e9 56 01 00 00       	jmp    40010cc <GlobalMemoryPGlevelMgr_t::dirtyentrydelete(unsigned long)+0x2dc>
        fast_index=slow_index=rootPhymemTbentryCount-1;    
 4000f76:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4000f7a:	48 8b 40 18          	mov    0x18(%rax),%rax
 4000f7e:	83 e8 01             	sub    $0x1,%eax
 4000f81:	89 45 f8             	mov    %eax,-0x8(%rbp)
 4000f84:	8b 45 f8             	mov    -0x8(%rbp),%eax
 4000f87:	89 45 fc             	mov    %eax,-0x4(%rbp)
            if(fast_index==0&&slow_index==0)break;
 4000f8a:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
 4000f8e:	75 0a                	jne    4000f9a <GlobalMemoryPGlevelMgr_t::dirtyentrydelete(unsigned long)+0x1aa>
 4000f90:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
 4000f94:	0f 84 30 01 00 00    	je     40010ca <GlobalMemoryPGlevelMgr_t::dirtyentrydelete(unsigned long)+0x2da>
            bool fastindex_stop=rootPhyMemDscptTbBsPtr[fast_index].ReservedUnion.TmpChainList.Flags==DIRTY_ENTRY\
 4000f9a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4000f9e:	48 8b 08             	mov    (%rax),%rcx
 4000fa1:	8b 45 fc             	mov    -0x4(%rbp),%eax
 4000fa4:	48 63 d0             	movslq %eax,%rdx
 4000fa7:	48 89 d0             	mov    %rdx,%rax
 4000faa:	48 01 c0             	add    %rax,%rax
 4000fad:	48 01 d0             	add    %rdx,%rax
 4000fb0:	48 c1 e0 04          	shl    $0x4,%rax
 4000fb4:	48 01 c8             	add    %rcx,%rax
 4000fb7:	0f b7 40 06          	movzwl 0x6(%rax),%eax
            &&rootPhyMemDscptTbBsPtr[fast_index-1].ReservedUnion.TmpChainList.Flags==CLEAN_ENTRY;
 4000fbb:	66 83 f8 01          	cmp    $0x1,%ax
 4000fbf:	75 31                	jne    4000ff2 <GlobalMemoryPGlevelMgr_t::dirtyentrydelete(unsigned long)+0x202>
 4000fc1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4000fc5:	48 8b 08             	mov    (%rax),%rcx
 4000fc8:	8b 45 fc             	mov    -0x4(%rbp),%eax
 4000fcb:	48 63 d0             	movslq %eax,%rdx
 4000fce:	48 89 d0             	mov    %rdx,%rax
 4000fd1:	48 01 c0             	add    %rax,%rax
 4000fd4:	48 01 d0             	add    %rdx,%rax
 4000fd7:	48 c1 e0 04          	shl    $0x4,%rax
 4000fdb:	48 83 e8 30          	sub    $0x30,%rax
 4000fdf:	48 01 c8             	add    %rcx,%rax
 4000fe2:	0f b7 40 06          	movzwl 0x6(%rax),%eax
 4000fe6:	66 85 c0             	test   %ax,%ax
 4000fe9:	75 07                	jne    4000ff2 <GlobalMemoryPGlevelMgr_t::dirtyentrydelete(unsigned long)+0x202>
 4000feb:	b8 01 00 00 00       	mov    $0x1,%eax
 4000ff0:	eb 05                	jmp    4000ff7 <GlobalMemoryPGlevelMgr_t::dirtyentrydelete(unsigned long)+0x207>
 4000ff2:	b8 00 00 00 00       	mov    $0x0,%eax
            bool fastindex_stop=rootPhyMemDscptTbBsPtr[fast_index].ReservedUnion.TmpChainList.Flags==DIRTY_ENTRY\
 4000ff7:	88 45 f7             	mov    %al,-0x9(%rbp)
            bool slowindex_stop=rootPhyMemDscptTbBsPtr[slow_index].ReservedUnion.TmpChainList.Flags==CLEAN_ENTRY\
 4000ffa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4000ffe:	48 8b 08             	mov    (%rax),%rcx
 4001001:	8b 45 f8             	mov    -0x8(%rbp),%eax
 4001004:	48 63 d0             	movslq %eax,%rdx
 4001007:	48 89 d0             	mov    %rdx,%rax
 400100a:	48 01 c0             	add    %rax,%rax
 400100d:	48 01 d0             	add    %rdx,%rax
 4001010:	48 c1 e0 04          	shl    $0x4,%rax
 4001014:	48 01 c8             	add    %rcx,%rax
 4001017:	0f b7 40 06          	movzwl 0x6(%rax),%eax
            &&rootPhyMemDscptTbBsPtr[slow_index-1].ReservedUnion.TmpChainList.Flags==DIRTY_ENTRY;
 400101b:	66 85 c0             	test   %ax,%ax
 400101e:	75 32                	jne    4001052 <GlobalMemoryPGlevelMgr_t::dirtyentrydelete(unsigned long)+0x262>
 4001020:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4001024:	48 8b 08             	mov    (%rax),%rcx
 4001027:	8b 45 f8             	mov    -0x8(%rbp),%eax
 400102a:	48 63 d0             	movslq %eax,%rdx
 400102d:	48 89 d0             	mov    %rdx,%rax
 4001030:	48 01 c0             	add    %rax,%rax
 4001033:	48 01 d0             	add    %rdx,%rax
 4001036:	48 c1 e0 04          	shl    $0x4,%rax
 400103a:	48 83 e8 30          	sub    $0x30,%rax
 400103e:	48 01 c8             	add    %rcx,%rax
 4001041:	0f b7 40 06          	movzwl 0x6(%rax),%eax
 4001045:	66 83 f8 01          	cmp    $0x1,%ax
 4001049:	75 07                	jne    4001052 <GlobalMemoryPGlevelMgr_t::dirtyentrydelete(unsigned long)+0x262>
 400104b:	b8 01 00 00 00       	mov    $0x1,%eax
 4001050:	eb 05                	jmp    4001057 <GlobalMemoryPGlevelMgr_t::dirtyentrydelete(unsigned long)+0x267>
 4001052:	b8 00 00 00 00       	mov    $0x0,%eax
            bool slowindex_stop=rootPhyMemDscptTbBsPtr[slow_index].ReservedUnion.TmpChainList.Flags==CLEAN_ENTRY\
 4001057:	88 45 f6             	mov    %al,-0xa(%rbp)
            if (fastindex_stop&&slowindex_stop)
 400105a:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
 400105e:	74 39                	je     4001099 <GlobalMemoryPGlevelMgr_t::dirtyentrydelete(unsigned long)+0x2a9>
 4001060:	80 7d f6 00          	cmpb   $0x0,-0xa(%rbp)
 4001064:	74 33                	je     4001099 <GlobalMemoryPGlevelMgr_t::dirtyentrydelete(unsigned long)+0x2a9>
                linearTBSerialDelete(&rootPhymemTbentryCount,fast_index,slow_index-1,(void*)rootPhyMemDscptTbBsPtr,sizeof(EFI_MEMORY_DESCRIPTORX64));
 4001066:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 400106a:	48 8b 08             	mov    (%rax),%rcx
 400106d:	8b 45 f8             	mov    -0x8(%rbp),%eax
 4001070:	83 e8 01             	sub    $0x1,%eax
 4001073:	48 63 d0             	movslq %eax,%rdx
 4001076:	8b 45 fc             	mov    -0x4(%rbp),%eax
 4001079:	48 98                	cltq
 400107b:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
 400107f:	48 8d 7e 18          	lea    0x18(%rsi),%rdi
 4001083:	41 b8 30 00 00 00    	mov    $0x30,%r8d
 4001089:	48 89 c6             	mov    %rax,%rsi
 400108c:	e8 10 74 00 00       	call   40084a1 <linearTBSerialDelete(unsigned long*, unsigned long, unsigned long, void*, unsigned int)>
                slow_index=fast_index;
 4001091:	8b 45 fc             	mov    -0x4(%rbp),%eax
 4001094:	89 45 f8             	mov    %eax,-0x8(%rbp)
 4001097:	eb 2c                	jmp    40010c5 <GlobalMemoryPGlevelMgr_t::dirtyentrydelete(unsigned long)+0x2d5>
                if (fastindex_stop==false&&fast_index>0)fast_index--;
 4001099:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
 400109d:	85 c0                	test   %eax,%eax
 400109f:	75 0a                	jne    40010ab <GlobalMemoryPGlevelMgr_t::dirtyentrydelete(unsigned long)+0x2bb>
 40010a1:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
 40010a5:	7e 04                	jle    40010ab <GlobalMemoryPGlevelMgr_t::dirtyentrydelete(unsigned long)+0x2bb>
 40010a7:	83 6d fc 01          	subl   $0x1,-0x4(%rbp)
                if(slowindex_stop==false&&slow_index>0)slow_index--;
 40010ab:	0f b6 45 f6          	movzbl -0xa(%rbp),%eax
 40010af:	85 c0                	test   %eax,%eax
 40010b1:	0f 85 d3 fe ff ff    	jne    4000f8a <GlobalMemoryPGlevelMgr_t::dirtyentrydelete(unsigned long)+0x19a>
 40010b7:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
 40010bb:	0f 8e c9 fe ff ff    	jle    4000f8a <GlobalMemoryPGlevelMgr_t::dirtyentrydelete(unsigned long)+0x19a>
 40010c1:	83 6d f8 01          	subl   $0x1,-0x8(%rbp)
            }
 40010c5:	e9 c0 fe ff ff       	jmp    4000f8a <GlobalMemoryPGlevelMgr_t::dirtyentrydelete(unsigned long)+0x19a>
            if(fast_index==0&&slow_index==0)break;
 40010ca:	90                   	nop
        break;
 40010cb:	90                   	nop
    }    

}
 40010cc:	90                   	nop
 40010cd:	c9                   	leave
 40010ce:	c3                   	ret
 40010cf:	90                   	nop

00000000040010d0 <GlobalMemoryPGlevelMgr_t::reclaimBootTimeMemoryonEfiTb()>:
     * 还要手动分配一个页来复制新的物理内存描述符表，在这之后才能用物理页分配器
     * 并在新建的物理内存描述表上把0x4000000连续的内存块的描述改为OS_KERNEL_CODE
     * OS_KERNEL_DATA，上面的改动必须完全同步到物理内存描述符表与efi表
     */
void GlobalMemoryPGlevelMgr_t::reclaimBootTimeMemoryonEfiTb()
{   
 40010d0:	55                   	push   %rbp
 40010d1:	48 89 e5             	mov    %rsp,%rbp
 40010d4:	48 83 ec 20          	sub    $0x20,%rsp
 40010d8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    fillMemoryHolesInEfiMap();
 40010dc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 40010e0:	48 89 c7             	mov    %rax,%rdi
 40010e3:	e8 a0 06 00 00       	call   4001788 <GlobalMemoryPGlevelMgr_t::fillMemoryHolesInEfiMap()>
    for(uint64_t i = 0; i < EfiMemMapEntryCount; i++)
 40010e8:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
 40010ef:	00 
 40010f0:	eb 6d                	jmp    400115f <GlobalMemoryPGlevelMgr_t::reclaimBootTimeMemoryonEfiTb()+0x8f>
    //此循环遍历EFI物理内存描述符表统计启动时服务项数
    {
         if(EfiMemMap[i].Type == EfiBootServicesData||
 40010f2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 40010f6:	48 8b 48 08          	mov    0x8(%rax),%rcx
 40010fa:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
 40010fe:	48 89 d0             	mov    %rdx,%rax
 4001101:	48 01 c0             	add    %rax,%rax
 4001104:	48 01 d0             	add    %rdx,%rax
 4001107:	48 c1 e0 04          	shl    $0x4,%rax
 400110b:	48 01 c8             	add    %rcx,%rax
 400110e:	8b 00                	mov    (%rax),%eax
 4001110:	83 f8 04             	cmp    $0x4,%eax
 4001113:	74 23                	je     4001138 <GlobalMemoryPGlevelMgr_t::reclaimBootTimeMemoryonEfiTb()+0x68>
        EfiMemMap[i].Type == EfiBootServicesCode)
 4001115:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4001119:	48 8b 48 08          	mov    0x8(%rax),%rcx
 400111d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
 4001121:	48 89 d0             	mov    %rdx,%rax
 4001124:	48 01 c0             	add    %rax,%rax
 4001127:	48 01 d0             	add    %rdx,%rax
 400112a:	48 c1 e0 04          	shl    $0x4,%rax
 400112e:	48 01 c8             	add    %rcx,%rax
 4001131:	8b 00                	mov    (%rax),%eax
         if(EfiMemMap[i].Type == EfiBootServicesData||
 4001133:	83 f8 03             	cmp    $0x3,%eax
 4001136:	75 22                	jne    400115a <GlobalMemoryPGlevelMgr_t::reclaimBootTimeMemoryonEfiTb()+0x8a>
        {
            EfiMemMap[i].Type = freeSystemRam;
 4001138:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 400113c:	48 8b 48 08          	mov    0x8(%rax),%rcx
 4001140:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
 4001144:	48 89 d0             	mov    %rdx,%rax
 4001147:	48 01 c0             	add    %rax,%rax
 400114a:	48 01 d0             	add    %rdx,%rax
 400114d:	48 c1 e0 04          	shl    $0x4,%rax
 4001151:	48 01 c8             	add    %rcx,%rax
 4001154:	c7 00 07 00 00 00    	movl   $0x7,(%rax)
    for(uint64_t i = 0; i < EfiMemMapEntryCount; i++)
 400115a:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
 400115f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4001163:	48 8b 40 10          	mov    0x10(%rax),%rax
 4001167:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
 400116b:	72 85                	jb     40010f2 <GlobalMemoryPGlevelMgr_t::reclaimBootTimeMemoryonEfiTb()+0x22>

        }
    }
    for(uint64_t i = 0; i < EfiMemMapEntryCount-1; i++)//表的最后一项通常不会是启动时服务项所以减1
 400116d:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
 4001174:	00 
 4001175:	e9 54 01 00 00       	jmp    40012ce <GlobalMemoryPGlevelMgr_t::reclaimBootTimeMemoryonEfiTb()+0x1fe>
    //此循环遍历EFI物理内存描述符表
    {   
        if(EfiMemMap[i].Type == freeSystemRam)
 400117a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 400117e:	48 8b 48 08          	mov    0x8(%rax),%rcx
 4001182:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
 4001186:	48 89 d0             	mov    %rdx,%rax
 4001189:	48 01 c0             	add    %rax,%rax
 400118c:	48 01 d0             	add    %rdx,%rax
 400118f:	48 c1 e0 04          	shl    $0x4,%rax
 4001193:	48 01 c8             	add    %rcx,%rax
 4001196:	8b 00                	mov    (%rax),%eax
 4001198:	83 f8 07             	cmp    $0x7,%eax
 400119b:	0f 85 28 01 00 00    	jne    40012c9 <GlobalMemoryPGlevelMgr_t::reclaimBootTimeMemoryonEfiTb()+0x1f9>
        {
            if(EfiMemMap[i+1].Type == freeSystemRam)
 40011a1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 40011a5:	48 8b 48 08          	mov    0x8(%rax),%rcx
 40011a9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 40011ad:	48 8d 50 01          	lea    0x1(%rax),%rdx
 40011b1:	48 89 d0             	mov    %rdx,%rax
 40011b4:	48 01 c0             	add    %rax,%rax
 40011b7:	48 01 d0             	add    %rdx,%rax
 40011ba:	48 c1 e0 04          	shl    $0x4,%rax
 40011be:	48 01 c8             	add    %rcx,%rax
 40011c1:	8b 00                	mov    (%rax),%eax
 40011c3:	83 f8 07             	cmp    $0x7,%eax
 40011c6:	0f 85 fd 00 00 00    	jne    40012c9 <GlobalMemoryPGlevelMgr_t::reclaimBootTimeMemoryonEfiTb()+0x1f9>
            {//后继也是启动时服务项
                if (Ismemspaceneighbors(i,i+1,0))
 40011cc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 40011d0:	83 c0 01             	add    $0x1,%eax
 40011d3:	0f b7 d0             	movzwl %ax,%edx
 40011d6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 40011da:	0f b7 f0             	movzwl %ax,%esi
 40011dd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 40011e1:	b9 00 00 00 00       	mov    $0x0,%ecx
 40011e6:	48 89 c7             	mov    %rax,%rdi
 40011e9:	e8 36 19 00 00       	call   4002b24 <GlobalMemoryPGlevelMgr_t::Ismemspaceneighbors(unsigned short, unsigned short, unsigned long)>
 40011ee:	84 c0                	test   %al,%al
 40011f0:	0f 84 d3 00 00 00    	je     40012c9 <GlobalMemoryPGlevelMgr_t::reclaimBootTimeMemoryonEfiTb()+0x1f9>
                {
                    EfiMemMap[i].ReservedUnion.TmpChainList.Flags=DIRTY_ENTRY;
 40011f6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 40011fa:	48 8b 48 08          	mov    0x8(%rax),%rcx
 40011fe:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
 4001202:	48 89 d0             	mov    %rdx,%rax
 4001205:	48 01 c0             	add    %rax,%rax
 4001208:	48 01 d0             	add    %rdx,%rax
 400120b:	48 c1 e0 04          	shl    $0x4,%rax
 400120f:	48 01 c8             	add    %rcx,%rax
 4001212:	66 c7 40 06 01 00    	movw   $0x1,0x6(%rax)
                    EfiMemMap[i+1].PhysicalStart=EfiMemMap[i].PhysicalStart;
 4001218:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 400121c:	48 8b 48 08          	mov    0x8(%rax),%rcx
 4001220:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
 4001224:	48 89 d0             	mov    %rdx,%rax
 4001227:	48 01 c0             	add    %rax,%rax
 400122a:	48 01 d0             	add    %rdx,%rax
 400122d:	48 c1 e0 04          	shl    $0x4,%rax
 4001231:	48 01 c1             	add    %rax,%rcx
 4001234:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4001238:	48 8b 70 08          	mov    0x8(%rax),%rsi
 400123c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 4001240:	48 8d 50 01          	lea    0x1(%rax),%rdx
 4001244:	48 89 d0             	mov    %rdx,%rax
 4001247:	48 01 c0             	add    %rax,%rax
 400124a:	48 01 d0             	add    %rdx,%rax
 400124d:	48 c1 e0 04          	shl    $0x4,%rax
 4001251:	48 8d 14 06          	lea    (%rsi,%rax,1),%rdx
 4001255:	48 8b 41 08          	mov    0x8(%rcx),%rax
 4001259:	48 89 42 08          	mov    %rax,0x8(%rdx)
                    EfiMemMap[i+1].NumberOfPages+=EfiMemMap[i].NumberOfPages;
 400125d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4001261:	48 8b 48 08          	mov    0x8(%rax),%rcx
 4001265:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 4001269:	48 8d 50 01          	lea    0x1(%rax),%rdx
 400126d:	48 89 d0             	mov    %rdx,%rax
 4001270:	48 01 c0             	add    %rax,%rax
 4001273:	48 01 d0             	add    %rdx,%rax
 4001276:	48 c1 e0 04          	shl    $0x4,%rax
 400127a:	48 01 c8             	add    %rcx,%rax
 400127d:	48 8b 70 18          	mov    0x18(%rax),%rsi
 4001281:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4001285:	48 8b 48 08          	mov    0x8(%rax),%rcx
 4001289:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
 400128d:	48 89 d0             	mov    %rdx,%rax
 4001290:	48 01 c0             	add    %rax,%rax
 4001293:	48 01 d0             	add    %rdx,%rax
 4001296:	48 c1 e0 04          	shl    $0x4,%rax
 400129a:	48 01 c8             	add    %rcx,%rax
 400129d:	48 8b 48 18          	mov    0x18(%rax),%rcx
 40012a1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 40012a5:	48 8b 78 08          	mov    0x8(%rax),%rdi
 40012a9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 40012ad:	48 8d 50 01          	lea    0x1(%rax),%rdx
 40012b1:	48 89 d0             	mov    %rdx,%rax
 40012b4:	48 01 c0             	add    %rax,%rax
 40012b7:	48 01 d0             	add    %rdx,%rax
 40012ba:	48 c1 e0 04          	shl    $0x4,%rax
 40012be:	48 01 f8             	add    %rdi,%rax
 40012c1:	48 8d 14 0e          	lea    (%rsi,%rcx,1),%rdx
 40012c5:	48 89 50 18          	mov    %rdx,0x18(%rax)
    for(uint64_t i = 0; i < EfiMemMapEntryCount-1; i++)//表的最后一项通常不会是启动时服务项所以减1
 40012c9:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
 40012ce:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 40012d2:	48 8b 40 10          	mov    0x10(%rax),%rax
 40012d6:	48 83 e8 01          	sub    $0x1,%rax
 40012da:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
 40012de:	0f 82 96 fe ff ff    	jb     400117a <GlobalMemoryPGlevelMgr_t::reclaimBootTimeMemoryonEfiTb()+0xaa>
                }
                
            } 
        }
    }
    dirtyentrydelete(0);
 40012e4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 40012e8:	be 00 00 00 00       	mov    $0x0,%esi
 40012ed:	48 89 c7             	mov    %rax,%rdi
 40012f0:	e8 fb fa ff ff       	call   4000df0 <GlobalMemoryPGlevelMgr_t::dirtyentrydelete(unsigned long)>

}
 40012f5:	90                   	nop
 40012f6:	c9                   	leave
 40012f7:	c3                   	ret

00000000040012f8 <GlobalMemoryPGlevelMgr_t::InitrootPhyMemDscptTbBsPtr()>:
 * @param entryCount 
*初始化物理内存描述符表是通过复制已经回收了启动时服务内存的efi表，根据约定标记内核数据，内核代码后再
*在物理内存描述符表中回收loader使用的内存
 */
void GlobalMemoryPGlevelMgr_t::InitrootPhyMemDscptTbBsPtr()
{
 40012f8:	55                   	push   %rbp
 40012f9:	48 89 e5             	mov    %rsp,%rbp
 40012fc:	48 83 ec 30          	sub    $0x30,%rsp
 4001300:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
        int pgcounts_for_phyramtb=(EfiMemMapEntryCount*sizeof(EFI_MEMORY_DESCRIPTORX64)+
 4001304:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4001308:	48 8b 50 10          	mov    0x10(%rax),%rdx
 400130c:	48 89 d0             	mov    %rdx,%rax
 400130f:	48 01 c0             	add    %rax,%rax
 4001312:	48 01 d0             	add    %rdx,%rax
 4001315:	48 c1 e0 04          	shl    $0x4,%rax
    PAGE_SIZE_4KB-1)/PAGE_SIZE_4KB+15;
 4001319:	48 05 ff 0f 00 00    	add    $0xfff,%rax
 400131f:	48 c1 e8 0c          	shr    $0xc,%rax
 4001323:	83 c0 0f             	add    $0xf,%eax
        int pgcounts_for_phyramtb=(EfiMemMapEntryCount*sizeof(EFI_MEMORY_DESCRIPTORX64)+
 4001326:	89 45 e4             	mov    %eax,-0x1c(%rbp)
    int kernelcodeDesIndex;
    for (int i=0; i < EfiMemMapEntryCount; i++)
 4001329:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
 4001330:	eb 5b                	jmp    400138d <GlobalMemoryPGlevelMgr_t::InitrootPhyMemDscptTbBsPtr()+0x95>
    {
        if ((EfiMemMap[i].Type==EfiLoaderCode)&&EfiMemMap[i].PhysicalStart==KEFLBASE)
 4001332:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4001336:	48 8b 48 08          	mov    0x8(%rax),%rcx
 400133a:	8b 45 f8             	mov    -0x8(%rbp),%eax
 400133d:	48 63 d0             	movslq %eax,%rdx
 4001340:	48 89 d0             	mov    %rdx,%rax
 4001343:	48 01 c0             	add    %rax,%rax
 4001346:	48 01 d0             	add    %rdx,%rax
 4001349:	48 c1 e0 04          	shl    $0x4,%rax
 400134d:	48 01 c8             	add    %rcx,%rax
 4001350:	8b 00                	mov    (%rax),%eax
 4001352:	83 f8 01             	cmp    $0x1,%eax
 4001355:	75 32                	jne    4001389 <GlobalMemoryPGlevelMgr_t::InitrootPhyMemDscptTbBsPtr()+0x91>
 4001357:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 400135b:	48 8b 48 08          	mov    0x8(%rax),%rcx
 400135f:	8b 45 f8             	mov    -0x8(%rbp),%eax
 4001362:	48 63 d0             	movslq %eax,%rdx
 4001365:	48 89 d0             	mov    %rdx,%rax
 4001368:	48 01 c0             	add    %rax,%rax
 400136b:	48 01 d0             	add    %rdx,%rax
 400136e:	48 c1 e0 04          	shl    $0x4,%rax
 4001372:	48 01 c8             	add    %rcx,%rax
 4001375:	48 8b 40 08          	mov    0x8(%rax),%rax
 4001379:	48 3d 00 00 00 04    	cmp    $0x4000000,%rax
 400137f:	75 08                	jne    4001389 <GlobalMemoryPGlevelMgr_t::InitrootPhyMemDscptTbBsPtr()+0x91>
        {
            kernelcodeDesIndex=i;
 4001381:	8b 45 f8             	mov    -0x8(%rbp),%eax
 4001384:	89 45 fc             	mov    %eax,-0x4(%rbp)
            break;
 4001387:	eb 17                	jmp    40013a0 <GlobalMemoryPGlevelMgr_t::InitrootPhyMemDscptTbBsPtr()+0xa8>
    for (int i=0; i < EfiMemMapEntryCount; i++)
 4001389:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
 400138d:	8b 45 f8             	mov    -0x8(%rbp),%eax
 4001390:	48 63 d0             	movslq %eax,%rdx
 4001393:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4001397:	48 8b 40 10          	mov    0x10(%rax),%rax
 400139b:	48 39 c2             	cmp    %rax,%rdx
 400139e:	72 92                	jb     4001332 <GlobalMemoryPGlevelMgr_t::InitrootPhyMemDscptTbBsPtr()+0x3a>
        }
    }
    int kerneldataDesIndex;
        for (int i=kernelcodeDesIndex; i < EfiMemMapEntryCount; i++)
 40013a0:	8b 45 fc             	mov    -0x4(%rbp),%eax
 40013a3:	89 45 f0             	mov    %eax,-0x10(%rbp)
 40013a6:	eb 59                	jmp    4001401 <GlobalMemoryPGlevelMgr_t::InitrootPhyMemDscptTbBsPtr()+0x109>
    {
        if ((EfiMemMap[i].Type==EfiLoaderData)&&EfiMemMap[i+1].Type==EfiConventionalMemory)
 40013a8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 40013ac:	48 8b 48 08          	mov    0x8(%rax),%rcx
 40013b0:	8b 45 f0             	mov    -0x10(%rbp),%eax
 40013b3:	48 63 d0             	movslq %eax,%rdx
 40013b6:	48 89 d0             	mov    %rdx,%rax
 40013b9:	48 01 c0             	add    %rax,%rax
 40013bc:	48 01 d0             	add    %rdx,%rax
 40013bf:	48 c1 e0 04          	shl    $0x4,%rax
 40013c3:	48 01 c8             	add    %rcx,%rax
 40013c6:	8b 00                	mov    (%rax),%eax
 40013c8:	83 f8 02             	cmp    $0x2,%eax
 40013cb:	75 30                	jne    40013fd <GlobalMemoryPGlevelMgr_t::InitrootPhyMemDscptTbBsPtr()+0x105>
 40013cd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 40013d1:	48 8b 48 08          	mov    0x8(%rax),%rcx
 40013d5:	8b 45 f0             	mov    -0x10(%rbp),%eax
 40013d8:	48 98                	cltq
 40013da:	48 8d 50 01          	lea    0x1(%rax),%rdx
 40013de:	48 89 d0             	mov    %rdx,%rax
 40013e1:	48 01 c0             	add    %rax,%rax
 40013e4:	48 01 d0             	add    %rdx,%rax
 40013e7:	48 c1 e0 04          	shl    $0x4,%rax
 40013eb:	48 01 c8             	add    %rcx,%rax
 40013ee:	8b 00                	mov    (%rax),%eax
 40013f0:	83 f8 07             	cmp    $0x7,%eax
 40013f3:	75 08                	jne    40013fd <GlobalMemoryPGlevelMgr_t::InitrootPhyMemDscptTbBsPtr()+0x105>
        {
            kerneldataDesIndex=i;
 40013f5:	8b 45 f0             	mov    -0x10(%rbp),%eax
 40013f8:	89 45 f4             	mov    %eax,-0xc(%rbp)
            break;
 40013fb:	eb 17                	jmp    4001414 <GlobalMemoryPGlevelMgr_t::InitrootPhyMemDscptTbBsPtr()+0x11c>
        for (int i=kernelcodeDesIndex; i < EfiMemMapEntryCount; i++)
 40013fd:	83 45 f0 01          	addl   $0x1,-0x10(%rbp)
 4001401:	8b 45 f0             	mov    -0x10(%rbp),%eax
 4001404:	48 63 d0             	movslq %eax,%rdx
 4001407:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 400140b:	48 8b 40 10          	mov    0x10(%rax),%rax
 400140f:	48 39 c2             	cmp    %rax,%rdx
 4001412:	72 94                	jb     40013a8 <GlobalMemoryPGlevelMgr_t::InitrootPhyMemDscptTbBsPtr()+0xb0>
        }
    }
   rootPhyMemDscptTbBsPtr=new phy_memDesriptor[EfiMemMapEntryCount+30];
 4001414:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4001418:	48 8b 40 10          	mov    0x10(%rax),%rax
 400141c:	48 8d 50 1e          	lea    0x1e(%rax),%rdx
 4001420:	48 b8 aa aa aa aa aa 	movabs $0x2aaaaaaaaaaaaaa,%rax
 4001427:	aa aa 02 
 400142a:	48 39 d0             	cmp    %rdx,%rax
 400142d:	72 0f                	jb     400143e <GlobalMemoryPGlevelMgr_t::InitrootPhyMemDscptTbBsPtr()+0x146>
 400142f:	48 89 d0             	mov    %rdx,%rax
 4001432:	48 01 c0             	add    %rax,%rax
 4001435:	48 01 d0             	add    %rdx,%rax
 4001438:	48 c1 e0 04          	shl    $0x4,%rax
 400143c:	eb 07                	jmp    4001445 <GlobalMemoryPGlevelMgr_t::InitrootPhyMemDscptTbBsPtr()+0x14d>
 400143e:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
 4001445:	48 89 c7             	mov    %rax,%rdi
 4001448:	e8 c7 31 00 00       	call   4004614 <operator new[](unsigned long)>
 400144d:	48 89 c2             	mov    %rax,%rdx
 4001450:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4001454:	48 89 10             	mov    %rdx,(%rax)
    ksystemramcpy(EfiMemMap,
    rootPhyMemDscptTbBsPtr,
    EfiMemMapEntryCount*sizeof(EfiMemMap[0]));
 4001457:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 400145b:	48 8b 50 10          	mov    0x10(%rax),%rdx
    ksystemramcpy(EfiMemMap,
 400145f:	48 89 d0             	mov    %rdx,%rax
 4001462:	48 01 c0             	add    %rax,%rax
 4001465:	48 01 d0             	add    %rdx,%rax
 4001468:	48 c1 e0 04          	shl    $0x4,%rax
 400146c:	48 89 c2             	mov    %rax,%rdx
    rootPhyMemDscptTbBsPtr,
 400146f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4001473:	48 8b 08             	mov    (%rax),%rcx
    ksystemramcpy(EfiMemMap,
 4001476:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 400147a:	48 8b 40 08          	mov    0x8(%rax),%rax
 400147e:	48 89 ce             	mov    %rcx,%rsi
 4001481:	48 89 c7             	mov    %rax,%rdi
 4001484:	e8 9d 6e 00 00       	call   4008326 <ksystemramcpy(void*, void*, unsigned long)>
    rootPhymemTbentryCount=EfiMemMapEntryCount;
 4001489:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 400148d:	48 8b 50 10          	mov    0x10(%rax),%rdx
 4001491:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4001495:	48 89 50 18          	mov    %rdx,0x18(%rax)
    rootPhyMemDscptTbBsPtr[kernelcodeDesIndex].Type=OS_KERNEL_CODE;
 4001499:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 400149d:	48 8b 08             	mov    (%rax),%rcx
 40014a0:	8b 45 fc             	mov    -0x4(%rbp),%eax
 40014a3:	48 63 d0             	movslq %eax,%rdx
 40014a6:	48 89 d0             	mov    %rdx,%rax
 40014a9:	48 01 c0             	add    %rax,%rax
 40014ac:	48 01 d0             	add    %rdx,%rax
 40014af:	48 c1 e0 04          	shl    $0x4,%rax
 40014b3:	48 01 c8             	add    %rcx,%rax
 40014b6:	c7 00 12 00 00 00    	movl   $0x12,(%rax)
    rootPhyMemDscptTbBsPtr[kerneldataDesIndex].Type=OS_KERNEL_DATA;
 40014bc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 40014c0:	48 8b 08             	mov    (%rax),%rcx
 40014c3:	8b 45 f4             	mov    -0xc(%rbp),%eax
 40014c6:	48 63 d0             	movslq %eax,%rdx
 40014c9:	48 89 d0             	mov    %rdx,%rax
 40014cc:	48 01 c0             	add    %rax,%rax
 40014cf:	48 01 d0             	add    %rdx,%rax
 40014d2:	48 c1 e0 04          	shl    $0x4,%rax
 40014d6:	48 01 c8             	add    %rcx,%rax
 40014d9:	c7 00 11 00 00 00    	movl   $0x11,(%rax)
    for (size_t i = 0; i < rootPhymemTbentryCount; i++)
 40014df:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
 40014e6:	00 
 40014e7:	eb 6f                	jmp    4001558 <GlobalMemoryPGlevelMgr_t::InitrootPhyMemDscptTbBsPtr()+0x260>
    {
        if (rootPhyMemDscptTbBsPtr[i].Type==EfiLoaderData&&
 40014e9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 40014ed:	48 8b 08             	mov    (%rax),%rcx
 40014f0:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
 40014f4:	48 89 d0             	mov    %rdx,%rax
 40014f7:	48 01 c0             	add    %rax,%rax
 40014fa:	48 01 d0             	add    %rdx,%rax
 40014fd:	48 c1 e0 04          	shl    $0x4,%rax
 4001501:	48 01 c8             	add    %rcx,%rax
 4001504:	8b 00                	mov    (%rax),%eax
 4001506:	83 f8 02             	cmp    $0x2,%eax
 4001509:	75 48                	jne    4001553 <GlobalMemoryPGlevelMgr_t::InitrootPhyMemDscptTbBsPtr()+0x25b>
        rootPhyMemDscptTbBsPtr[i].PhysicalStart==0x400000)
 400150b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 400150f:	48 8b 08             	mov    (%rax),%rcx
 4001512:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
 4001516:	48 89 d0             	mov    %rdx,%rax
 4001519:	48 01 c0             	add    %rax,%rax
 400151c:	48 01 d0             	add    %rdx,%rax
 400151f:	48 c1 e0 04          	shl    $0x4,%rax
 4001523:	48 01 c8             	add    %rcx,%rax
 4001526:	48 8b 40 08          	mov    0x8(%rax),%rax
        if (rootPhyMemDscptTbBsPtr[i].Type==EfiLoaderData&&
 400152a:	48 3d 00 00 40 00    	cmp    $0x400000,%rax
 4001530:	75 21                	jne    4001553 <GlobalMemoryPGlevelMgr_t::InitrootPhyMemDscptTbBsPtr()+0x25b>
        {
            rootPhyMemDscptTbBsPtr[i].Type=OS_KERNEL_STACK;
 4001532:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4001536:	48 8b 08             	mov    (%rax),%rcx
 4001539:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
 400153d:	48 89 d0             	mov    %rdx,%rax
 4001540:	48 01 c0             	add    %rax,%rax
 4001543:	48 01 d0             	add    %rdx,%rax
 4001546:	48 c1 e0 04          	shl    $0x4,%rax
 400154a:	48 01 c8             	add    %rcx,%rax
 400154d:	c7 00 13 00 00 00    	movl   $0x13,(%rax)
    for (size_t i = 0; i < rootPhymemTbentryCount; i++)
 4001553:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
 4001558:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 400155c:	48 8b 40 18          	mov    0x18(%rax),%rax
 4001560:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
 4001564:	72 83                	jb     40014e9 <GlobalMemoryPGlevelMgr_t::InitrootPhyMemDscptTbBsPtr()+0x1f1>
        }
        
    }  
    reclaimLoaderMemory(); 
 4001566:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 400156a:	48 89 c7             	mov    %rax,%rdi
 400156d:	e8 4e 03 00 00       	call   40018c0 <GlobalMemoryPGlevelMgr_t::reclaimLoaderMemory()>
}
 4001572:	90                   	nop
 4001573:	c9                   	leave
 4001574:	c3                   	ret

0000000004001575 <compareEfiDescriptors(void const*, void const*)>:
// 对EFI内存表按物理起始地址排序
static int compareEfiDescriptors(const void* a, const void* b) {
 4001575:	55                   	push   %rbp
 4001576:	48 89 e5             	mov    %rsp,%rbp
 4001579:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
 400157d:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
    const EFI_MEMORY_DESCRIPTORX64* descA = (const EFI_MEMORY_DESCRIPTORX64*)a;
 4001581:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4001585:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    const EFI_MEMORY_DESCRIPTORX64* descB = (const EFI_MEMORY_DESCRIPTORX64*)b;
 4001589:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 400158d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    
    if (descA->PhysicalStart < descB->PhysicalStart) return -1;
 4001591:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4001595:	48 8b 50 08          	mov    0x8(%rax),%rdx
 4001599:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 400159d:	48 8b 40 08          	mov    0x8(%rax),%rax
 40015a1:	48 39 c2             	cmp    %rax,%rdx
 40015a4:	73 07                	jae    40015ad <compareEfiDescriptors(void const*, void const*)+0x38>
 40015a6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 40015ab:	eb 21                	jmp    40015ce <compareEfiDescriptors(void const*, void const*)+0x59>
    if (descA->PhysicalStart > descB->PhysicalStart) return 1;
 40015ad:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 40015b1:	48 8b 40 08          	mov    0x8(%rax),%rax
 40015b5:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
 40015b9:	48 8b 52 08          	mov    0x8(%rdx),%rdx
 40015bd:	48 39 c2             	cmp    %rax,%rdx
 40015c0:	73 07                	jae    40015c9 <compareEfiDescriptors(void const*, void const*)+0x54>
 40015c2:	b8 01 00 00 00       	mov    $0x1,%eax
 40015c7:	eb 05                	jmp    40015ce <compareEfiDescriptors(void const*, void const*)+0x59>
    return 0;
 40015c9:	b8 00 00 00 00       	mov    $0x0,%eax
}
 40015ce:	5d                   	pop    %rbp
 40015cf:	c3                   	ret

00000000040015d0 <GlobalMemoryPGlevelMgr_t::sortEfiMemoryMapByPhysicalStart()>:
void GlobalMemoryPGlevelMgr_t::sortEfiMemoryMapByPhysicalStart() {
 40015d0:	55                   	push   %rbp
 40015d1:	48 89 e5             	mov    %rsp,%rbp
 40015d4:	53                   	push   %rbx
 40015d5:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
    // 使用简单的冒泡排序，因为EFI内存表通常不会太大
    for (uint64_t i = 0; i < EfiMemMapEntryCount - 1; i++) {
 40015d9:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
 40015e0:	00 
 40015e1:	e9 83 01 00 00       	jmp    4001769 <GlobalMemoryPGlevelMgr_t::sortEfiMemoryMapByPhysicalStart()+0x199>
        for (uint64_t j = 0; j < EfiMemMapEntryCount - i - 1; j++) {
 40015e6:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
 40015ed:	00 
 40015ee:	e9 57 01 00 00       	jmp    400174a <GlobalMemoryPGlevelMgr_t::sortEfiMemoryMapByPhysicalStart()+0x17a>
            if (EfiMemMap[j].PhysicalStart > EfiMemMap[j + 1].PhysicalStart) {
 40015f3:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
 40015f7:	48 8b 48 08          	mov    0x8(%rax),%rcx
 40015fb:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
 40015ff:	48 89 d0             	mov    %rdx,%rax
 4001602:	48 01 c0             	add    %rax,%rax
 4001605:	48 01 d0             	add    %rdx,%rax
 4001608:	48 c1 e0 04          	shl    $0x4,%rax
 400160c:	48 01 c8             	add    %rcx,%rax
 400160f:	48 8b 48 08          	mov    0x8(%rax),%rcx
 4001613:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
 4001617:	48 8b 70 08          	mov    0x8(%rax),%rsi
 400161b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 400161f:	48 8d 50 01          	lea    0x1(%rax),%rdx
 4001623:	48 89 d0             	mov    %rdx,%rax
 4001626:	48 01 c0             	add    %rax,%rax
 4001629:	48 01 d0             	add    %rdx,%rax
 400162c:	48 c1 e0 04          	shl    $0x4,%rax
 4001630:	48 01 f0             	add    %rsi,%rax
 4001633:	48 8b 40 08          	mov    0x8(%rax),%rax
 4001637:	48 39 c8             	cmp    %rcx,%rax
 400163a:	0f 83 05 01 00 00    	jae    4001745 <GlobalMemoryPGlevelMgr_t::sortEfiMemoryMapByPhysicalStart()+0x175>
                // 交换两个描述符
                EFI_MEMORY_DESCRIPTORX64 temp = EfiMemMap[j];
 4001640:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
 4001644:	48 8b 48 08          	mov    0x8(%rax),%rcx
 4001648:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
 400164c:	48 89 d0             	mov    %rdx,%rax
 400164f:	48 01 c0             	add    %rax,%rax
 4001652:	48 01 d0             	add    %rdx,%rax
 4001655:	48 c1 e0 04          	shl    $0x4,%rax
 4001659:	48 01 c8             	add    %rcx,%rax
 400165c:	48 8b 08             	mov    (%rax),%rcx
 400165f:	48 8b 58 08          	mov    0x8(%rax),%rbx
 4001663:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
 4001667:	48 89 5d b8          	mov    %rbx,-0x48(%rbp)
 400166b:	48 8b 48 10          	mov    0x10(%rax),%rcx
 400166f:	48 8b 58 18          	mov    0x18(%rax),%rbx
 4001673:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
 4001677:	48 89 5d c8          	mov    %rbx,-0x38(%rbp)
 400167b:	48 8b 50 28          	mov    0x28(%rax),%rdx
 400167f:	48 8b 40 20          	mov    0x20(%rax),%rax
 4001683:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
 4001687:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
                EfiMemMap[j] = EfiMemMap[j + 1];
 400168b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
 400168f:	48 8b 48 08          	mov    0x8(%rax),%rcx
 4001693:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4001697:	48 8d 50 01          	lea    0x1(%rax),%rdx
 400169b:	48 89 d0             	mov    %rdx,%rax
 400169e:	48 01 c0             	add    %rax,%rax
 40016a1:	48 01 d0             	add    %rdx,%rax
 40016a4:	48 c1 e0 04          	shl    $0x4,%rax
 40016a8:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
 40016ac:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
 40016b0:	48 8b 70 08          	mov    0x8(%rax),%rsi
 40016b4:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
 40016b8:	48 89 c8             	mov    %rcx,%rax
 40016bb:	48 01 c0             	add    %rax,%rax
 40016be:	48 01 c8             	add    %rcx,%rax
 40016c1:	48 c1 e0 04          	shl    $0x4,%rax
 40016c5:	48 01 f0             	add    %rsi,%rax
 40016c8:	48 8b 0a             	mov    (%rdx),%rcx
 40016cb:	48 8b 5a 08          	mov    0x8(%rdx),%rbx
 40016cf:	48 89 08             	mov    %rcx,(%rax)
 40016d2:	48 89 58 08          	mov    %rbx,0x8(%rax)
 40016d6:	48 8b 4a 10          	mov    0x10(%rdx),%rcx
 40016da:	48 8b 5a 18          	mov    0x18(%rdx),%rbx
 40016de:	48 89 48 10          	mov    %rcx,0x10(%rax)
 40016e2:	48 89 58 18          	mov    %rbx,0x18(%rax)
 40016e6:	48 8b 4a 20          	mov    0x20(%rdx),%rcx
 40016ea:	48 8b 5a 28          	mov    0x28(%rdx),%rbx
 40016ee:	48 89 48 20          	mov    %rcx,0x20(%rax)
 40016f2:	48 89 58 28          	mov    %rbx,0x28(%rax)
                EfiMemMap[j + 1] = temp;
 40016f6:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
 40016fa:	48 8b 48 08          	mov    0x8(%rax),%rcx
 40016fe:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4001702:	48 8d 50 01          	lea    0x1(%rax),%rdx
 4001706:	48 89 d0             	mov    %rdx,%rax
 4001709:	48 01 c0             	add    %rax,%rax
 400170c:	48 01 d0             	add    %rdx,%rax
 400170f:	48 c1 e0 04          	shl    $0x4,%rax
 4001713:	48 01 c8             	add    %rcx,%rax
 4001716:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
 400171a:	48 8b 5d b8          	mov    -0x48(%rbp),%rbx
 400171e:	48 89 08             	mov    %rcx,(%rax)
 4001721:	48 89 58 08          	mov    %rbx,0x8(%rax)
 4001725:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
 4001729:	48 8b 5d c8          	mov    -0x38(%rbp),%rbx
 400172d:	48 89 48 10          	mov    %rcx,0x10(%rax)
 4001731:	48 89 58 18          	mov    %rbx,0x18(%rax)
 4001735:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
 4001739:	48 8b 5d d8          	mov    -0x28(%rbp),%rbx
 400173d:	48 89 48 20          	mov    %rcx,0x20(%rax)
 4001741:	48 89 58 28          	mov    %rbx,0x28(%rax)
        for (uint64_t j = 0; j < EfiMemMapEntryCount - i - 1; j++) {
 4001745:	48 83 45 e0 01       	addq   $0x1,-0x20(%rbp)
 400174a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
 400174e:	48 8b 40 10          	mov    0x10(%rax),%rax
 4001752:	48 2b 45 e8          	sub    -0x18(%rbp),%rax
 4001756:	48 83 e8 01          	sub    $0x1,%rax
 400175a:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
 400175e:	0f 82 8f fe ff ff    	jb     40015f3 <GlobalMemoryPGlevelMgr_t::sortEfiMemoryMapByPhysicalStart()+0x23>
    for (uint64_t i = 0; i < EfiMemMapEntryCount - 1; i++) {
 4001764:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
 4001769:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
 400176d:	48 8b 40 10          	mov    0x10(%rax),%rax
 4001771:	48 83 e8 01          	sub    $0x1,%rax
 4001775:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
 4001779:	0f 82 67 fe ff ff    	jb     40015e6 <GlobalMemoryPGlevelMgr_t::sortEfiMemoryMapByPhysicalStart()+0x16>
            }
        }
    }
}
 400177f:	90                   	nop
 4001780:	90                   	nop
 4001781:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
 4001785:	c9                   	leave
 4001786:	c3                   	ret
 4001787:	90                   	nop

0000000004001788 <GlobalMemoryPGlevelMgr_t::fillMemoryHolesInEfiMap()>:
// 检测并填充内存空洞
void GlobalMemoryPGlevelMgr_t::fillMemoryHolesInEfiMap() {
 4001788:	55                   	push   %rbp
 4001789:	48 89 e5             	mov    %rsp,%rbp
 400178c:	48 83 ec 60          	sub    $0x60,%rsp
 4001790:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
    // 先对内存表排序
    sortEfiMemoryMapByPhysicalStart();
 4001794:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
 4001798:	48 89 c7             	mov    %rax,%rdi
 400179b:	e8 30 fe ff ff       	call   40015d0 <GlobalMemoryPGlevelMgr_t::sortEfiMemoryMapByPhysicalStart()>
    
    // 检测内存空洞并插入Reserved类型的描述符
    for (uint64_t i = 0; i < EfiMemMapEntryCount - 1; i++) {
 40017a0:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
 40017a7:	00 
 40017a8:	e9 f9 00 00 00       	jmp    40018a6 <GlobalMemoryPGlevelMgr_t::fillMemoryHolesInEfiMap()+0x11e>
        uint64_t currentEnd = EfiMemMap[i].PhysicalStart + 
 40017ad:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
 40017b1:	48 8b 48 08          	mov    0x8(%rax),%rcx
 40017b5:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
 40017b9:	48 89 d0             	mov    %rdx,%rax
 40017bc:	48 01 c0             	add    %rax,%rax
 40017bf:	48 01 d0             	add    %rdx,%rax
 40017c2:	48 c1 e0 04          	shl    $0x4,%rax
 40017c6:	48 01 c8             	add    %rcx,%rax
 40017c9:	48 8b 48 08          	mov    0x8(%rax),%rcx
                             (EfiMemMap[i].NumberOfPages * EFI_PAGE_SIZE);
 40017cd:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
 40017d1:	48 8b 70 08          	mov    0x8(%rax),%rsi
 40017d5:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
 40017d9:	48 89 d0             	mov    %rdx,%rax
 40017dc:	48 01 c0             	add    %rax,%rax
 40017df:	48 01 d0             	add    %rdx,%rax
 40017e2:	48 c1 e0 04          	shl    $0x4,%rax
 40017e6:	48 01 f0             	add    %rsi,%rax
 40017e9:	48 8b 40 18          	mov    0x18(%rax),%rax
 40017ed:	48 c1 e0 0c          	shl    $0xc,%rax
        uint64_t currentEnd = EfiMemMap[i].PhysicalStart + 
 40017f1:	48 01 c8             	add    %rcx,%rax
 40017f4:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        uint64_t nextStart = EfiMemMap[i + 1].PhysicalStart;
 40017f8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
 40017fc:	48 8b 48 08          	mov    0x8(%rax),%rcx
 4001800:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4001804:	48 8d 50 01          	lea    0x1(%rax),%rdx
 4001808:	48 89 d0             	mov    %rdx,%rax
 400180b:	48 01 c0             	add    %rax,%rax
 400180e:	48 01 d0             	add    %rdx,%rax
 4001811:	48 c1 e0 04          	shl    $0x4,%rax
 4001815:	48 01 c8             	add    %rcx,%rax
 4001818:	48 8b 40 08          	mov    0x8(%rax),%rax
 400181c:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
        
        // 检查是否存在空洞
        if (currentEnd < nextStart) {
 4001820:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 4001824:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
 4001828:	73 77                	jae    40018a1 <GlobalMemoryPGlevelMgr_t::fillMemoryHolesInEfiMap()+0x119>
            // 计算空洞大小（以页为单位）
            uint64_t holePages = (nextStart - currentEnd) / EFI_PAGE_SIZE;
 400182a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 400182e:	48 2b 45 f0          	sub    -0x10(%rbp),%rax
 4001832:	48 c1 e8 0c          	shr    $0xc,%rax
 4001836:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
            
            // 创建Reserved类型的描述符
            EFI_MEMORY_DESCRIPTORX64 holeDesc = {0};
 400183a:	66 0f ef c0          	pxor   %xmm0,%xmm0
 400183e:	0f 29 45 b0          	movaps %xmm0,-0x50(%rbp)
 4001842:	0f 29 45 c0          	movaps %xmm0,-0x40(%rbp)
 4001846:	0f 29 45 d0          	movaps %xmm0,-0x30(%rbp)
            holeDesc.Type = EFI_RESERVED_MEMORY_TYPE;
 400184a:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)
            holeDesc.PhysicalStart = currentEnd;
 4001851:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 4001855:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
            holeDesc.NumberOfPages = holePages;
 4001859:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 400185d:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
            holeDesc.Attribute = 0;
 4001861:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
 4001868:	00 
            // 插入到表中
            linearTBSerialInsert(
                &EfiMemMapEntryCount,
                i + 1,
                &holeDesc,
                EfiMemMap,
 4001869:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
 400186d:	48 8b 50 08          	mov    0x8(%rax),%rdx
            linearTBSerialInsert(
 4001871:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4001875:	48 8d 70 01          	lea    0x1(%rax),%rsi
 4001879:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
 400187d:	48 8d 78 10          	lea    0x10(%rax),%rdi
 4001881:	48 8d 45 b0          	lea    -0x50(%rbp),%rax
 4001885:	41 b9 01 00 00 00    	mov    $0x1,%r9d
 400188b:	41 b8 30 00 00 00    	mov    $0x30,%r8d
 4001891:	48 89 d1             	mov    %rdx,%rcx
 4001894:	48 89 c2             	mov    %rax,%rdx
 4001897:	e8 aa 6c 00 00       	call   4008546 <linearTBSerialInsert(unsigned long*, unsigned long, void*, void*, unsigned int, unsigned long)>
                sizeof(EFI_MEMORY_DESCRIPTORX64),1
            );
            
            // 跳过刚刚插入的项
            i++;
 400189c:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
    for (uint64_t i = 0; i < EfiMemMapEntryCount - 1; i++) {
 40018a1:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
 40018a6:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
 40018aa:	48 8b 40 10          	mov    0x10(%rax),%rax
 40018ae:	48 83 e8 01          	sub    $0x1,%rax
 40018b2:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
 40018b6:	0f 82 f1 fe ff ff    	jb     40017ad <GlobalMemoryPGlevelMgr_t::fillMemoryHolesInEfiMap()+0x25>
        }
    }
}
 40018bc:	90                   	nop
 40018bd:	90                   	nop
 40018be:	c9                   	leave
 40018bf:	c3                   	ret

00000000040018c0 <GlobalMemoryPGlevelMgr_t::reclaimLoaderMemory()>:
// 回收Loader内存（非Runtime属性）
void GlobalMemoryPGlevelMgr_t::reclaimLoaderMemory() {
 40018c0:	55                   	push   %rbp
 40018c1:	48 89 e5             	mov    %rsp,%rbp
 40018c4:	48 83 ec 30          	sub    $0x30,%rsp
 40018c8:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
    // 遍历物理内存描述符表，回收Loader内存
    for (uint64_t i = 0; i < rootPhymemTbentryCount; i++) {
 40018cc:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
 40018d3:	00 
 40018d4:	eb 5b                	jmp    4001931 <GlobalMemoryPGlevelMgr_t::reclaimLoaderMemory()+0x71>
        phy_memDesriptor* desc = &rootPhyMemDscptTbBsPtr[i];
 40018d6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 40018da:	48 8b 08             	mov    (%rax),%rcx
 40018dd:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
 40018e1:	48 89 d0             	mov    %rdx,%rax
 40018e4:	48 01 c0             	add    %rax,%rax
 40018e7:	48 01 d0             	add    %rdx,%rax
 40018ea:	48 c1 e0 04          	shl    $0x4,%rax
 40018ee:	48 01 c8             	add    %rcx,%rax
 40018f1:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
        
        // 只处理Loader类型的内存且不包含Runtime属性
        if ((desc->Type == EFI_LOADER_CODE || desc->Type == EFI_LOADER_DATA) &&
 40018f5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 40018f9:	8b 00                	mov    (%rax),%eax
 40018fb:	83 f8 01             	cmp    $0x1,%eax
 40018fe:	74 0b                	je     400190b <GlobalMemoryPGlevelMgr_t::reclaimLoaderMemory()+0x4b>
 4001900:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4001904:	8b 00                	mov    (%rax),%eax
 4001906:	83 f8 02             	cmp    $0x2,%eax
 4001909:	75 21                	jne    400192c <GlobalMemoryPGlevelMgr_t::reclaimLoaderMemory()+0x6c>
            !(desc->Attribute & EFI_MEMORY_RUNTIME)) {
 400190b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 400190f:	48 8b 40 20          	mov    0x20(%rax),%rax
        if ((desc->Type == EFI_LOADER_CODE || desc->Type == EFI_LOADER_DATA) &&
 4001913:	48 85 c0             	test   %rax,%rax
 4001916:	78 14                	js     400192c <GlobalMemoryPGlevelMgr_t::reclaimLoaderMemory()+0x6c>
            // 标记为系统空闲内存
            desc->Type = freeSystemRam;
 4001918:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 400191c:	c7 00 07 00 00 00    	movl   $0x7,(%rax)
            
            // 设置临时标志用于后续合并
            desc->ReservedUnion.TmpChainList.Flags = CLEAN_ENTRY;
 4001922:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4001926:	66 c7 40 06 00 00    	movw   $0x0,0x6(%rax)
    for (uint64_t i = 0; i < rootPhymemTbentryCount; i++) {
 400192c:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
 4001931:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4001935:	48 8b 40 18          	mov    0x18(%rax),%rax
 4001939:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
 400193d:	72 97                	jb     40018d6 <GlobalMemoryPGlevelMgr_t::reclaimLoaderMemory()+0x16>
        }
    }
    
   for (uint64_t i = 0; i < rootPhymemTbentryCount-1  ; i++)
 400193f:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
 4001946:	00 
 4001947:	e9 4c 01 00 00       	jmp    4001a98 <GlobalMemoryPGlevelMgr_t::reclaimLoaderMemory()+0x1d8>
   {
    if(rootPhyMemDscptTbBsPtr[i].Type == freeSystemRam)
 400194c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4001950:	48 8b 08             	mov    (%rax),%rcx
 4001953:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
 4001957:	48 89 d0             	mov    %rdx,%rax
 400195a:	48 01 c0             	add    %rax,%rax
 400195d:	48 01 d0             	add    %rdx,%rax
 4001960:	48 c1 e0 04          	shl    $0x4,%rax
 4001964:	48 01 c8             	add    %rcx,%rax
 4001967:	8b 00                	mov    (%rax),%eax
 4001969:	83 f8 07             	cmp    $0x7,%eax
 400196c:	0f 85 21 01 00 00    	jne    4001a93 <GlobalMemoryPGlevelMgr_t::reclaimLoaderMemory()+0x1d3>
        {
            if(rootPhyMemDscptTbBsPtr[i+1].Type == freeSystemRam)
 4001972:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4001976:	48 8b 08             	mov    (%rax),%rcx
 4001979:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 400197d:	48 8d 50 01          	lea    0x1(%rax),%rdx
 4001981:	48 89 d0             	mov    %rdx,%rax
 4001984:	48 01 c0             	add    %rax,%rax
 4001987:	48 01 d0             	add    %rdx,%rax
 400198a:	48 c1 e0 04          	shl    $0x4,%rax
 400198e:	48 01 c8             	add    %rcx,%rax
 4001991:	8b 00                	mov    (%rax),%eax
 4001993:	83 f8 07             	cmp    $0x7,%eax
 4001996:	0f 85 f7 00 00 00    	jne    4001a93 <GlobalMemoryPGlevelMgr_t::reclaimLoaderMemory()+0x1d3>
            {//后继也是启动时服务项
                if (Ismemspaceneighbors(i,i+1,1))
 400199c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 40019a0:	83 c0 01             	add    $0x1,%eax
 40019a3:	0f b7 d0             	movzwl %ax,%edx
 40019a6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 40019aa:	0f b7 f0             	movzwl %ax,%esi
 40019ad:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 40019b1:	b9 01 00 00 00       	mov    $0x1,%ecx
 40019b6:	48 89 c7             	mov    %rax,%rdi
 40019b9:	e8 66 11 00 00       	call   4002b24 <GlobalMemoryPGlevelMgr_t::Ismemspaceneighbors(unsigned short, unsigned short, unsigned long)>
 40019be:	84 c0                	test   %al,%al
 40019c0:	0f 84 cd 00 00 00    	je     4001a93 <GlobalMemoryPGlevelMgr_t::reclaimLoaderMemory()+0x1d3>
                {
                    rootPhyMemDscptTbBsPtr[i].ReservedUnion.TmpChainList.Flags=DIRTY_ENTRY;
 40019c6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 40019ca:	48 8b 08             	mov    (%rax),%rcx
 40019cd:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
 40019d1:	48 89 d0             	mov    %rdx,%rax
 40019d4:	48 01 c0             	add    %rax,%rax
 40019d7:	48 01 d0             	add    %rdx,%rax
 40019da:	48 c1 e0 04          	shl    $0x4,%rax
 40019de:	48 01 c8             	add    %rcx,%rax
 40019e1:	66 c7 40 06 01 00    	movw   $0x1,0x6(%rax)
                    rootPhyMemDscptTbBsPtr[i+1].PhysicalStart=rootPhyMemDscptTbBsPtr[i].PhysicalStart;
 40019e7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 40019eb:	48 8b 08             	mov    (%rax),%rcx
 40019ee:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
 40019f2:	48 89 d0             	mov    %rdx,%rax
 40019f5:	48 01 c0             	add    %rax,%rax
 40019f8:	48 01 d0             	add    %rdx,%rax
 40019fb:	48 c1 e0 04          	shl    $0x4,%rax
 40019ff:	48 01 c1             	add    %rax,%rcx
 4001a02:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4001a06:	48 8b 30             	mov    (%rax),%rsi
 4001a09:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 4001a0d:	48 8d 50 01          	lea    0x1(%rax),%rdx
 4001a11:	48 89 d0             	mov    %rdx,%rax
 4001a14:	48 01 c0             	add    %rax,%rax
 4001a17:	48 01 d0             	add    %rdx,%rax
 4001a1a:	48 c1 e0 04          	shl    $0x4,%rax
 4001a1e:	48 8d 14 06          	lea    (%rsi,%rax,1),%rdx
 4001a22:	48 8b 41 08          	mov    0x8(%rcx),%rax
 4001a26:	48 89 42 08          	mov    %rax,0x8(%rdx)
                    rootPhyMemDscptTbBsPtr[i+1].NumberOfPages+=rootPhyMemDscptTbBsPtr[i].NumberOfPages;
 4001a2a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4001a2e:	48 8b 08             	mov    (%rax),%rcx
 4001a31:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 4001a35:	48 8d 50 01          	lea    0x1(%rax),%rdx
 4001a39:	48 89 d0             	mov    %rdx,%rax
 4001a3c:	48 01 c0             	add    %rax,%rax
 4001a3f:	48 01 d0             	add    %rdx,%rax
 4001a42:	48 c1 e0 04          	shl    $0x4,%rax
 4001a46:	48 01 c8             	add    %rcx,%rax
 4001a49:	48 8b 70 18          	mov    0x18(%rax),%rsi
 4001a4d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4001a51:	48 8b 08             	mov    (%rax),%rcx
 4001a54:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
 4001a58:	48 89 d0             	mov    %rdx,%rax
 4001a5b:	48 01 c0             	add    %rax,%rax
 4001a5e:	48 01 d0             	add    %rdx,%rax
 4001a61:	48 c1 e0 04          	shl    $0x4,%rax
 4001a65:	48 01 c8             	add    %rcx,%rax
 4001a68:	48 8b 48 18          	mov    0x18(%rax),%rcx
 4001a6c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4001a70:	48 8b 38             	mov    (%rax),%rdi
 4001a73:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 4001a77:	48 8d 50 01          	lea    0x1(%rax),%rdx
 4001a7b:	48 89 d0             	mov    %rdx,%rax
 4001a7e:	48 01 c0             	add    %rax,%rax
 4001a81:	48 01 d0             	add    %rdx,%rax
 4001a84:	48 c1 e0 04          	shl    $0x4,%rax
 4001a88:	48 01 f8             	add    %rdi,%rax
 4001a8b:	48 8d 14 0e          	lea    (%rsi,%rcx,1),%rdx
 4001a8f:	48 89 50 18          	mov    %rdx,0x18(%rax)
   for (uint64_t i = 0; i < rootPhymemTbentryCount-1  ; i++)
 4001a93:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
 4001a98:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4001a9c:	48 8b 40 18          	mov    0x18(%rax),%rax
 4001aa0:	48 83 e8 01          	sub    $0x1,%rax
 4001aa4:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
 4001aa8:	0f 82 9e fe ff ff    	jb     400194c <GlobalMemoryPGlevelMgr_t::reclaimLoaderMemory()+0x8c>
                }
                
            } 
        }
   }
   dirtyentrydelete(1);
 4001aae:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4001ab2:	be 01 00 00 00       	mov    $0x1,%esi
 4001ab7:	48 89 c7             	mov    %rax,%rdi
 4001aba:	e8 31 f3 ff ff       	call   4000df0 <GlobalMemoryPGlevelMgr_t::dirtyentrydelete(unsigned long)>
}
 4001abf:	90                   	nop
 4001ac0:	c9                   	leave
 4001ac1:	c3                   	ret

0000000004001ac2 <GlobalMemoryPGlevelMgr_t::FixedPhyaddPgallocate(unsigned long, unsigned long, PHY_MEM_TYPE)>:
int GlobalMemoryPGlevelMgr_t::FixedPhyaddPgallocate(
    IN phyaddr_t addr,
    IN uint64_t size,
    IN PHY_MEM_TYPE type)
{
 4001ac2:	55                   	push   %rbp
 4001ac3:	48 89 e5             	mov    %rsp,%rbp
 4001ac6:	53                   	push   %rbx
 4001ac7:	48 81 ec 48 01 00 00 	sub    $0x148,%rsp
 4001ace:	48 89 bd c8 fe ff ff 	mov    %rdi,-0x138(%rbp)
 4001ad5:	48 89 b5 c0 fe ff ff 	mov    %rsi,-0x140(%rbp)
 4001adc:	48 89 95 b8 fe ff ff 	mov    %rdx,-0x148(%rbp)
 4001ae3:	89 8d b4 fe ff ff    	mov    %ecx,-0x14c(%rbp)
    if (Statusflags==0)
 4001ae9:	48 8b 85 c8 fe ff ff 	mov    -0x138(%rbp),%rax
 4001af0:	48 8b 40 20          	mov    0x20(%rax),%rax
 4001af4:	48 85 c0             	test   %rax,%rax
 4001af7:	75 0a                	jne    4001b03 <GlobalMemoryPGlevelMgr_t::FixedPhyaddPgallocate(unsigned long, unsigned long, PHY_MEM_TYPE)+0x41>
    {
       return -EINVAL;
 4001af9:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
 4001afe:	e9 ea 04 00 00       	jmp    4001fed <GlobalMemoryPGlevelMgr_t::FixedPhyaddPgallocate(unsigned long, unsigned long, PHY_MEM_TYPE)+0x52b>
    }
    
    const uint64_t requiredPages = (size + PAGE_SIZE_4KB - 1) / PAGE_SIZE_4KB;
 4001b03:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
 4001b0a:	48 05 ff 0f 00 00    	add    $0xfff,%rax
 4001b10:	48 c1 e8 0c          	shr    $0xc,%rax
 4001b14:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    
    // 验证地址对齐
    if (addr % PAGE_SIZE_4KB != 0) {
 4001b18:	48 8b 85 c0 fe ff ff 	mov    -0x140(%rbp),%rax
 4001b1f:	25 ff 0f 00 00       	and    $0xfff,%eax
 4001b24:	48 85 c0             	test   %rax,%rax
 4001b27:	74 0a                	je     4001b33 <GlobalMemoryPGlevelMgr_t::FixedPhyaddPgallocate(unsigned long, unsigned long, PHY_MEM_TYPE)+0x71>
        return -EINVAL;
 4001b29:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
 4001b2e:	e9 ba 04 00 00       	jmp    4001fed <GlobalMemoryPGlevelMgr_t::FixedPhyaddPgallocate(unsigned long, unsigned long, PHY_MEM_TYPE)+0x52b>
    }
    
    phy_memDesriptor* desc = queryPhysicalMemoryUsage(addr);
 4001b33:	48 8b 95 c0 fe ff ff 	mov    -0x140(%rbp),%rdx
 4001b3a:	48 8b 85 c8 fe ff ff 	mov    -0x138(%rbp),%rax
 4001b41:	48 89 d6             	mov    %rdx,%rsi
 4001b44:	48 89 c7             	mov    %rax,%rdi
 4001b47:	e8 d4 f1 ff ff       	call   4000d20 <GlobalMemoryPGlevelMgr_t::queryPhysicalMemoryUsage(unsigned long)>
 4001b4c:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    if (!desc || desc->Type != freeSystemRam) {
 4001b50:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
 4001b55:	74 0b                	je     4001b62 <GlobalMemoryPGlevelMgr_t::FixedPhyaddPgallocate(unsigned long, unsigned long, PHY_MEM_TYPE)+0xa0>
 4001b57:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4001b5b:	8b 00                	mov    (%rax),%eax
 4001b5d:	83 f8 07             	cmp    $0x7,%eax
 4001b60:	74 0a                	je     4001b6c <GlobalMemoryPGlevelMgr_t::FixedPhyaddPgallocate(unsigned long, unsigned long, PHY_MEM_TYPE)+0xaa>
        return -ENOMEM;
 4001b62:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
 4001b67:	e9 81 04 00 00       	jmp    4001fed <GlobalMemoryPGlevelMgr_t::FixedPhyaddPgallocate(unsigned long, unsigned long, PHY_MEM_TYPE)+0x52b>
    }
    
    const uint64_t endAddr = addr + requiredPages * PAGE_SIZE_4KB;
 4001b6c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4001b70:	48 c1 e0 0c          	shl    $0xc,%rax
 4001b74:	48 89 c2             	mov    %rax,%rdx
 4001b77:	48 8b 85 c0 fe ff ff 	mov    -0x140(%rbp),%rax
 4001b7e:	48 01 d0             	add    %rdx,%rax
 4001b81:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    const uint64_t descEnd = desc->PhysicalStart + desc->NumberOfPages * PAGE_SIZE_4KB;
 4001b85:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4001b89:	48 8b 50 08          	mov    0x8(%rax),%rdx
 4001b8d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4001b91:	48 8b 40 18          	mov    0x18(%rax),%rax
 4001b95:	48 c1 e0 0c          	shl    $0xc,%rax
 4001b99:	48 01 d0             	add    %rdx,%rax
 4001b9c:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    
    if (endAddr > descEnd) {
 4001ba0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4001ba4:	48 39 45 d0          	cmp    %rax,-0x30(%rbp)
 4001ba8:	73 0a                	jae    4001bb4 <GlobalMemoryPGlevelMgr_t::FixedPhyaddPgallocate(unsigned long, unsigned long, PHY_MEM_TYPE)+0xf2>
        return -ENOMEM;
 4001baa:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
 4001baf:	e9 39 04 00 00       	jmp    4001fed <GlobalMemoryPGlevelMgr_t::FixedPhyaddPgallocate(unsigned long, unsigned long, PHY_MEM_TYPE)+0x52b>
    }
    
    const uint64_t beforePages = (addr - desc->PhysicalStart) / PAGE_SIZE_4KB;
 4001bb4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4001bb8:	48 8b 40 08          	mov    0x8(%rax),%rax
 4001bbc:	48 8b 95 c0 fe ff ff 	mov    -0x140(%rbp),%rdx
 4001bc3:	48 29 c2             	sub    %rax,%rdx
 4001bc6:	48 89 d0             	mov    %rdx,%rax
 4001bc9:	48 c1 e8 0c          	shr    $0xc,%rax
 4001bcd:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    const uint64_t afterPages = (descEnd - endAddr) / PAGE_SIZE_4KB;
 4001bd1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
 4001bd5:	48 2b 45 d8          	sub    -0x28(%rbp),%rax
 4001bd9:	48 c1 e8 0c          	shr    $0xc,%rax
 4001bdd:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    
    if (beforePages > 0 && afterPages > 0) {
 4001be1:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
 4001be6:	0f 84 31 02 00 00    	je     4001e1d <GlobalMemoryPGlevelMgr_t::FixedPhyaddPgallocate(unsigned long, unsigned long, PHY_MEM_TYPE)+0x35b>
 4001bec:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
 4001bf1:	0f 84 26 02 00 00    	je     4001e1d <GlobalMemoryPGlevelMgr_t::FixedPhyaddPgallocate(unsigned long, unsigned long, PHY_MEM_TYPE)+0x35b>
        // ==== 修复1：正确分裂为三个区域 ====
        phy_memDesriptor originalDesc = *desc;  // 保存原始信息
 4001bf7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4001bfb:	48 8b 08             	mov    (%rax),%rcx
 4001bfe:	48 8b 58 08          	mov    0x8(%rax),%rbx
 4001c02:	48 89 8d d0 fe ff ff 	mov    %rcx,-0x130(%rbp)
 4001c09:	48 89 9d d8 fe ff ff 	mov    %rbx,-0x128(%rbp)
 4001c10:	48 8b 48 10          	mov    0x10(%rax),%rcx
 4001c14:	48 8b 58 18          	mov    0x18(%rax),%rbx
 4001c18:	48 89 8d e0 fe ff ff 	mov    %rcx,-0x120(%rbp)
 4001c1f:	48 89 9d e8 fe ff ff 	mov    %rbx,-0x118(%rbp)
 4001c26:	48 8b 50 28          	mov    0x28(%rax),%rdx
 4001c2a:	48 8b 40 20          	mov    0x20(%rax),%rax
 4001c2e:	48 89 85 f0 fe ff ff 	mov    %rax,-0x110(%rbp)
 4001c35:	48 89 95 f8 fe ff ff 	mov    %rdx,-0x108(%rbp)
        
        // 1. 修改当前描述符为前部空闲
        desc->NumberOfPages = beforePages;  // 保持freeSystemRam类型
 4001c3c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4001c40:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
 4001c44:	48 89 50 18          	mov    %rdx,0x18(%rax)
        
        // 2. 创建中间分配描述符
        phy_memDesriptor midDesc = originalDesc;
 4001c48:	48 8b 85 d0 fe ff ff 	mov    -0x130(%rbp),%rax
 4001c4f:	48 8b 95 d8 fe ff ff 	mov    -0x128(%rbp),%rdx
 4001c56:	48 89 85 00 ff ff ff 	mov    %rax,-0x100(%rbp)
 4001c5d:	48 89 95 08 ff ff ff 	mov    %rdx,-0xf8(%rbp)
 4001c64:	48 8b 85 e0 fe ff ff 	mov    -0x120(%rbp),%rax
 4001c6b:	48 8b 95 e8 fe ff ff 	mov    -0x118(%rbp),%rdx
 4001c72:	48 89 85 10 ff ff ff 	mov    %rax,-0xf0(%rbp)
 4001c79:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
 4001c80:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
 4001c87:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
 4001c8e:	48 89 85 20 ff ff ff 	mov    %rax,-0xe0(%rbp)
 4001c95:	48 89 95 28 ff ff ff 	mov    %rdx,-0xd8(%rbp)
        midDesc.PhysicalStart = addr;
 4001c9c:	48 8b 85 c0 fe ff ff 	mov    -0x140(%rbp),%rax
 4001ca3:	48 89 85 08 ff ff ff 	mov    %rax,-0xf8(%rbp)
        midDesc.NumberOfPages = requiredPages;
 4001caa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4001cae:	48 89 85 18 ff ff ff 	mov    %rax,-0xe8(%rbp)
        midDesc.Type = type;  // 设置分配类型
 4001cb5:	8b 85 b4 fe ff ff    	mov    -0x14c(%rbp),%eax
 4001cbb:	89 85 00 ff ff ff    	mov    %eax,-0x100(%rbp)
        
        // 3. 创建后部空闲描述符
        phy_memDesriptor afterDesc = originalDesc;
 4001cc1:	48 8b 85 d0 fe ff ff 	mov    -0x130(%rbp),%rax
 4001cc8:	48 8b 95 d8 fe ff ff 	mov    -0x128(%rbp),%rdx
 4001ccf:	48 89 85 30 ff ff ff 	mov    %rax,-0xd0(%rbp)
 4001cd6:	48 89 95 38 ff ff ff 	mov    %rdx,-0xc8(%rbp)
 4001cdd:	48 8b 85 e0 fe ff ff 	mov    -0x120(%rbp),%rax
 4001ce4:	48 8b 95 e8 fe ff ff 	mov    -0x118(%rbp),%rdx
 4001ceb:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
 4001cf2:	48 89 95 48 ff ff ff 	mov    %rdx,-0xb8(%rbp)
 4001cf9:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
 4001d00:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
 4001d07:	48 89 85 50 ff ff ff 	mov    %rax,-0xb0(%rbp)
 4001d0e:	48 89 95 58 ff ff ff 	mov    %rdx,-0xa8(%rbp)
        afterDesc.PhysicalStart = endAddr;
 4001d15:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4001d19:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
        afterDesc.NumberOfPages = afterPages;
 4001d20:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
 4001d24:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
        
        // 插入两个新描述符（分配块+后部空闲）
        phy_memDesriptor newDescs[2] = {midDesc, afterDesc};
 4001d2b:	48 8b 85 00 ff ff ff 	mov    -0x100(%rbp),%rax
 4001d32:	48 8b 95 08 ff ff ff 	mov    -0xf8(%rbp),%rdx
 4001d39:	48 89 85 60 ff ff ff 	mov    %rax,-0xa0(%rbp)
 4001d40:	48 89 95 68 ff ff ff 	mov    %rdx,-0x98(%rbp)
 4001d47:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
 4001d4e:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
 4001d55:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
 4001d5c:	48 89 95 78 ff ff ff 	mov    %rdx,-0x88(%rbp)
 4001d63:	48 8b 85 20 ff ff ff 	mov    -0xe0(%rbp),%rax
 4001d6a:	48 8b 95 28 ff ff ff 	mov    -0xd8(%rbp),%rdx
 4001d71:	48 89 45 80          	mov    %rax,-0x80(%rbp)
 4001d75:	48 89 55 88          	mov    %rdx,-0x78(%rbp)
 4001d79:	48 8b 85 30 ff ff ff 	mov    -0xd0(%rbp),%rax
 4001d80:	48 8b 95 38 ff ff ff 	mov    -0xc8(%rbp),%rdx
 4001d87:	48 89 45 90          	mov    %rax,-0x70(%rbp)
 4001d8b:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
 4001d8f:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
 4001d96:	48 8b 95 48 ff ff ff 	mov    -0xb8(%rbp),%rdx
 4001d9d:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
 4001da1:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
 4001da5:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
 4001dac:	48 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%rdx
 4001db3:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
 4001db7:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
        linearTBSerialInsert(
            &rootPhymemTbentryCount,
            desc - rootPhyMemDscptTbBsPtr + 1,
            newDescs,
            rootPhyMemDscptTbBsPtr,
 4001dbb:	48 8b 85 c8 fe ff ff 	mov    -0x138(%rbp),%rax
 4001dc2:	48 8b 10             	mov    (%rax),%rdx
            desc - rootPhyMemDscptTbBsPtr + 1,
 4001dc5:	48 8b 85 c8 fe ff ff 	mov    -0x138(%rbp),%rax
 4001dcc:	48 8b 00             	mov    (%rax),%rax
 4001dcf:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
 4001dd3:	48 29 c1             	sub    %rax,%rcx
 4001dd6:	48 c1 f9 04          	sar    $0x4,%rcx
 4001dda:	48 b8 ab aa aa aa aa 	movabs $0xaaaaaaaaaaaaaaab,%rax
 4001de1:	aa aa aa 
 4001de4:	48 0f af c1          	imul   %rcx,%rax
 4001de8:	48 83 c0 01          	add    $0x1,%rax
        linearTBSerialInsert(
 4001dec:	48 89 c6             	mov    %rax,%rsi
 4001def:	48 8b 85 c8 fe ff ff 	mov    -0x138(%rbp),%rax
 4001df6:	48 8d 78 18          	lea    0x18(%rax),%rdi
 4001dfa:	48 8d 85 60 ff ff ff 	lea    -0xa0(%rbp),%rax
 4001e01:	41 b9 02 00 00 00    	mov    $0x2,%r9d
 4001e07:	41 b8 30 00 00 00    	mov    $0x30,%r8d
 4001e0d:	48 89 d1             	mov    %rdx,%rcx
 4001e10:	48 89 c2             	mov    %rax,%rdx
 4001e13:	e8 2e 67 00 00       	call   4008546 <linearTBSerialInsert(unsigned long*, unsigned long, void*, void*, unsigned int, unsigned long)>
            sizeof(phy_memDesriptor),
            2  // 插入两个条目
        );
    }
 4001e18:	e9 cb 01 00 00       	jmp    4001fe8 <GlobalMemoryPGlevelMgr_t::FixedPhyaddPgallocate(unsigned long, unsigned long, PHY_MEM_TYPE)+0x526>
    else if (beforePages > 0) {
 4001e1d:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
 4001e22:	0f 84 d2 00 00 00    	je     4001efa <GlobalMemoryPGlevelMgr_t::FixedPhyaddPgallocate(unsigned long, unsigned long, PHY_MEM_TYPE)+0x438>
        // 情况2：分配尾部区域
        phy_memDesriptor newDesc = *desc;
 4001e28:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4001e2c:	48 8b 08             	mov    (%rax),%rcx
 4001e2f:	48 8b 58 08          	mov    0x8(%rax),%rbx
 4001e33:	48 89 8d 60 ff ff ff 	mov    %rcx,-0xa0(%rbp)
 4001e3a:	48 89 9d 68 ff ff ff 	mov    %rbx,-0x98(%rbp)
 4001e41:	48 8b 48 10          	mov    0x10(%rax),%rcx
 4001e45:	48 8b 58 18          	mov    0x18(%rax),%rbx
 4001e49:	48 89 8d 70 ff ff ff 	mov    %rcx,-0x90(%rbp)
 4001e50:	48 89 9d 78 ff ff ff 	mov    %rbx,-0x88(%rbp)
 4001e57:	48 8b 50 28          	mov    0x28(%rax),%rdx
 4001e5b:	48 8b 40 20          	mov    0x20(%rax),%rax
 4001e5f:	48 89 45 80          	mov    %rax,-0x80(%rbp)
 4001e63:	48 89 55 88          	mov    %rdx,-0x78(%rbp)
        newDesc.PhysicalStart = addr;
 4001e67:	48 8b 85 c0 fe ff ff 	mov    -0x140(%rbp),%rax
 4001e6e:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
        newDesc.NumberOfPages = requiredPages;
 4001e75:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4001e79:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
        newDesc.Type = type;  // 设置分配类型
 4001e80:	8b 85 b4 fe ff ff    	mov    -0x14c(%rbp),%eax
 4001e86:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%rbp)
        
        // 修改原描述符为前部空闲（保持freeSystemRam类型）
        desc->NumberOfPages = beforePages;
 4001e8c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4001e90:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
 4001e94:	48 89 50 18          	mov    %rdx,0x18(%rax)
        // 插入分配块
        linearTBSerialInsert(
            &rootPhymemTbentryCount,
            desc - rootPhyMemDscptTbBsPtr + 1,
            &newDesc,
            rootPhyMemDscptTbBsPtr,
 4001e98:	48 8b 85 c8 fe ff ff 	mov    -0x138(%rbp),%rax
 4001e9f:	48 8b 10             	mov    (%rax),%rdx
            desc - rootPhyMemDscptTbBsPtr + 1,
 4001ea2:	48 8b 85 c8 fe ff ff 	mov    -0x138(%rbp),%rax
 4001ea9:	48 8b 00             	mov    (%rax),%rax
 4001eac:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
 4001eb0:	48 29 c1             	sub    %rax,%rcx
 4001eb3:	48 c1 f9 04          	sar    $0x4,%rcx
 4001eb7:	48 b8 ab aa aa aa aa 	movabs $0xaaaaaaaaaaaaaaab,%rax
 4001ebe:	aa aa aa 
 4001ec1:	48 0f af c1          	imul   %rcx,%rax
 4001ec5:	48 83 c0 01          	add    $0x1,%rax
        linearTBSerialInsert(
 4001ec9:	48 89 c6             	mov    %rax,%rsi
 4001ecc:	48 8b 85 c8 fe ff ff 	mov    -0x138(%rbp),%rax
 4001ed3:	48 8d 78 18          	lea    0x18(%rax),%rdi
 4001ed7:	48 8d 85 60 ff ff ff 	lea    -0xa0(%rbp),%rax
 4001ede:	41 b9 01 00 00 00    	mov    $0x1,%r9d
 4001ee4:	41 b8 30 00 00 00    	mov    $0x30,%r8d
 4001eea:	48 89 d1             	mov    %rdx,%rcx
 4001eed:	48 89 c2             	mov    %rax,%rdx
 4001ef0:	e8 51 66 00 00       	call   4008546 <linearTBSerialInsert(unsigned long*, unsigned long, void*, void*, unsigned int, unsigned long)>
 4001ef5:	e9 ee 00 00 00       	jmp    4001fe8 <GlobalMemoryPGlevelMgr_t::FixedPhyaddPgallocate(unsigned long, unsigned long, PHY_MEM_TYPE)+0x526>
        );
        
        // ==== 修复2：删除错误的类型设置 ====
        // desc->Type 保持 freeSystemRam 不变
    }
    else if (afterPages > 0) {
 4001efa:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
 4001eff:	0f 84 d7 00 00 00    	je     4001fdc <GlobalMemoryPGlevelMgr_t::FixedPhyaddPgallocate(unsigned long, unsigned long, PHY_MEM_TYPE)+0x51a>
        // 情况3：分配头部区域
        phy_memDesriptor newDesc = *desc;
 4001f05:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4001f09:	48 8b 08             	mov    (%rax),%rcx
 4001f0c:	48 8b 58 08          	mov    0x8(%rax),%rbx
 4001f10:	48 89 8d 60 ff ff ff 	mov    %rcx,-0xa0(%rbp)
 4001f17:	48 89 9d 68 ff ff ff 	mov    %rbx,-0x98(%rbp)
 4001f1e:	48 8b 48 10          	mov    0x10(%rax),%rcx
 4001f22:	48 8b 58 18          	mov    0x18(%rax),%rbx
 4001f26:	48 89 8d 70 ff ff ff 	mov    %rcx,-0x90(%rbp)
 4001f2d:	48 89 9d 78 ff ff ff 	mov    %rbx,-0x88(%rbp)
 4001f34:	48 8b 50 28          	mov    0x28(%rax),%rdx
 4001f38:	48 8b 40 20          	mov    0x20(%rax),%rax
 4001f3c:	48 89 45 80          	mov    %rax,-0x80(%rbp)
 4001f40:	48 89 55 88          	mov    %rdx,-0x78(%rbp)
        newDesc.PhysicalStart = addr;
 4001f44:	48 8b 85 c0 fe ff ff 	mov    -0x140(%rbp),%rax
 4001f4b:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
        newDesc.NumberOfPages = requiredPages;
 4001f52:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4001f56:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
        newDesc.Type = type;  // 设置分配类型
 4001f5d:	8b 85 b4 fe ff ff    	mov    -0x14c(%rbp),%eax
 4001f63:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%rbp)
        
        // 修改原描述符为后部空闲
        desc->PhysicalStart = endAddr;
 4001f69:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4001f6d:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
 4001f71:	48 89 50 08          	mov    %rdx,0x8(%rax)
        desc->NumberOfPages = afterPages;
 4001f75:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4001f79:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
 4001f7d:	48 89 50 18          	mov    %rdx,0x18(%rax)
        // 插入分配块
        linearTBSerialInsert(
            &rootPhymemTbentryCount,
            desc - rootPhyMemDscptTbBsPtr,
            &newDesc,
            rootPhyMemDscptTbBsPtr,
 4001f81:	48 8b 85 c8 fe ff ff 	mov    -0x138(%rbp),%rax
 4001f88:	48 8b 10             	mov    (%rax),%rdx
            desc - rootPhyMemDscptTbBsPtr,
 4001f8b:	48 8b 85 c8 fe ff ff 	mov    -0x138(%rbp),%rax
 4001f92:	48 8b 00             	mov    (%rax),%rax
 4001f95:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
 4001f99:	48 29 c1             	sub    %rax,%rcx
 4001f9c:	48 c1 f9 04          	sar    $0x4,%rcx
 4001fa0:	48 b8 ab aa aa aa aa 	movabs $0xaaaaaaaaaaaaaaab,%rax
 4001fa7:	aa aa aa 
 4001faa:	48 0f af c1          	imul   %rcx,%rax
        linearTBSerialInsert(
 4001fae:	48 89 c6             	mov    %rax,%rsi
 4001fb1:	48 8b 85 c8 fe ff ff 	mov    -0x138(%rbp),%rax
 4001fb8:	48 8d 78 18          	lea    0x18(%rax),%rdi
 4001fbc:	48 8d 85 60 ff ff ff 	lea    -0xa0(%rbp),%rax
 4001fc3:	41 b9 01 00 00 00    	mov    $0x1,%r9d
 4001fc9:	41 b8 30 00 00 00    	mov    $0x30,%r8d
 4001fcf:	48 89 d1             	mov    %rdx,%rcx
 4001fd2:	48 89 c2             	mov    %rax,%rdx
 4001fd5:	e8 6c 65 00 00       	call   4008546 <linearTBSerialInsert(unsigned long*, unsigned long, void*, void*, unsigned int, unsigned long)>
 4001fda:	eb 0c                	jmp    4001fe8 <GlobalMemoryPGlevelMgr_t::FixedPhyaddPgallocate(unsigned long, unsigned long, PHY_MEM_TYPE)+0x526>
        // ==== 修复3：删除错误的类型设置 ====
        // desc->Type 保持 freeSystemRam 不变
    }
    else {
        // 整个块分配（无前后空闲区域）
        desc->Type = type;
 4001fdc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4001fe0:	8b 95 b4 fe ff ff    	mov    -0x14c(%rbp),%edx
 4001fe6:	89 10                	mov    %edx,(%rax)
    }
    
    return 0;
 4001fe8:	b8 00 00 00 00       	mov    $0x0,%eax
}
 4001fed:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
 4001ff1:	c9                   	leave
 4001ff2:	c3                   	ret
 4001ff3:	90                   	nop

0000000004001ff4 <GlobalMemoryPGlevelMgr_t::defaultPhyaddPgallocate(unsigned long&, unsigned long, PHY_MEM_TYPE)>:

int GlobalMemoryPGlevelMgr_t::defaultPhyaddPgallocate(
    IN OUT phyaddr_t& addr,  // 通过引用修改addr
    IN uint64_t size,
    IN PHY_MEM_TYPE type)
{
 4001ff4:	55                   	push   %rbp
 4001ff5:	48 89 e5             	mov    %rsp,%rbp
 4001ff8:	48 83 ec 40          	sub    $0x40,%rsp
 4001ffc:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
 4002000:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
 4002004:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
 4002008:	89 4d c4             	mov    %ecx,-0x3c(%rbp)
        if (Statusflags==0)
 400200b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 400200f:	48 8b 40 20          	mov    0x20(%rax),%rax
 4002013:	48 85 c0             	test   %rax,%rax
 4002016:	75 0a                	jne    4002022 <GlobalMemoryPGlevelMgr_t::defaultPhyaddPgallocate(unsigned long&, unsigned long, PHY_MEM_TYPE)+0x2e>
    {
       return -EINVAL;
 4002018:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
 400201d:	e9 97 00 00 00       	jmp    40020b9 <GlobalMemoryPGlevelMgr_t::defaultPhyaddPgallocate(unsigned long&, unsigned long, PHY_MEM_TYPE)+0xc5>
    }
    const uint64_t requiredPages = (size + PAGE_SIZE_4KB - 1) / PAGE_SIZE_4KB;
 4002022:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 4002026:	48 05 ff 0f 00 00    	add    $0xfff,%rax
 400202c:	48 c1 e8 0c          	shr    $0xc,%rax
 4002030:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    
    // 遍历查找合适的空闲块
    for (uint64_t i = 0; i < rootPhymemTbentryCount; ++i) {
 4002034:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
 400203b:	00 
 400203c:	eb 68                	jmp    40020a6 <GlobalMemoryPGlevelMgr_t::defaultPhyaddPgallocate(unsigned long&, unsigned long, PHY_MEM_TYPE)+0xb2>
        phy_memDesriptor* desc = &rootPhyMemDscptTbBsPtr[i];
 400203e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4002042:	48 8b 08             	mov    (%rax),%rcx
 4002045:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
 4002049:	48 89 d0             	mov    %rdx,%rax
 400204c:	48 01 c0             	add    %rax,%rax
 400204f:	48 01 d0             	add    %rdx,%rax
 4002052:	48 c1 e0 04          	shl    $0x4,%rax
 4002056:	48 01 c8             	add    %rcx,%rax
 4002059:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
        
        if (desc->Type == freeSystemRam && 
 400205d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4002061:	8b 00                	mov    (%rax),%eax
 4002063:	83 f8 07             	cmp    $0x7,%eax
 4002066:	75 39                	jne    40020a1 <GlobalMemoryPGlevelMgr_t::defaultPhyaddPgallocate(unsigned long&, unsigned long, PHY_MEM_TYPE)+0xad>
            desc->NumberOfPages >= requiredPages) {
 4002068:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 400206c:	48 8b 40 18          	mov    0x18(%rax),%rax
        if (desc->Type == freeSystemRam && 
 4002070:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
 4002074:	72 2b                	jb     40020a1 <GlobalMemoryPGlevelMgr_t::defaultPhyaddPgallocate(unsigned long&, unsigned long, PHY_MEM_TYPE)+0xad>
            
            addr = desc->PhysicalStart;  // 设置输出地址
 4002076:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 400207a:	48 8b 50 08          	mov    0x8(%rax),%rdx
 400207e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
 4002082:	48 89 10             	mov    %rdx,(%rax)
            return FixedPhyaddPgallocate(addr, size, type);
 4002085:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
 4002089:	48 8b 30             	mov    (%rax),%rsi
 400208c:	8b 4d c4             	mov    -0x3c(%rbp),%ecx
 400208f:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
 4002093:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4002097:	48 89 c7             	mov    %rax,%rdi
 400209a:	e8 23 fa ff ff       	call   4001ac2 <GlobalMemoryPGlevelMgr_t::FixedPhyaddPgallocate(unsigned long, unsigned long, PHY_MEM_TYPE)>
 400209f:	eb 18                	jmp    40020b9 <GlobalMemoryPGlevelMgr_t::defaultPhyaddPgallocate(unsigned long&, unsigned long, PHY_MEM_TYPE)+0xc5>
    for (uint64_t i = 0; i < rootPhymemTbentryCount; ++i) {
 40020a1:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
 40020a6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 40020aa:	48 8b 40 18          	mov    0x18(%rax),%rax
 40020ae:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
 40020b2:	72 8a                	jb     400203e <GlobalMemoryPGlevelMgr_t::defaultPhyaddPgallocate(unsigned long&, unsigned long, PHY_MEM_TYPE)+0x4a>
        }
    }
    
    return -ENOMEM;  // 没有找到合适的内存块
 40020b4:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
}
 40020b9:	c9                   	leave
 40020ba:	c3                   	ret
 40020bb:	90                   	nop

00000000040020bc <GlobalMemoryPGlevelMgr_t::SameNeighborMerge(unsigned long)>:

void* GlobalMemoryPGlevelMgr_t::SameNeighborMerge(phyaddr_t addr)
{
 40020bc:	55                   	push   %rbp
 40020bd:	48 89 e5             	mov    %rsp,%rbp
 40020c0:	48 83 ec 60          	sub    $0x60,%rsp
 40020c4:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
 40020c8:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
        if (Statusflags==0)
 40020cc:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
 40020d0:	48 8b 40 20          	mov    0x20(%rax),%rax
 40020d4:	48 85 c0             	test   %rax,%rax
 40020d7:	75 0a                	jne    40020e3 <GlobalMemoryPGlevelMgr_t::SameNeighborMerge(unsigned long)+0x27>
    {
       return NULL;
 40020d9:	b8 00 00 00 00       	mov    $0x0,%eax
 40020de:	e9 5f 02 00 00       	jmp    4002342 <GlobalMemoryPGlevelMgr_t::SameNeighborMerge(unsigned long)+0x286>
    }
    // 查找包含指定地址的内存描述符
    phy_memDesriptor* current = queryPhysicalMemoryUsage(addr);
 40020e3:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
 40020e7:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
 40020eb:	48 89 d6             	mov    %rdx,%rsi
 40020ee:	48 89 c7             	mov    %rax,%rdi
 40020f1:	e8 2a ec ff ff       	call   4000d20 <GlobalMemoryPGlevelMgr_t::queryPhysicalMemoryUsage(unsigned long)>
 40020f6:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    if (!current || current->Type == freeSystemRam) 
 40020fa:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
 40020ff:	74 0b                	je     400210c <GlobalMemoryPGlevelMgr_t::SameNeighborMerge(unsigned long)+0x50>
 4002101:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
 4002105:	8b 00                	mov    (%rax),%eax
 4002107:	83 f8 07             	cmp    $0x7,%eax
 400210a:	75 0a                	jne    4002116 <GlobalMemoryPGlevelMgr_t::SameNeighborMerge(unsigned long)+0x5a>
        return NULL;
 400210c:	b8 00 00 00 00       	mov    $0x0,%eax
 4002111:	e9 2c 02 00 00       	jmp    4002342 <GlobalMemoryPGlevelMgr_t::SameNeighborMerge(unsigned long)+0x286>

    // 获取当前描述符在表中的索引
    uint64_t currentIdx = current - rootPhyMemDscptTbBsPtr;
 4002116:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
 400211a:	48 8b 00             	mov    (%rax),%rax
 400211d:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
 4002121:	48 29 c2             	sub    %rax,%rdx
 4002124:	48 c1 fa 04          	sar    $0x4,%rdx
 4002128:	48 b8 ab aa aa aa aa 	movabs $0xaaaaaaaaaaaaaaab,%rax
 400212f:	aa aa aa 
 4002132:	48 0f af c2          	imul   %rdx,%rax
 4002136:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    uint64_t startIdx = currentIdx;  // 合并起始索引
 400213a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 400213e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    uint64_t endIdx = currentIdx;    // 合并结束索引
 4002142:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 4002146:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    bool merged = false;
 400214a:	c6 45 b7 00          	movb   $0x0,-0x49(%rbp)

    // 向前查找可合并的连续块
    for (int64_t i = currentIdx - 1; i >= 0; i--) {
 400214e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 4002152:	48 83 e8 01          	sub    $0x1,%rax
 4002156:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
 400215a:	eb 6a                	jmp    40021c6 <GlobalMemoryPGlevelMgr_t::SameNeighborMerge(unsigned long)+0x10a>
        if (rootPhyMemDscptTbBsPtr[i].Type == current->Type &&
 400215c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
 4002160:	48 8b 08             	mov    (%rax),%rcx
 4002163:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
 4002167:	48 89 d0             	mov    %rdx,%rax
 400216a:	48 01 c0             	add    %rax,%rax
 400216d:	48 01 d0             	add    %rdx,%rax
 4002170:	48 c1 e0 04          	shl    $0x4,%rax
 4002174:	48 01 c8             	add    %rcx,%rax
 4002177:	8b 10                	mov    (%rax),%edx
 4002179:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
 400217d:	8b 00                	mov    (%rax),%eax
 400217f:	39 c2                	cmp    %eax,%edx
 4002181:	75 2d                	jne    40021b0 <GlobalMemoryPGlevelMgr_t::SameNeighborMerge(unsigned long)+0xf4>
            Ismemspaceneighbors(i, i+1, 1)) 
 4002183:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4002187:	83 c0 01             	add    $0x1,%eax
 400218a:	0f b7 d0             	movzwl %ax,%edx
 400218d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4002191:	0f b7 f0             	movzwl %ax,%esi
 4002194:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
 4002198:	b9 01 00 00 00       	mov    $0x1,%ecx
 400219d:	48 89 c7             	mov    %rax,%rdi
 40021a0:	e8 7f 09 00 00       	call   4002b24 <GlobalMemoryPGlevelMgr_t::Ismemspaceneighbors(unsigned short, unsigned short, unsigned long)>
        if (rootPhyMemDscptTbBsPtr[i].Type == current->Type &&
 40021a5:	84 c0                	test   %al,%al
 40021a7:	74 07                	je     40021b0 <GlobalMemoryPGlevelMgr_t::SameNeighborMerge(unsigned long)+0xf4>
 40021a9:	b8 01 00 00 00       	mov    $0x1,%eax
 40021ae:	eb 05                	jmp    40021b5 <GlobalMemoryPGlevelMgr_t::SameNeighborMerge(unsigned long)+0xf9>
 40021b0:	b8 00 00 00 00       	mov    $0x0,%eax
 40021b5:	84 c0                	test   %al,%al
 40021b7:	74 16                	je     40021cf <GlobalMemoryPGlevelMgr_t::SameNeighborMerge(unsigned long)+0x113>
        {
            startIdx = i;
 40021b9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 40021bd:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    for (int64_t i = currentIdx - 1; i >= 0; i--) {
 40021c1:	48 83 6d e8 01       	subq   $0x1,-0x18(%rbp)
 40021c6:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
 40021cb:	79 8f                	jns    400215c <GlobalMemoryPGlevelMgr_t::SameNeighborMerge(unsigned long)+0xa0>
 40021cd:	eb 01                	jmp    40021d0 <GlobalMemoryPGlevelMgr_t::SameNeighborMerge(unsigned long)+0x114>
        } else {
            break;
 40021cf:	90                   	nop
        }
    }

    // 向后查找可合并的连续块
    for (uint64_t i = currentIdx + 1; i < rootPhymemTbentryCount; i++) {
 40021d0:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 40021d4:	48 83 c0 01          	add    $0x1,%rax
 40021d8:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
 40021dc:	eb 6a                	jmp    4002248 <GlobalMemoryPGlevelMgr_t::SameNeighborMerge(unsigned long)+0x18c>
        if (rootPhyMemDscptTbBsPtr[i].Type == current->Type &&
 40021de:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
 40021e2:	48 8b 08             	mov    (%rax),%rcx
 40021e5:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
 40021e9:	48 89 d0             	mov    %rdx,%rax
 40021ec:	48 01 c0             	add    %rax,%rax
 40021ef:	48 01 d0             	add    %rdx,%rax
 40021f2:	48 c1 e0 04          	shl    $0x4,%rax
 40021f6:	48 01 c8             	add    %rcx,%rax
 40021f9:	8b 10                	mov    (%rax),%edx
 40021fb:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
 40021ff:	8b 00                	mov    (%rax),%eax
 4002201:	39 c2                	cmp    %eax,%edx
 4002203:	75 2d                	jne    4002232 <GlobalMemoryPGlevelMgr_t::SameNeighborMerge(unsigned long)+0x176>
            Ismemspaceneighbors(i-1, i, 1)) 
 4002205:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4002209:	0f b7 d0             	movzwl %ax,%edx
 400220c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4002210:	83 e8 01             	sub    $0x1,%eax
 4002213:	0f b7 f0             	movzwl %ax,%esi
 4002216:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
 400221a:	b9 01 00 00 00       	mov    $0x1,%ecx
 400221f:	48 89 c7             	mov    %rax,%rdi
 4002222:	e8 fd 08 00 00       	call   4002b24 <GlobalMemoryPGlevelMgr_t::Ismemspaceneighbors(unsigned short, unsigned short, unsigned long)>
        if (rootPhyMemDscptTbBsPtr[i].Type == current->Type &&
 4002227:	84 c0                	test   %al,%al
 4002229:	74 07                	je     4002232 <GlobalMemoryPGlevelMgr_t::SameNeighborMerge(unsigned long)+0x176>
 400222b:	b8 01 00 00 00       	mov    $0x1,%eax
 4002230:	eb 05                	jmp    4002237 <GlobalMemoryPGlevelMgr_t::SameNeighborMerge(unsigned long)+0x17b>
 4002232:	b8 00 00 00 00       	mov    $0x0,%eax
 4002237:	84 c0                	test   %al,%al
 4002239:	74 1d                	je     4002258 <GlobalMemoryPGlevelMgr_t::SameNeighborMerge(unsigned long)+0x19c>
        {
            endIdx = i;
 400223b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 400223f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    for (uint64_t i = currentIdx + 1; i < rootPhymemTbentryCount; i++) {
 4002243:	48 83 45 e0 01       	addq   $0x1,-0x20(%rbp)
 4002248:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
 400224c:	48 8b 40 18          	mov    0x18(%rax),%rax
 4002250:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
 4002254:	72 88                	jb     40021de <GlobalMemoryPGlevelMgr_t::SameNeighborMerge(unsigned long)+0x122>
 4002256:	eb 01                	jmp    4002259 <GlobalMemoryPGlevelMgr_t::SameNeighborMerge(unsigned long)+0x19d>
        } else {
            break;
 4002258:	90                   	nop
        }
    }

    // 如果不需要合并（只有一个块）
    if (startIdx == endIdx) 
 4002259:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 400225d:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
 4002261:	75 09                	jne    400226c <GlobalMemoryPGlevelMgr_t::SameNeighborMerge(unsigned long)+0x1b0>
        return current;
 4002263:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
 4002267:	e9 d6 00 00 00       	jmp    4002342 <GlobalMemoryPGlevelMgr_t::SameNeighborMerge(unsigned long)+0x286>

    // ==== 合并连续块 ====
    merged = true;
 400226c:	c6 45 b7 01          	movb   $0x1,-0x49(%rbp)
    
    // 1. 计算合并后的总页数
    uint64_t totalPages = 0;
 4002270:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
 4002277:	00 
    for (uint64_t i = startIdx; i <= endIdx; i++) {
 4002278:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 400227c:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
 4002280:	eb 28                	jmp    40022aa <GlobalMemoryPGlevelMgr_t::SameNeighborMerge(unsigned long)+0x1ee>
        totalPages += rootPhyMemDscptTbBsPtr[i].NumberOfPages;
 4002282:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
 4002286:	48 8b 08             	mov    (%rax),%rcx
 4002289:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
 400228d:	48 89 d0             	mov    %rdx,%rax
 4002290:	48 01 c0             	add    %rax,%rax
 4002293:	48 01 d0             	add    %rdx,%rax
 4002296:	48 c1 e0 04          	shl    $0x4,%rax
 400229a:	48 01 c8             	add    %rcx,%rax
 400229d:	48 8b 40 18          	mov    0x18(%rax),%rax
 40022a1:	48 01 45 d8          	add    %rax,-0x28(%rbp)
    for (uint64_t i = startIdx; i <= endIdx; i++) {
 40022a5:	48 83 45 d0 01       	addq   $0x1,-0x30(%rbp)
 40022aa:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
 40022ae:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
 40022b2:	73 ce                	jae    4002282 <GlobalMemoryPGlevelMgr_t::SameNeighborMerge(unsigned long)+0x1c6>
    }
    
    // 2. 更新起始块的描述符
    rootPhyMemDscptTbBsPtr[startIdx].NumberOfPages = totalPages;
 40022b4:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
 40022b8:	48 8b 08             	mov    (%rax),%rcx
 40022bb:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
 40022bf:	48 89 d0             	mov    %rdx,%rax
 40022c2:	48 01 c0             	add    %rax,%rax
 40022c5:	48 01 d0             	add    %rdx,%rax
 40022c8:	48 c1 e0 04          	shl    $0x4,%rax
 40022cc:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
 40022d0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 40022d4:	48 89 42 18          	mov    %rax,0x18(%rdx)
    
    // 3. 标记后续块为脏（准备删除）
    for (uint64_t i = startIdx + 1; i <= endIdx; i++) {
 40022d8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 40022dc:	48 83 c0 01          	add    $0x1,%rax
 40022e0:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
 40022e4:	eb 26                	jmp    400230c <GlobalMemoryPGlevelMgr_t::SameNeighborMerge(unsigned long)+0x250>
        rootPhyMemDscptTbBsPtr[i].ReservedUnion.TmpChainList.Flags = DIRTY_ENTRY;
 40022e6:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
 40022ea:	48 8b 08             	mov    (%rax),%rcx
 40022ed:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
 40022f1:	48 89 d0             	mov    %rdx,%rax
 40022f4:	48 01 c0             	add    %rax,%rax
 40022f7:	48 01 d0             	add    %rdx,%rax
 40022fa:	48 c1 e0 04          	shl    $0x4,%rax
 40022fe:	48 01 c8             	add    %rcx,%rax
 4002301:	66 c7 40 06 01 00    	movw   $0x1,0x6(%rax)
    for (uint64_t i = startIdx + 1; i <= endIdx; i++) {
 4002307:	48 83 45 c8 01       	addq   $0x1,-0x38(%rbp)
 400230c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 4002310:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
 4002314:	73 d0                	jae    40022e6 <GlobalMemoryPGlevelMgr_t::SameNeighborMerge(unsigned long)+0x22a>
    }
    
    // 4. 批量删除标记为脏的项
    dirtyentrydelete(1);  // tbid=1表示操作系统内存描述表
 4002316:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
 400231a:	be 01 00 00 00       	mov    $0x1,%esi
 400231f:	48 89 c7             	mov    %rax,%rdi
 4002322:	e8 c9 ea ff ff       	call   4000df0 <GlobalMemoryPGlevelMgr_t::dirtyentrydelete(unsigned long)>
    
    return &rootPhyMemDscptTbBsPtr[startIdx];
 4002327:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
 400232b:	48 8b 08             	mov    (%rax),%rcx
 400232e:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
 4002332:	48 89 d0             	mov    %rdx,%rax
 4002335:	48 01 c0             	add    %rax,%rax
 4002338:	48 01 d0             	add    %rdx,%rax
 400233b:	48 c1 e0 04          	shl    $0x4,%rax
 400233f:	48 01 c8             	add    %rcx,%rax
}
 4002342:	c9                   	leave
 4002343:	c3                   	ret

0000000004002344 <GlobalMemoryPGlevelMgr_t::pageRecycle(unsigned long)>:
/**
 *页回收函数传入的地址必须为某一个项的物理地址，否则会报错
 *一个地址回收后其地址会尽可能与相邻的其它空闲内存块合并
 */
int GlobalMemoryPGlevelMgr_t::pageRecycle(phyaddr_t EntryStartphyaddr)
{
 4002344:	55                   	push   %rbp
 4002345:	48 89 e5             	mov    %rsp,%rbp
 4002348:	48 83 ec 30          	sub    $0x30,%rsp
 400234c:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
 4002350:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
        if (Statusflags==0)
 4002354:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4002358:	48 8b 40 20          	mov    0x20(%rax),%rax
 400235c:	48 85 c0             	test   %rax,%rax
 400235f:	75 0a                	jne    400236b <GlobalMemoryPGlevelMgr_t::pageRecycle(unsigned long)+0x27>
    {
       return -EINVAL;
 4002361:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
 4002366:	e9 10 02 00 00       	jmp    400257b <GlobalMemoryPGlevelMgr_t::pageRecycle(unsigned long)+0x237>
    }
    // 1. 查找包含该地址的内存描述符
    phy_memDesriptor* desc = queryPhysicalMemoryUsage(EntryStartphyaddr);
 400236b:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
 400236f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4002373:	48 89 d6             	mov    %rdx,%rsi
 4002376:	48 89 c7             	mov    %rax,%rdi
 4002379:	e8 a2 e9 ff ff       	call   4000d20 <GlobalMemoryPGlevelMgr_t::queryPhysicalMemoryUsage(unsigned long)>
 400237e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if (!desc) {
 4002382:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
 4002387:	75 0a                	jne    4002393 <GlobalMemoryPGlevelMgr_t::pageRecycle(unsigned long)+0x4f>
        return -ENOENT; // 地址未找到
 4002389:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
 400238e:	e9 e8 01 00 00       	jmp    400257b <GlobalMemoryPGlevelMgr_t::pageRecycle(unsigned long)+0x237>
    }

    // 2. 验证地址必须是描述符的起始地址
    if (desc->PhysicalStart != EntryStartphyaddr) {
 4002393:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4002397:	48 8b 40 08          	mov    0x8(%rax),%rax
 400239b:	48 39 45 d0          	cmp    %rax,-0x30(%rbp)
 400239f:	74 0a                	je     40023ab <GlobalMemoryPGlevelMgr_t::pageRecycle(unsigned long)+0x67>
        return -EINVAL; // 地址不是内存块的起始地址
 40023a1:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
 40023a6:	e9 d0 01 00 00       	jmp    400257b <GlobalMemoryPGlevelMgr_t::pageRecycle(unsigned long)+0x237>
    }

    // 3. 保存原始类型用于合并条件检查
    PHY_MEM_TYPE originalType = static_cast<PHY_MEM_TYPE>(desc->Type);
 40023ab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 40023af:	8b 00                	mov    (%rax),%eax
 40023b1:	89 45 f4             	mov    %eax,-0xc(%rbp)
    
    // 4. 将内存标记为空闲（准备回收）
    desc->Type = freeSystemRam;
 40023b4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 40023b8:	c7 00 07 00 00 00    	movl   $0x7,(%rax)

    // 5. 尝试向前合并（与前一个空闲块）
    if (desc > rootPhyMemDscptTbBsPtr) {
 40023be:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 40023c2:	48 8b 00             	mov    (%rax),%rax
 40023c5:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
 40023c9:	0f 83 b7 00 00 00    	jae    4002486 <GlobalMemoryPGlevelMgr_t::pageRecycle(unsigned long)+0x142>
        phy_memDesriptor* prevDesc = desc - 1;
 40023cf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 40023d3:	48 83 e8 30          	sub    $0x30,%rax
 40023d7:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
        if (prevDesc->Type == freeSystemRam && 
 40023db:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 40023df:	8b 00                	mov    (%rax),%eax
 40023e1:	83 f8 07             	cmp    $0x7,%eax
 40023e4:	75 62                	jne    4002448 <GlobalMemoryPGlevelMgr_t::pageRecycle(unsigned long)+0x104>
            Ismemspaceneighbors(prevDesc - rootPhyMemDscptTbBsPtr, 
                               desc - rootPhyMemDscptTbBsPtr, 1)) 
 40023e6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 40023ea:	48 8b 00             	mov    (%rax),%rax
 40023ed:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
 40023f1:	48 29 c2             	sub    %rax,%rdx
 40023f4:	48 c1 fa 04          	sar    $0x4,%rdx
 40023f8:	48 b8 ab aa aa aa aa 	movabs $0xaaaaaaaaaaaaaaab,%rax
 40023ff:	aa aa aa 
 4002402:	48 0f af c2          	imul   %rdx,%rax
            Ismemspaceneighbors(prevDesc - rootPhyMemDscptTbBsPtr, 
 4002406:	0f b7 d0             	movzwl %ax,%edx
 4002409:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 400240d:	48 8b 00             	mov    (%rax),%rax
 4002410:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
 4002414:	48 29 c1             	sub    %rax,%rcx
 4002417:	48 c1 f9 04          	sar    $0x4,%rcx
 400241b:	48 b8 ab aa aa aa aa 	movabs $0xaaaaaaaaaaaaaaab,%rax
 4002422:	aa aa aa 
 4002425:	48 0f af c1          	imul   %rcx,%rax
 4002429:	0f b7 f0             	movzwl %ax,%esi
 400242c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4002430:	b9 01 00 00 00       	mov    $0x1,%ecx
 4002435:	48 89 c7             	mov    %rax,%rdi
 4002438:	e8 e7 06 00 00       	call   4002b24 <GlobalMemoryPGlevelMgr_t::Ismemspaceneighbors(unsigned short, unsigned short, unsigned long)>
        if (prevDesc->Type == freeSystemRam && 
 400243d:	84 c0                	test   %al,%al
 400243f:	74 07                	je     4002448 <GlobalMemoryPGlevelMgr_t::pageRecycle(unsigned long)+0x104>
 4002441:	b8 01 00 00 00       	mov    $0x1,%eax
 4002446:	eb 05                	jmp    400244d <GlobalMemoryPGlevelMgr_t::pageRecycle(unsigned long)+0x109>
 4002448:	b8 00 00 00 00       	mov    $0x0,%eax
 400244d:	84 c0                	test   %al,%al
 400244f:	74 35                	je     4002486 <GlobalMemoryPGlevelMgr_t::pageRecycle(unsigned long)+0x142>
        {
              desc->NumberOfPages+=prevDesc->NumberOfPages;
 4002451:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4002455:	48 8b 50 18          	mov    0x18(%rax),%rdx
 4002459:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 400245d:	48 8b 40 18          	mov    0x18(%rax),%rax
 4002461:	48 01 c2             	add    %rax,%rdx
 4002464:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4002468:	48 89 50 18          	mov    %rdx,0x18(%rax)
              desc->PhysicalStart = prevDesc->PhysicalStart;
 400246c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4002470:	48 8b 50 08          	mov    0x8(%rax),%rdx
 4002474:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4002478:	48 89 50 08          	mov    %rdx,0x8(%rax)
            prevDesc->ReservedUnion.TmpChainList.Flags = DIRTY_ENTRY;
 400247c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4002480:	66 c7 40 06 01 00    	movw   $0x1,0x6(%rax)
        }
    }

    // 6. 尝试向后合并（与后一个空闲块）
    if ((desc - rootPhyMemDscptTbBsPtr) < (rootPhymemTbentryCount - 1)) {
 4002486:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 400248a:	48 8b 00             	mov    (%rax),%rax
 400248d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
 4002491:	48 29 c2             	sub    %rax,%rdx
 4002494:	48 c1 fa 04          	sar    $0x4,%rdx
 4002498:	48 b8 ab aa aa aa aa 	movabs $0xaaaaaaaaaaaaaaab,%rax
 400249f:	aa aa aa 
 40024a2:	48 0f af c2          	imul   %rdx,%rax
 40024a6:	48 89 c2             	mov    %rax,%rdx
 40024a9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 40024ad:	48 8b 40 18          	mov    0x18(%rax),%rax
 40024b1:	48 83 e8 01          	sub    $0x1,%rax
 40024b5:	48 39 c2             	cmp    %rax,%rdx
 40024b8:	0f 83 a7 00 00 00    	jae    4002565 <GlobalMemoryPGlevelMgr_t::pageRecycle(unsigned long)+0x221>
        phy_memDesriptor* nextDesc = desc + 1;
 40024be:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 40024c2:	48 83 c0 30          	add    $0x30,%rax
 40024c6:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
        if (nextDesc->Type == freeSystemRam && 
 40024ca:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 40024ce:	8b 00                	mov    (%rax),%eax
 40024d0:	83 f8 07             	cmp    $0x7,%eax
 40024d3:	75 62                	jne    4002537 <GlobalMemoryPGlevelMgr_t::pageRecycle(unsigned long)+0x1f3>
            Ismemspaceneighbors(desc - rootPhyMemDscptTbBsPtr, 
                              nextDesc - rootPhyMemDscptTbBsPtr, 1)) 
 40024d5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 40024d9:	48 8b 00             	mov    (%rax),%rax
 40024dc:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
 40024e0:	48 29 c2             	sub    %rax,%rdx
 40024e3:	48 c1 fa 04          	sar    $0x4,%rdx
 40024e7:	48 b8 ab aa aa aa aa 	movabs $0xaaaaaaaaaaaaaaab,%rax
 40024ee:	aa aa aa 
 40024f1:	48 0f af c2          	imul   %rdx,%rax
            Ismemspaceneighbors(desc - rootPhyMemDscptTbBsPtr, 
 40024f5:	0f b7 d0             	movzwl %ax,%edx
 40024f8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 40024fc:	48 8b 00             	mov    (%rax),%rax
 40024ff:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
 4002503:	48 29 c1             	sub    %rax,%rcx
 4002506:	48 c1 f9 04          	sar    $0x4,%rcx
 400250a:	48 b8 ab aa aa aa aa 	movabs $0xaaaaaaaaaaaaaaab,%rax
 4002511:	aa aa aa 
 4002514:	48 0f af c1          	imul   %rcx,%rax
 4002518:	0f b7 f0             	movzwl %ax,%esi
 400251b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 400251f:	b9 01 00 00 00       	mov    $0x1,%ecx
 4002524:	48 89 c7             	mov    %rax,%rdi
 4002527:	e8 f8 05 00 00       	call   4002b24 <GlobalMemoryPGlevelMgr_t::Ismemspaceneighbors(unsigned short, unsigned short, unsigned long)>
        if (nextDesc->Type == freeSystemRam && 
 400252c:	84 c0                	test   %al,%al
 400252e:	74 07                	je     4002537 <GlobalMemoryPGlevelMgr_t::pageRecycle(unsigned long)+0x1f3>
 4002530:	b8 01 00 00 00       	mov    $0x1,%eax
 4002535:	eb 05                	jmp    400253c <GlobalMemoryPGlevelMgr_t::pageRecycle(unsigned long)+0x1f8>
 4002537:	b8 00 00 00 00       	mov    $0x0,%eax
 400253c:	84 c0                	test   %al,%al
 400253e:	74 25                	je     4002565 <GlobalMemoryPGlevelMgr_t::pageRecycle(unsigned long)+0x221>
        {
            desc->NumberOfPages += nextDesc->NumberOfPages;
 4002540:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4002544:	48 8b 50 18          	mov    0x18(%rax),%rdx
 4002548:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 400254c:	48 8b 40 18          	mov    0x18(%rax),%rax
 4002550:	48 01 c2             	add    %rax,%rdx
 4002553:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4002557:	48 89 50 18          	mov    %rdx,0x18(%rax)
            nextDesc->ReservedUnion.TmpChainList.Flags = DIRTY_ENTRY;
 400255b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 400255f:	66 c7 40 06 01 00    	movw   $0x1,0x6(%rax)
        }
    }

    // 7. 清理脏标记的条目
    dirtyentrydelete(1); // tbid=1 表示操作系统内存描述表
 4002565:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4002569:	be 01 00 00 00       	mov    $0x1,%esi
 400256e:	48 89 c7             	mov    %rax,%rdi
 4002571:	e8 7a e8 ff ff       	call   4000df0 <GlobalMemoryPGlevelMgr_t::dirtyentrydelete(unsigned long)>

    return 0; // 回收成功
 4002576:	b8 00 00 00 00       	mov    $0x0,%eax
}
 400257b:	c9                   	leave
 400257c:	c3                   	ret
 400257d:	90                   	nop

000000000400257e <GlobalMemoryPGlevelMgr_t::pageSetValue(unsigned long, unsigned long)>:

void GlobalMemoryPGlevelMgr_t::pageSetValue(phyaddr_t EntryStartphyaddr, uint64_t value)
{
 400257e:	55                   	push   %rbp
 400257f:	48 89 e5             	mov    %rsp,%rbp
 4002582:	48 83 ec 40          	sub    $0x40,%rsp
 4002586:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
 400258a:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
 400258e:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
    
    phy_memDesriptor* Entry = queryPhysicalMemoryUsage(EntryStartphyaddr);
 4002592:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
 4002596:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 400259a:	48 89 d6             	mov    %rdx,%rsi
 400259d:	48 89 c7             	mov    %rax,%rdi
 40025a0:	e8 7b e7 ff ff       	call   4000d20 <GlobalMemoryPGlevelMgr_t::queryPhysicalMemoryUsage(unsigned long)>
 40025a5:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    if(Entry)
 40025a9:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
 40025ae:	74 4d                	je     40025fd <GlobalMemoryPGlevelMgr_t::pageSetValue(unsigned long, unsigned long)+0x7f>
    {uint64_t* p = (uint64_t*)Entry->PhysicalStart;
 40025b0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 40025b4:	48 8b 40 08          	mov    0x8(%rax),%rax
 40025b8:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
        for (int i = 0; i < Entry->NumberOfPages*512; i++)
 40025bc:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
 40025c3:	eb 1f                	jmp    40025e4 <GlobalMemoryPGlevelMgr_t::pageSetValue(unsigned long, unsigned long)+0x66>
        {
            p[i]=value;
 40025c5:	8b 45 fc             	mov    -0x4(%rbp),%eax
 40025c8:	48 98                	cltq
 40025ca:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
 40025d1:	00 
 40025d2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 40025d6:	48 01 c2             	add    %rax,%rdx
 40025d9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 40025dd:	48 89 02             	mov    %rax,(%rdx)
        for (int i = 0; i < Entry->NumberOfPages*512; i++)
 40025e0:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
 40025e4:	8b 45 fc             	mov    -0x4(%rbp),%eax
 40025e7:	48 63 d0             	movslq %eax,%rdx
 40025ea:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 40025ee:	48 8b 40 18          	mov    0x18(%rax),%rax
 40025f2:	48 c1 e0 09          	shl    $0x9,%rax
 40025f6:	48 39 c2             	cmp    %rax,%rdx
 40025f9:	72 ca                	jb     40025c5 <GlobalMemoryPGlevelMgr_t::pageSetValue(unsigned long, unsigned long)+0x47>
        
    }else{
        kputsSecure("pageSetValue:Entry is null,Invalid EntryStartphyaddr");
    }
    
}
 40025fb:	eb 0f                	jmp    400260c <GlobalMemoryPGlevelMgr_t::pageSetValue(unsigned long, unsigned long)+0x8e>
        kputsSecure("pageSetValue:Entry is null,Invalid EntryStartphyaddr");
 40025fd:	48 8d 05 ac d0 00 00 	lea    0xd0ac(%rip),%rax        # 400f6b0 <PTE::ADDR_MASK+0x8>
 4002604:	48 89 c7             	mov    %rax,%rdi
 4002607:	e8 b9 7b 00 00       	call   400a1c5 <kputsSecure>
}
 400260c:	90                   	nop
 400260d:	c9                   	leave
 400260e:	c3                   	ret

000000000400260f <MemoryTypeToString(unsigned int)>:

const char *MemoryTypeToString(UINT32 type)
{
 400260f:	55                   	push   %rbp
 4002610:	48 89 e5             	mov    %rsp,%rbp
 4002613:	89 7d fc             	mov    %edi,-0x4(%rbp)
    switch (type) {
 4002616:	83 7d fc 13          	cmpl   $0x13,-0x4(%rbp)
 400261a:	0f 84 20 02 00 00    	je     4002840 <MemoryTypeToString(unsigned int)+0x231>
 4002620:	83 7d fc 13          	cmpl   $0x13,-0x4(%rbp)
 4002624:	0f 87 1f 02 00 00    	ja     4002849 <MemoryTypeToString(unsigned int)+0x23a>
 400262a:	83 7d fc 12          	cmpl   $0x12,-0x4(%rbp)
 400262e:	0f 84 03 02 00 00    	je     4002837 <MemoryTypeToString(unsigned int)+0x228>
 4002634:	83 7d fc 12          	cmpl   $0x12,-0x4(%rbp)
 4002638:	0f 87 0b 02 00 00    	ja     4002849 <MemoryTypeToString(unsigned int)+0x23a>
 400263e:	83 7d fc 11          	cmpl   $0x11,-0x4(%rbp)
 4002642:	0f 84 e6 01 00 00    	je     400282e <MemoryTypeToString(unsigned int)+0x21f>
 4002648:	83 7d fc 11          	cmpl   $0x11,-0x4(%rbp)
 400264c:	0f 87 f7 01 00 00    	ja     4002849 <MemoryTypeToString(unsigned int)+0x23a>
 4002652:	83 7d fc 10          	cmpl   $0x10,-0x4(%rbp)
 4002656:	0f 84 c9 01 00 00    	je     4002825 <MemoryTypeToString(unsigned int)+0x216>
 400265c:	83 7d fc 10          	cmpl   $0x10,-0x4(%rbp)
 4002660:	0f 87 e3 01 00 00    	ja     4002849 <MemoryTypeToString(unsigned int)+0x23a>
 4002666:	83 7d fc 0f          	cmpl   $0xf,-0x4(%rbp)
 400266a:	0f 84 ac 01 00 00    	je     400281c <MemoryTypeToString(unsigned int)+0x20d>
 4002670:	83 7d fc 0f          	cmpl   $0xf,-0x4(%rbp)
 4002674:	0f 87 cf 01 00 00    	ja     4002849 <MemoryTypeToString(unsigned int)+0x23a>
 400267a:	83 7d fc 0e          	cmpl   $0xe,-0x4(%rbp)
 400267e:	0f 84 8f 01 00 00    	je     4002813 <MemoryTypeToString(unsigned int)+0x204>
 4002684:	83 7d fc 0e          	cmpl   $0xe,-0x4(%rbp)
 4002688:	0f 87 bb 01 00 00    	ja     4002849 <MemoryTypeToString(unsigned int)+0x23a>
 400268e:	83 7d fc 0d          	cmpl   $0xd,-0x4(%rbp)
 4002692:	0f 84 72 01 00 00    	je     400280a <MemoryTypeToString(unsigned int)+0x1fb>
 4002698:	83 7d fc 0d          	cmpl   $0xd,-0x4(%rbp)
 400269c:	0f 87 a7 01 00 00    	ja     4002849 <MemoryTypeToString(unsigned int)+0x23a>
 40026a2:	83 7d fc 0c          	cmpl   $0xc,-0x4(%rbp)
 40026a6:	0f 84 55 01 00 00    	je     4002801 <MemoryTypeToString(unsigned int)+0x1f2>
 40026ac:	83 7d fc 0c          	cmpl   $0xc,-0x4(%rbp)
 40026b0:	0f 87 93 01 00 00    	ja     4002849 <MemoryTypeToString(unsigned int)+0x23a>
 40026b6:	83 7d fc 0b          	cmpl   $0xb,-0x4(%rbp)
 40026ba:	0f 84 38 01 00 00    	je     40027f8 <MemoryTypeToString(unsigned int)+0x1e9>
 40026c0:	83 7d fc 0b          	cmpl   $0xb,-0x4(%rbp)
 40026c4:	0f 87 7f 01 00 00    	ja     4002849 <MemoryTypeToString(unsigned int)+0x23a>
 40026ca:	83 7d fc 0a          	cmpl   $0xa,-0x4(%rbp)
 40026ce:	0f 84 1b 01 00 00    	je     40027ef <MemoryTypeToString(unsigned int)+0x1e0>
 40026d4:	83 7d fc 0a          	cmpl   $0xa,-0x4(%rbp)
 40026d8:	0f 87 6b 01 00 00    	ja     4002849 <MemoryTypeToString(unsigned int)+0x23a>
 40026de:	83 7d fc 09          	cmpl   $0x9,-0x4(%rbp)
 40026e2:	0f 84 fe 00 00 00    	je     40027e6 <MemoryTypeToString(unsigned int)+0x1d7>
 40026e8:	83 7d fc 09          	cmpl   $0x9,-0x4(%rbp)
 40026ec:	0f 87 57 01 00 00    	ja     4002849 <MemoryTypeToString(unsigned int)+0x23a>
 40026f2:	83 7d fc 08          	cmpl   $0x8,-0x4(%rbp)
 40026f6:	0f 84 e1 00 00 00    	je     40027dd <MemoryTypeToString(unsigned int)+0x1ce>
 40026fc:	83 7d fc 08          	cmpl   $0x8,-0x4(%rbp)
 4002700:	0f 87 43 01 00 00    	ja     4002849 <MemoryTypeToString(unsigned int)+0x23a>
 4002706:	83 7d fc 07          	cmpl   $0x7,-0x4(%rbp)
 400270a:	0f 84 c4 00 00 00    	je     40027d4 <MemoryTypeToString(unsigned int)+0x1c5>
 4002710:	83 7d fc 07          	cmpl   $0x7,-0x4(%rbp)
 4002714:	0f 87 2f 01 00 00    	ja     4002849 <MemoryTypeToString(unsigned int)+0x23a>
 400271a:	83 7d fc 06          	cmpl   $0x6,-0x4(%rbp)
 400271e:	0f 84 a7 00 00 00    	je     40027cb <MemoryTypeToString(unsigned int)+0x1bc>
 4002724:	83 7d fc 06          	cmpl   $0x6,-0x4(%rbp)
 4002728:	0f 87 1b 01 00 00    	ja     4002849 <MemoryTypeToString(unsigned int)+0x23a>
 400272e:	83 7d fc 05          	cmpl   $0x5,-0x4(%rbp)
 4002732:	0f 84 87 00 00 00    	je     40027bf <MemoryTypeToString(unsigned int)+0x1b0>
 4002738:	83 7d fc 05          	cmpl   $0x5,-0x4(%rbp)
 400273c:	0f 87 07 01 00 00    	ja     4002849 <MemoryTypeToString(unsigned int)+0x23a>
 4002742:	83 7d fc 04          	cmpl   $0x4,-0x4(%rbp)
 4002746:	74 6b                	je     40027b3 <MemoryTypeToString(unsigned int)+0x1a4>
 4002748:	83 7d fc 04          	cmpl   $0x4,-0x4(%rbp)
 400274c:	0f 87 f7 00 00 00    	ja     4002849 <MemoryTypeToString(unsigned int)+0x23a>
 4002752:	83 7d fc 03          	cmpl   $0x3,-0x4(%rbp)
 4002756:	74 4f                	je     40027a7 <MemoryTypeToString(unsigned int)+0x198>
 4002758:	83 7d fc 03          	cmpl   $0x3,-0x4(%rbp)
 400275c:	0f 87 e7 00 00 00    	ja     4002849 <MemoryTypeToString(unsigned int)+0x23a>
 4002762:	83 7d fc 02          	cmpl   $0x2,-0x4(%rbp)
 4002766:	74 33                	je     400279b <MemoryTypeToString(unsigned int)+0x18c>
 4002768:	83 7d fc 02          	cmpl   $0x2,-0x4(%rbp)
 400276c:	0f 87 d7 00 00 00    	ja     4002849 <MemoryTypeToString(unsigned int)+0x23a>
 4002772:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
 4002776:	74 0b                	je     4002783 <MemoryTypeToString(unsigned int)+0x174>
 4002778:	83 7d fc 01          	cmpl   $0x1,-0x4(%rbp)
 400277c:	74 11                	je     400278f <MemoryTypeToString(unsigned int)+0x180>
 400277e:	e9 c6 00 00 00       	jmp    4002849 <MemoryTypeToString(unsigned int)+0x23a>
        case 0:  return "Reserved";
 4002783:	48 8d 05 5b cf 00 00 	lea    0xcf5b(%rip),%rax        # 400f6e5 <PTE::ADDR_MASK+0x3d>
 400278a:	e9 c1 00 00 00       	jmp    4002850 <MemoryTypeToString(unsigned int)+0x241>
        case 1:  return "LoaderCode";
 400278f:	48 8d 05 58 cf 00 00 	lea    0xcf58(%rip),%rax        # 400f6ee <PTE::ADDR_MASK+0x46>
 4002796:	e9 b5 00 00 00       	jmp    4002850 <MemoryTypeToString(unsigned int)+0x241>
        case 2:  return "LoaderData";
 400279b:	48 8d 05 57 cf 00 00 	lea    0xcf57(%rip),%rax        # 400f6f9 <PTE::ADDR_MASK+0x51>
 40027a2:	e9 a9 00 00 00       	jmp    4002850 <MemoryTypeToString(unsigned int)+0x241>
        case 3:  return "BootServicesCode";
 40027a7:	48 8d 05 56 cf 00 00 	lea    0xcf56(%rip),%rax        # 400f704 <PTE::ADDR_MASK+0x5c>
 40027ae:	e9 9d 00 00 00       	jmp    4002850 <MemoryTypeToString(unsigned int)+0x241>
        case 4:  return "BootServicesData";
 40027b3:	48 8d 05 5b cf 00 00 	lea    0xcf5b(%rip),%rax        # 400f715 <PTE::ADDR_MASK+0x6d>
 40027ba:	e9 91 00 00 00       	jmp    4002850 <MemoryTypeToString(unsigned int)+0x241>
        case 5:  return "RuntimeServicesCode";
 40027bf:	48 8d 05 60 cf 00 00 	lea    0xcf60(%rip),%rax        # 400f726 <PTE::ADDR_MASK+0x7e>
 40027c6:	e9 85 00 00 00       	jmp    4002850 <MemoryTypeToString(unsigned int)+0x241>
        case 6:  return "RuntimeServicesData";
 40027cb:	48 8d 05 68 cf 00 00 	lea    0xcf68(%rip),%rax        # 400f73a <PTE::ADDR_MASK+0x92>
 40027d2:	eb 7c                	jmp    4002850 <MemoryTypeToString(unsigned int)+0x241>
        case 7:  return "ConventionalMemory";
 40027d4:	48 8d 05 73 cf 00 00 	lea    0xcf73(%rip),%rax        # 400f74e <PTE::ADDR_MASK+0xa6>
 40027db:	eb 73                	jmp    4002850 <MemoryTypeToString(unsigned int)+0x241>
        case 8:  return "UnusableMemory";
 40027dd:	48 8d 05 7d cf 00 00 	lea    0xcf7d(%rip),%rax        # 400f761 <PTE::ADDR_MASK+0xb9>
 40027e4:	eb 6a                	jmp    4002850 <MemoryTypeToString(unsigned int)+0x241>
        case 9:  return "ACPIReclaimMemory";
 40027e6:	48 8d 05 83 cf 00 00 	lea    0xcf83(%rip),%rax        # 400f770 <PTE::ADDR_MASK+0xc8>
 40027ed:	eb 61                	jmp    4002850 <MemoryTypeToString(unsigned int)+0x241>
        case 10: return "ACPIMemoryNVS";
 40027ef:	48 8d 05 8c cf 00 00 	lea    0xcf8c(%rip),%rax        # 400f782 <PTE::ADDR_MASK+0xda>
 40027f6:	eb 58                	jmp    4002850 <MemoryTypeToString(unsigned int)+0x241>
        case 11: return "MemoryMappedIO";
 40027f8:	48 8d 05 91 cf 00 00 	lea    0xcf91(%rip),%rax        # 400f790 <PTE::ADDR_MASK+0xe8>
 40027ff:	eb 4f                	jmp    4002850 <MemoryTypeToString(unsigned int)+0x241>
        case 12: return "MemoryMappedIOPortSpace";
 4002801:	48 8d 05 97 cf 00 00 	lea    0xcf97(%rip),%rax        # 400f79f <PTE::ADDR_MASK+0xf7>
 4002808:	eb 46                	jmp    4002850 <MemoryTypeToString(unsigned int)+0x241>
        case 13: return "PalCode";
 400280a:	48 8d 05 a6 cf 00 00 	lea    0xcfa6(%rip),%rax        # 400f7b7 <PTE::ADDR_MASK+0x10f>
 4002811:	eb 3d                	jmp    4002850 <MemoryTypeToString(unsigned int)+0x241>
        case 14: return "PERSISTENT_MEMORY";
 4002813:	48 8d 05 a5 cf 00 00 	lea    0xcfa5(%rip),%rax        # 400f7bf <PTE::ADDR_MASK+0x117>
 400281a:	eb 34                	jmp    4002850 <MemoryTypeToString(unsigned int)+0x241>
        case 15: return "EFI_UNACCEPTED_MEMORY_TYPE";
 400281c:	48 8d 05 ae cf 00 00 	lea    0xcfae(%rip),%rax        # 400f7d1 <PTE::ADDR_MASK+0x129>
 4002823:	eb 2b                	jmp    4002850 <MemoryTypeToString(unsigned int)+0x241>
        case 16: return "EFI_MAX_MEMORY_TYPE";
 4002825:	48 8d 05 c0 cf 00 00 	lea    0xcfc0(%rip),%rax        # 400f7ec <PTE::ADDR_MASK+0x144>
 400282c:	eb 22                	jmp    4002850 <MemoryTypeToString(unsigned int)+0x241>
        case 17: return "OS_KERNEL_DATA";
 400282e:	48 8d 05 cb cf 00 00 	lea    0xcfcb(%rip),%rax        # 400f800 <PTE::ADDR_MASK+0x158>
 4002835:	eb 19                	jmp    4002850 <MemoryTypeToString(unsigned int)+0x241>
        case 18: return "OS_KERNEL_CODE";
 4002837:	48 8d 05 d1 cf 00 00 	lea    0xcfd1(%rip),%rax        # 400f80f <PTE::ADDR_MASK+0x167>
 400283e:	eb 10                	jmp    4002850 <MemoryTypeToString(unsigned int)+0x241>
        case 19: return "OS_KERNEL_STACK";
 4002840:	48 8d 05 d7 cf 00 00 	lea    0xcfd7(%rip),%rax        # 400f81e <PTE::ADDR_MASK+0x176>
 4002847:	eb 07                	jmp    4002850 <MemoryTypeToString(unsigned int)+0x241>

        default: return "UnknownType";
 4002849:	48 8d 05 de cf 00 00 	lea    0xcfde(%rip),%rax        # 400f82e <PTE::ADDR_MASK+0x186>
    }
}
 4002850:	5d                   	pop    %rbp
 4002851:	c3                   	ret

0000000004002852 <PrintMemoryDescriptor(EFI_MEMORY_DESCRIPTORX64 const*)>:

// 打印单个内存描述符
void PrintMemoryDescriptor(const EFI_MEMORY_DESCRIPTORX64* desc) {
 4002852:	55                   	push   %rbp
 4002853:	48 89 e5             	mov    %rsp,%rbp
 4002856:	48 83 ec 20          	sub    $0x20,%rsp
 400285a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    if(desc->ReservedUnion.TmpChainList.Flags==DIRTY_ENTRY)return;
 400285e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4002862:	0f b7 40 06          	movzwl 0x6(%rax),%eax
 4002866:	66 83 f8 01          	cmp    $0x1,%ax
 400286a:	0f 84 f0 00 00 00    	je     4002960 <PrintMemoryDescriptor(EFI_MEMORY_DESCRIPTORX64 const*)+0x10e>
    // 1. 打印起始物理地址
    kputsSecure("Start: 0x");
 4002870:	48 8d 05 c3 cf 00 00 	lea    0xcfc3(%rip),%rax        # 400f83a <PTE::ADDR_MASK+0x192>
 4002877:	48 89 c7             	mov    %rax,%rdi
 400287a:	e8 46 79 00 00       	call   400a1c5 <kputsSecure>
    kpnumSecure((void*)&desc->PhysicalStart, UNHEX, sizeof(EFI_PHYSICAL_ADDRESS));
 400287f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4002883:	48 83 c0 08          	add    $0x8,%rax
 4002887:	ba 08 00 00 00       	mov    $0x8,%edx
 400288c:	be 05 00 00 00       	mov    $0x5,%esi
 4002891:	48 89 c7             	mov    %rax,%rdi
 4002894:	e8 6d 7a 00 00       	call   400a306 <kpnumSecure>
    
    // 2. 计算并打印终止物理地址
    UINT64 endAddress = desc->PhysicalStart + (desc->NumberOfPages * EFI_PAGE_SIZE);
 4002899:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 400289d:	48 8b 50 08          	mov    0x8(%rax),%rdx
 40028a1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 40028a5:	48 8b 40 18          	mov    0x18(%rax),%rax
 40028a9:	48 c1 e0 0c          	shl    $0xc,%rax
 40028ad:	48 01 d0             	add    %rdx,%rax
 40028b0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    kputsSecure(" - End: 0x");
 40028b4:	48 8d 05 89 cf 00 00 	lea    0xcf89(%rip),%rax        # 400f844 <PTE::ADDR_MASK+0x19c>
 40028bb:	48 89 c7             	mov    %rax,%rdi
 40028be:	e8 02 79 00 00       	call   400a1c5 <kputsSecure>
    kpnumSecure((void*)&endAddress, UNHEX, sizeof(UINT64));
 40028c3:	48 8d 45 f8          	lea    -0x8(%rbp),%rax
 40028c7:	ba 08 00 00 00       	mov    $0x8,%edx
 40028cc:	be 05 00 00 00       	mov    $0x5,%esi
 40028d1:	48 89 c7             	mov    %rax,%rdi
 40028d4:	e8 2d 7a 00 00       	call   400a306 <kpnumSecure>
    
    // 3. 打印内存类型和属性
    kputsSecure(" Type: ");
 40028d9:	48 8d 05 6f cf 00 00 	lea    0xcf6f(%rip),%rax        # 400f84f <PTE::ADDR_MASK+0x1a7>
 40028e0:	48 89 c7             	mov    %rax,%rdi
 40028e3:	e8 dd 78 00 00       	call   400a1c5 <kputsSecure>
    kputsSecure((char*)MemoryTypeToString(desc->Type));
 40028e8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 40028ec:	8b 00                	mov    (%rax),%eax
 40028ee:	89 c7                	mov    %eax,%edi
 40028f0:	e8 1a fd ff ff       	call   400260f <MemoryTypeToString(unsigned int)>
 40028f5:	48 89 c7             	mov    %rax,%rdi
 40028f8:	e8 c8 78 00 00       	call   400a1c5 <kputsSecure>
    
    kputsSecure(" Attr: 0x");
 40028fd:	48 8d 05 53 cf 00 00 	lea    0xcf53(%rip),%rax        # 400f857 <PTE::ADDR_MASK+0x1af>
 4002904:	48 89 c7             	mov    %rax,%rdi
 4002907:	e8 b9 78 00 00       	call   400a1c5 <kputsSecure>
    kpnumSecure((void*)&desc->Attribute, UNHEX, sizeof(UINT64));
 400290c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4002910:	48 83 c0 20          	add    $0x20,%rax
 4002914:	ba 08 00 00 00       	mov    $0x8,%edx
 4002919:	be 05 00 00 00       	mov    $0x5,%esi
 400291e:	48 89 c7             	mov    %rax,%rdi
 4002921:	e8 e0 79 00 00       	call   400a306 <kpnumSecure>
    
    // 4. 打印页数（可选）
    kputsSecure(" Pages: ");
 4002926:	48 8d 05 34 cf 00 00 	lea    0xcf34(%rip),%rax        # 400f861 <PTE::ADDR_MASK+0x1b9>
 400292d:	48 89 c7             	mov    %rax,%rdi
 4002930:	e8 90 78 00 00       	call   400a1c5 <kputsSecure>
    kpnumSecure((void*)&desc->NumberOfPages, UNDEC, sizeof(UINT64));
 4002935:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4002939:	48 83 c0 18          	add    $0x18,%rax
 400293d:	ba 08 00 00 00       	mov    $0x8,%edx
 4002942:	be 03 00 00 00       	mov    $0x3,%esi
 4002947:	48 89 c7             	mov    %rax,%rdi
 400294a:	e8 b7 79 00 00       	call   400a306 <kpnumSecure>
    
    // 换行
    kputsSecure("\n");
 400294f:	48 8d 05 14 cf 00 00 	lea    0xcf14(%rip),%rax        # 400f86a <PTE::ADDR_MASK+0x1c2>
 4002956:	48 89 c7             	mov    %rax,%rdi
 4002959:	e8 67 78 00 00       	call   400a1c5 <kputsSecure>
 400295e:	eb 01                	jmp    4002961 <PrintMemoryDescriptor(EFI_MEMORY_DESCRIPTORX64 const*)+0x10f>
    if(desc->ReservedUnion.TmpChainList.Flags==DIRTY_ENTRY)return;
 4002960:	90                   	nop
}
 4002961:	c9                   	leave
 4002962:	c3                   	ret
 4002963:	90                   	nop

0000000004002964 <GlobalMemoryPGlevelMgr_t::getMaxPhyaddr()>:
phyaddr_t GlobalMemoryPGlevelMgr_t::getMaxPhyaddr()
{
 4002964:	55                   	push   %rbp
 4002965:	48 89 e5             	mov    %rsp,%rbp
 4002968:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    return max_phy_addr;
 400296c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4002970:	48 8b 40 28          	mov    0x28(%rax),%rax
}
 4002974:	5d                   	pop    %rbp
 4002975:	c3                   	ret

0000000004002976 <GlobalMemoryPGlevelMgr_t::printEfiMemoryDescriptorTable()>:
void GlobalMemoryPGlevelMgr_t::printEfiMemoryDescriptorTable()
{
 4002976:	55                   	push   %rbp
 4002977:	48 89 e5             	mov    %rsp,%rbp
 400297a:	48 83 ec 20          	sub    $0x20,%rsp
 400297e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
        kputsSecure("\n========== Memory Map ==========\n");
 4002982:	48 8d 05 e7 ce 00 00 	lea    0xcee7(%rip),%rax        # 400f870 <PTE::ADDR_MASK+0x1c8>
 4002989:	48 89 c7             	mov    %rax,%rdi
 400298c:	e8 34 78 00 00       	call   400a1c5 <kputsSecure>
    
    // 打印表头
    kputsSecure("Physical Range             Type               Attribute    Pages\n");
 4002991:	48 8d 05 00 cf 00 00 	lea    0xcf00(%rip),%rax        # 400f898 <PTE::ADDR_MASK+0x1f0>
 4002998:	48 89 c7             	mov    %rax,%rdi
 400299b:	e8 25 78 00 00       	call   400a1c5 <kputsSecure>
    kputsSecure("-----------------------------------------------------------------\n");
 40029a0:	48 8d 05 39 cf 00 00 	lea    0xcf39(%rip),%rax        # 400f8e0 <PTE::ADDR_MASK+0x238>
 40029a7:	48 89 c7             	mov    %rax,%rdi
 40029aa:	e8 16 78 00 00       	call   400a1c5 <kputsSecure>
    
    // 遍历所有条目
    for (UINTN i = 0; i < EfiMemMapEntryCount; i++) {
 40029af:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
 40029b6:	00 
 40029b7:	eb 55                	jmp    4002a0e <GlobalMemoryPGlevelMgr_t::printEfiMemoryDescriptorTable()+0x98>
        kpnumSecure((void*)&i, UNDEC, sizeof(UINTN));
 40029b9:	48 8d 45 f8          	lea    -0x8(%rbp),%rax
 40029bd:	ba 08 00 00 00       	mov    $0x8,%edx
 40029c2:	be 03 00 00 00       	mov    $0x3,%esi
 40029c7:	48 89 c7             	mov    %rax,%rdi
 40029ca:	e8 37 79 00 00       	call   400a306 <kpnumSecure>
        kputsSecure(": ");
 40029cf:	48 8d 05 4d cf 00 00 	lea    0xcf4d(%rip),%rax        # 400f923 <PTE::ADDR_MASK+0x27b>
 40029d6:	48 89 c7             	mov    %rax,%rdi
 40029d9:	e8 e7 77 00 00       	call   400a1c5 <kputsSecure>
        PrintMemoryDescriptor(EfiMemMap+i);
 40029de:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 40029e2:	48 8b 48 08          	mov    0x8(%rax),%rcx
 40029e6:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
 40029ea:	48 89 d0             	mov    %rdx,%rax
 40029ed:	48 01 c0             	add    %rax,%rax
 40029f0:	48 01 d0             	add    %rdx,%rax
 40029f3:	48 c1 e0 04          	shl    $0x4,%rax
 40029f7:	48 01 c8             	add    %rcx,%rax
 40029fa:	48 89 c7             	mov    %rax,%rdi
 40029fd:	e8 50 fe ff ff       	call   4002852 <PrintMemoryDescriptor(EFI_MEMORY_DESCRIPTORX64 const*)>
    for (UINTN i = 0; i < EfiMemMapEntryCount; i++) {
 4002a02:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4002a06:	48 83 c0 01          	add    $0x1,%rax
 4002a0a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
 4002a0e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4002a12:	48 8b 40 10          	mov    0x10(%rax),%rax
 4002a16:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
 4002a1a:	48 39 c2             	cmp    %rax,%rdx
 4002a1d:	72 9a                	jb     40029b9 <GlobalMemoryPGlevelMgr_t::printEfiMemoryDescriptorTable()+0x43>
    }
    
    kputsSecure("========== End of Map ==========\n");
 4002a1f:	48 8d 05 02 cf 00 00 	lea    0xcf02(%rip),%rax        # 400f928 <PTE::ADDR_MASK+0x280>
 4002a26:	48 89 c7             	mov    %rax,%rdi
 4002a29:	e8 97 77 00 00       	call   400a1c5 <kputsSecure>
}
 4002a2e:	90                   	nop
 4002a2f:	c9                   	leave
 4002a30:	c3                   	ret
 4002a31:	90                   	nop

0000000004002a32 <GlobalMemoryPGlevelMgr_t::printPhyMemDesTb()>:

void GlobalMemoryPGlevelMgr_t::printPhyMemDesTb()
{
 4002a32:	55                   	push   %rbp
 4002a33:	48 89 e5             	mov    %rsp,%rbp
 4002a36:	48 83 ec 20          	sub    $0x20,%rsp
 4002a3a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
       kputsSecure("\n========== Phy Memory Map ==========\n");
 4002a3e:	48 8d 05 0b cf 00 00 	lea    0xcf0b(%rip),%rax        # 400f950 <PTE::ADDR_MASK+0x2a8>
 4002a45:	48 89 c7             	mov    %rax,%rdi
 4002a48:	e8 78 77 00 00       	call   400a1c5 <kputsSecure>
    
    // 打印表头
    kputsSecure("Physical Range             Type               Attribute    Pages\n");
 4002a4d:	48 8d 05 44 ce 00 00 	lea    0xce44(%rip),%rax        # 400f898 <PTE::ADDR_MASK+0x1f0>
 4002a54:	48 89 c7             	mov    %rax,%rdi
 4002a57:	e8 69 77 00 00       	call   400a1c5 <kputsSecure>
    kputsSecure("-----------------------------------------------------------------\n");
 4002a5c:	48 8d 05 7d ce 00 00 	lea    0xce7d(%rip),%rax        # 400f8e0 <PTE::ADDR_MASK+0x238>
 4002a63:	48 89 c7             	mov    %rax,%rdi
 4002a66:	e8 5a 77 00 00       	call   400a1c5 <kputsSecure>
    
    // 遍历所有条目
    for (UINTN i = 0; i < rootPhymemTbentryCount; i++) {
 4002a6b:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
 4002a72:	00 
 4002a73:	eb 54                	jmp    4002ac9 <GlobalMemoryPGlevelMgr_t::printPhyMemDesTb()+0x97>
        kpnumSecure((void*)&i, UNDEC, sizeof(UINTN));
 4002a75:	48 8d 45 f8          	lea    -0x8(%rbp),%rax
 4002a79:	ba 08 00 00 00       	mov    $0x8,%edx
 4002a7e:	be 03 00 00 00       	mov    $0x3,%esi
 4002a83:	48 89 c7             	mov    %rax,%rdi
 4002a86:	e8 7b 78 00 00       	call   400a306 <kpnumSecure>
        kputsSecure(": ");
 4002a8b:	48 8d 05 91 ce 00 00 	lea    0xce91(%rip),%rax        # 400f923 <PTE::ADDR_MASK+0x27b>
 4002a92:	48 89 c7             	mov    %rax,%rdi
 4002a95:	e8 2b 77 00 00       	call   400a1c5 <kputsSecure>
        PrintMemoryDescriptor((EFI_MEMORY_DESCRIPTORX64*)(rootPhyMemDscptTbBsPtr+i));
 4002a9a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4002a9e:	48 8b 08             	mov    (%rax),%rcx
 4002aa1:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
 4002aa5:	48 89 d0             	mov    %rdx,%rax
 4002aa8:	48 01 c0             	add    %rax,%rax
 4002aab:	48 01 d0             	add    %rdx,%rax
 4002aae:	48 c1 e0 04          	shl    $0x4,%rax
 4002ab2:	48 01 c8             	add    %rcx,%rax
 4002ab5:	48 89 c7             	mov    %rax,%rdi
 4002ab8:	e8 95 fd ff ff       	call   4002852 <PrintMemoryDescriptor(EFI_MEMORY_DESCRIPTORX64 const*)>
    for (UINTN i = 0; i < rootPhymemTbentryCount; i++) {
 4002abd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4002ac1:	48 83 c0 01          	add    $0x1,%rax
 4002ac5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
 4002ac9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4002acd:	48 8b 40 18          	mov    0x18(%rax),%rax
 4002ad1:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
 4002ad5:	48 39 c2             	cmp    %rax,%rdx
 4002ad8:	72 9b                	jb     4002a75 <GlobalMemoryPGlevelMgr_t::printPhyMemDesTb()+0x43>
    }
    
    kputsSecure("========== End of Map ==========\n");
 4002ada:	48 8d 05 47 ce 00 00 	lea    0xce47(%rip),%rax        # 400f928 <PTE::ADDR_MASK+0x280>
 4002ae1:	48 89 c7             	mov    %rax,%rdi
 4002ae4:	e8 dc 76 00 00       	call   400a1c5 <kputsSecure>
}
 4002ae9:	90                   	nop
 4002aea:	c9                   	leave
 4002aeb:	c3                   	ret

0000000004002aec <GlobalMemoryPGlevelMgr_t::DisableBasicMemService()>:

void GlobalMemoryPGlevelMgr_t::DisableBasicMemService()
{
 4002aec:	55                   	push   %rbp
 4002aed:	48 89 e5             	mov    %rsp,%rbp
 4002af0:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    Statusflags=0;
 4002af4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4002af8:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
 4002aff:	00 
}
 4002b00:	90                   	nop
 4002b01:	5d                   	pop    %rbp
 4002b02:	c3                   	ret

0000000004002b03 <__static_initialization_and_destruction_0()>:
 4002b03:	55                   	push   %rbp
 4002b04:	48 89 e5             	mov    %rsp,%rbp
GlobalMemoryPGlevelMgr_t gBaseMemMgr;
 4002b07:	48 8d 05 32 d5 7f 00 	lea    0x7fd532(%rip),%rax        # 4800040 <gBaseMemMgr>
 4002b0e:	48 89 c7             	mov    %rax,%rdi
 4002b11:	e8 20 e0 ff ff       	call   4000b36 <GlobalMemoryPGlevelMgr_t::GlobalMemoryPGlevelMgr_t()>
}
 4002b16:	90                   	nop
 4002b17:	5d                   	pop    %rbp
 4002b18:	c3                   	ret

0000000004002b19 <_GLOBAL__sub_I_gBaseMemMgr>:
 4002b19:	55                   	push   %rbp
 4002b1a:	48 89 e5             	mov    %rsp,%rbp
 4002b1d:	e8 e1 ff ff ff       	call   4002b03 <__static_initialization_and_destruction_0()>
 4002b22:	5d                   	pop    %rbp
 4002b23:	c3                   	ret

0000000004002b24 <GlobalMemoryPGlevelMgr_t::Ismemspaceneighbors(unsigned short, unsigned short, unsigned long)>:
{
 4002b24:	55                   	push   %rbp
 4002b25:	48 89 e5             	mov    %rsp,%rbp
 4002b28:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
 4002b2c:	89 d0                	mov    %edx,%eax
 4002b2e:	48 89 4d e8          	mov    %rcx,-0x18(%rbp)
 4002b32:	89 f2                	mov    %esi,%edx
 4002b34:	66 89 55 f4          	mov    %dx,-0xc(%rbp)
 4002b38:	66 89 45 f0          	mov    %ax,-0x10(%rbp)
    switch (tbid)
 4002b3c:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
 4002b41:	74 0a                	je     4002b4d <GlobalMemoryPGlevelMgr_t::Ismemspaceneighbors(unsigned short, unsigned short, unsigned long)+0x29>
 4002b43:	48 83 7d e8 01       	cmpq   $0x1,-0x18(%rbp)
 4002b48:	74 7e                	je     4002bc8 <GlobalMemoryPGlevelMgr_t::Ismemspaceneighbors(unsigned short, unsigned short, unsigned long)+0xa4>
        break;
 4002b4a:	90                   	nop
 4002b4b:	0f 0b                	ud2
        if(EfiMemMap[index_a].PhysicalStart + 4096*EfiMemMap[index_a].NumberOfPages == EfiMemMap[index_b].PhysicalStart)
 4002b4d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4002b51:	48 8b 48 08          	mov    0x8(%rax),%rcx
 4002b55:	0f b7 55 f4          	movzwl -0xc(%rbp),%edx
 4002b59:	48 89 d0             	mov    %rdx,%rax
 4002b5c:	48 01 c0             	add    %rax,%rax
 4002b5f:	48 01 d0             	add    %rdx,%rax
 4002b62:	48 c1 e0 04          	shl    $0x4,%rax
 4002b66:	48 01 c8             	add    %rcx,%rax
 4002b69:	48 8b 48 08          	mov    0x8(%rax),%rcx
 4002b6d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4002b71:	48 8b 70 08          	mov    0x8(%rax),%rsi
 4002b75:	0f b7 55 f4          	movzwl -0xc(%rbp),%edx
 4002b79:	48 89 d0             	mov    %rdx,%rax
 4002b7c:	48 01 c0             	add    %rax,%rax
 4002b7f:	48 01 d0             	add    %rdx,%rax
 4002b82:	48 c1 e0 04          	shl    $0x4,%rax
 4002b86:	48 01 f0             	add    %rsi,%rax
 4002b89:	48 8b 40 18          	mov    0x18(%rax),%rax
 4002b8d:	48 c1 e0 0c          	shl    $0xc,%rax
 4002b91:	48 8d 34 01          	lea    (%rcx,%rax,1),%rsi
 4002b95:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4002b99:	48 8b 48 08          	mov    0x8(%rax),%rcx
 4002b9d:	0f b7 55 f0          	movzwl -0x10(%rbp),%edx
 4002ba1:	48 89 d0             	mov    %rdx,%rax
 4002ba4:	48 01 c0             	add    %rax,%rax
 4002ba7:	48 01 d0             	add    %rdx,%rax
 4002baa:	48 c1 e0 04          	shl    $0x4,%rax
 4002bae:	48 01 c8             	add    %rcx,%rax
 4002bb1:	48 8b 40 08          	mov    0x8(%rax),%rax
 4002bb5:	48 39 c6             	cmp    %rax,%rsi
 4002bb8:	75 07                	jne    4002bc1 <GlobalMemoryPGlevelMgr_t::Ismemspaceneighbors(unsigned short, unsigned short, unsigned long)+0x9d>
        return true;
 4002bba:	b8 01 00 00 00       	mov    $0x1,%eax
 4002bbf:	eb 7d                	jmp    4002c3e <GlobalMemoryPGlevelMgr_t::Ismemspaceneighbors(unsigned short, unsigned short, unsigned long)+0x11a>
        else return false;
 4002bc1:	b8 00 00 00 00       	mov    $0x0,%eax
 4002bc6:	eb 76                	jmp    4002c3e <GlobalMemoryPGlevelMgr_t::Ismemspaceneighbors(unsigned short, unsigned short, unsigned long)+0x11a>
        if (rootPhyMemDscptTbBsPtr[index_a].PhysicalStart+
 4002bc8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4002bcc:	48 8b 08             	mov    (%rax),%rcx
 4002bcf:	0f b7 55 f4          	movzwl -0xc(%rbp),%edx
 4002bd3:	48 89 d0             	mov    %rdx,%rax
 4002bd6:	48 01 c0             	add    %rax,%rax
 4002bd9:	48 01 d0             	add    %rdx,%rax
 4002bdc:	48 c1 e0 04          	shl    $0x4,%rax
 4002be0:	48 01 c8             	add    %rcx,%rax
 4002be3:	48 8b 48 08          	mov    0x8(%rax),%rcx
        4096*rootPhyMemDscptTbBsPtr[index_a].NumberOfPages == 
 4002be7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4002beb:	48 8b 30             	mov    (%rax),%rsi
 4002bee:	0f b7 55 f4          	movzwl -0xc(%rbp),%edx
 4002bf2:	48 89 d0             	mov    %rdx,%rax
 4002bf5:	48 01 c0             	add    %rax,%rax
 4002bf8:	48 01 d0             	add    %rdx,%rax
 4002bfb:	48 c1 e0 04          	shl    $0x4,%rax
 4002bff:	48 01 f0             	add    %rsi,%rax
 4002c02:	48 8b 40 18          	mov    0x18(%rax),%rax
 4002c06:	48 c1 e0 0c          	shl    $0xc,%rax
        if (rootPhyMemDscptTbBsPtr[index_a].PhysicalStart+
 4002c0a:	48 8d 34 01          	lea    (%rcx,%rax,1),%rsi
        rootPhyMemDscptTbBsPtr[index_b].PhysicalStart)
 4002c0e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4002c12:	48 8b 08             	mov    (%rax),%rcx
 4002c15:	0f b7 55 f0          	movzwl -0x10(%rbp),%edx
 4002c19:	48 89 d0             	mov    %rdx,%rax
 4002c1c:	48 01 c0             	add    %rax,%rax
 4002c1f:	48 01 d0             	add    %rdx,%rax
 4002c22:	48 c1 e0 04          	shl    $0x4,%rax
 4002c26:	48 01 c8             	add    %rcx,%rax
 4002c29:	48 8b 40 08          	mov    0x8(%rax),%rax
        if (rootPhyMemDscptTbBsPtr[index_a].PhysicalStart+
 4002c2d:	48 39 c6             	cmp    %rax,%rsi
 4002c30:	75 07                	jne    4002c39 <GlobalMemoryPGlevelMgr_t::Ismemspaceneighbors(unsigned short, unsigned short, unsigned long)+0x115>
            return true;
 4002c32:	b8 01 00 00 00       	mov    $0x1,%eax
 4002c37:	eb 05                	jmp    4002c3e <GlobalMemoryPGlevelMgr_t::Ismemspaceneighbors(unsigned short, unsigned short, unsigned long)+0x11a>
        }else return false;
 4002c39:	b8 00 00 00 00       	mov    $0x0,%eax
}/**
 4002c3e:	5d                   	pop    %rbp
 4002c3f:	c3                   	ret

0000000004002c40 <offset_to_phys_addr(HCB_chainlist_node*, unsigned int)>:
    }
    return result;
}

// 辅助函数：根据偏移量计算物理地址
static inline uint8_t* offset_to_phys_addr(HCB_chainlist_node* node, uint32_t offset) {
 4002c40:	55                   	push   %rbp
 4002c41:	48 89 e5             	mov    %rsp,%rbp
 4002c44:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
 4002c48:	89 75 f4             	mov    %esi,-0xc(%rbp)
    return (uint8_t*)node->heap.heapStart + offset;
 4002c4b:	8b 55 f4             	mov    -0xc(%rbp),%edx
 4002c4e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4002c52:	48 8b 00             	mov    (%rax),%rax
 4002c55:	48 01 d0             	add    %rdx,%rax
}
 4002c58:	5d                   	pop    %rbp
 4002c59:	c3                   	ret

0000000004002c5a <offset_to_virt_addr(HCB_chainlist_node*, unsigned int)>:

// 辅助函数：根据偏移量计算虚拟地址
static inline uint8_t* offset_to_virt_addr(HCB_chainlist_node* node, uint32_t offset) {
 4002c5a:	55                   	push   %rbp
 4002c5b:	48 89 e5             	mov    %rsp,%rbp
 4002c5e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
 4002c62:	89 75 f4             	mov    %esi,-0xc(%rbp)
    return (uint8_t*)node->heap.heapVStart + offset;
 4002c65:	8b 55 f4             	mov    -0xc(%rbp),%edx
 4002c68:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4002c6c:	48 8b 40 08          	mov    0x8(%rax),%rax
 4002c70:	48 01 d0             	add    %rdx,%rax
}
 4002c73:	5d                   	pop    %rbp
 4002c74:	c3                   	ret

0000000004002c75 <phys_addr_to_offset(HCB_chainlist_node*, unsigned char*)>:

// 辅助函数：根据物理地址计算偏移量
static inline uint32_t phys_addr_to_offset(HCB_chainlist_node* node, uint8_t* addr) {
 4002c75:	55                   	push   %rbp
 4002c76:	48 89 e5             	mov    %rsp,%rbp
 4002c79:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
 4002c7d:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
    return (uint32_t)(addr - (uint8_t*)node->heap.heapStart);
 4002c81:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4002c85:	48 8b 00             	mov    (%rax),%rax
 4002c88:	48 89 c2             	mov    %rax,%rdx
 4002c8b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 4002c8f:	48 29 d0             	sub    %rdx,%rax
}
 4002c92:	5d                   	pop    %rbp
 4002c93:	c3                   	ret

0000000004002c94 <virt_addr_to_offset(HCB_chainlist_node*, unsigned char*)>:

// 辅助函数：根据虚拟地址计算偏移量
static inline uint32_t virt_addr_to_offset(HCB_chainlist_node* node, uint8_t* addr) {
 4002c94:	55                   	push   %rbp
 4002c95:	48 89 e5             	mov    %rsp,%rbp
 4002c98:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
 4002c9c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
    return (uint32_t)(addr - (uint8_t*)node->heap.heapVStart);
 4002ca0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4002ca4:	48 8b 40 08          	mov    0x8(%rax),%rax
 4002ca8:	48 89 c2             	mov    %rax,%rdx
 4002cab:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 4002caf:	48 29 d0             	sub    %rdx,%rax
}
 4002cb2:	5d                   	pop    %rbp
 4002cb3:	c3                   	ret

0000000004002cb4 <kpoolmemmgr_t::addr_to_HCB_MetaInfotb_Index(HCB_chainlist_node, unsigned char*)>:
 * 使用二分查找在元信息表中查找地址对应的对象索引
 * 如果地址在某个对象内，返回该对象的索引
 * 如果地址在堆空洞中，返回-1
 * 如果地址不在堆范围内，返回INDEX_NOT_EXIST (-100)
 */
int kpoolmemmgr_t::addr_to_HCB_MetaInfotb_Index(HCB_chainlist_node HNode, uint8_t* addr) {
 4002cb4:	55                   	push   %rbp
 4002cb5:	48 89 e5             	mov    %rsp,%rbp
 4002cb8:	48 83 ec 50          	sub    $0x50,%rsp
 4002cbc:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
 4002cc0:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
    HeapMetaInfoArray* metaInfo = &HNode.heap.metaInfo;
 4002cc4:	48 8d 45 30          	lea    0x30(%rbp),%rax
 4002cc8:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    uint32_t objCount = metaInfo->header.objMetaCount;
 4002ccc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 4002cd0:	48 8b 40 08          	mov    0x8(%rax),%rax
 4002cd4:	89 45 ec             	mov    %eax,-0x14(%rbp)
    HeapObjectMetav2* metaTable = metaInfo->objMetaTable;
 4002cd7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 4002cdb:	48 8b 40 18          	mov    0x18(%rax),%rax
 4002cdf:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    
    // 检查地址是否在堆范围内
    uint8_t* heapStart = (uint8_t*)HNode.heap.heapStart;
 4002ce3:	48 8b 45 10          	mov    0x10(%rbp),%rax
 4002ce7:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    uint8_t* heapEnd = heapStart + HNode.heap.heapSize;
 4002ceb:	48 8b 55 20          	mov    0x20(%rbp),%rdx
 4002cef:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4002cf3:	48 01 d0             	add    %rdx,%rax
 4002cf6:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    
    if (addr < heapStart || addr >= heapEnd) {
 4002cfa:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
 4002cfe:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
 4002d02:	72 0a                	jb     4002d0e <kpoolmemmgr_t::addr_to_HCB_MetaInfotb_Index(HCB_chainlist_node, unsigned char*)+0x5a>
 4002d04:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
 4002d08:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
 4002d0c:	72 0a                	jb     4002d18 <kpoolmemmgr_t::addr_to_HCB_MetaInfotb_Index(HCB_chainlist_node, unsigned char*)+0x64>
        return OS_OUT_OF_RANGE; // 地址不在堆范围内
 4002d0e:	b8 10 10 00 00       	mov    $0x1010,%eax
 4002d13:	e9 dd 00 00 00       	jmp    4002df5 <kpoolmemmgr_t::addr_to_HCB_MetaInfotb_Index(HCB_chainlist_node, unsigned char*)+0x141>
    }
    
    // 如果元数据表为空，地址在堆空洞中
    if (objCount == 0) {
 4002d18:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
 4002d1c:	75 0a                	jne    4002d28 <kpoolmemmgr_t::addr_to_HCB_MetaInfotb_Index(HCB_chainlist_node, unsigned char*)+0x74>
        return OS_NOT_EXIST;
 4002d1e:	b8 11 10 00 00       	mov    $0x1011,%eax
 4002d23:	e9 cd 00 00 00       	jmp    4002df5 <kpoolmemmgr_t::addr_to_HCB_MetaInfotb_Index(HCB_chainlist_node, unsigned char*)+0x141>
    }
    
    // 计算地址在堆中的偏移量
    uint32_t offset = phys_addr_to_offset(&HNode, addr);
 4002d28:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
 4002d2c:	48 89 c6             	mov    %rax,%rsi
 4002d2f:	48 8d 7d 10          	lea    0x10(%rbp),%rdi
 4002d33:	e8 3d ff ff ff       	call   4002c75 <phys_addr_to_offset(HCB_chainlist_node*, unsigned char*)>
 4002d38:	89 45 cc             	mov    %eax,-0x34(%rbp)
    
    // 使用二分查找找到地址所在的对象
    int32_t left = 0;
 4002d3b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
    int32_t right = objCount - 1;
 4002d42:	8b 45 ec             	mov    -0x14(%rbp),%eax
 4002d45:	83 e8 01             	sub    $0x1,%eax
 4002d48:	89 45 f8             	mov    %eax,-0x8(%rbp)
    
    while (left <= right) {
 4002d4b:	e9 94 00 00 00       	jmp    4002de4 <kpoolmemmgr_t::addr_to_HCB_MetaInfotb_Index(HCB_chainlist_node, unsigned char*)+0x130>
        int32_t mid = left + (right - left) / 2;
 4002d50:	8b 45 f8             	mov    -0x8(%rbp),%eax
 4002d53:	2b 45 fc             	sub    -0x4(%rbp),%eax
 4002d56:	89 c2                	mov    %eax,%edx
 4002d58:	c1 ea 1f             	shr    $0x1f,%edx
 4002d5b:	01 d0                	add    %edx,%eax
 4002d5d:	d1 f8                	sar    $1,%eax
 4002d5f:	89 c2                	mov    %eax,%edx
 4002d61:	8b 45 fc             	mov    -0x4(%rbp),%eax
 4002d64:	01 d0                	add    %edx,%eax
 4002d66:	89 45 c8             	mov    %eax,-0x38(%rbp)
        uint32_t objStart = metaTable[mid].offset_in_heap;
 4002d69:	8b 45 c8             	mov    -0x38(%rbp),%eax
 4002d6c:	48 63 d0             	movslq %eax,%rdx
 4002d6f:	48 89 d0             	mov    %rdx,%rax
 4002d72:	48 01 c0             	add    %rax,%rax
 4002d75:	48 01 d0             	add    %rdx,%rax
 4002d78:	48 c1 e0 02          	shl    $0x2,%rax
 4002d7c:	48 89 c2             	mov    %rax,%rdx
 4002d7f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4002d83:	48 01 d0             	add    %rdx,%rax
 4002d86:	8b 00                	mov    (%rax),%eax
 4002d88:	89 45 c4             	mov    %eax,-0x3c(%rbp)
        uint32_t objEnd = objStart + metaTable[mid].size;
 4002d8b:	8b 45 c8             	mov    -0x38(%rbp),%eax
 4002d8e:	48 63 d0             	movslq %eax,%rdx
 4002d91:	48 89 d0             	mov    %rdx,%rax
 4002d94:	48 01 c0             	add    %rax,%rax
 4002d97:	48 01 d0             	add    %rdx,%rax
 4002d9a:	48 c1 e0 02          	shl    $0x2,%rax
 4002d9e:	48 89 c2             	mov    %rax,%rdx
 4002da1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4002da5:	48 01 d0             	add    %rdx,%rax
 4002da8:	8b 50 04             	mov    0x4(%rax),%edx
 4002dab:	8b 45 c4             	mov    -0x3c(%rbp),%eax
 4002dae:	01 d0                	add    %edx,%eax
 4002db0:	89 45 c0             	mov    %eax,-0x40(%rbp)
        
        if (offset >= objStart && offset < objEnd) {
 4002db3:	8b 45 cc             	mov    -0x34(%rbp),%eax
 4002db6:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
 4002db9:	72 0d                	jb     4002dc8 <kpoolmemmgr_t::addr_to_HCB_MetaInfotb_Index(HCB_chainlist_node, unsigned char*)+0x114>
 4002dbb:	8b 45 cc             	mov    -0x34(%rbp),%eax
 4002dbe:	3b 45 c0             	cmp    -0x40(%rbp),%eax
 4002dc1:	73 05                	jae    4002dc8 <kpoolmemmgr_t::addr_to_HCB_MetaInfotb_Index(HCB_chainlist_node, unsigned char*)+0x114>
            // 地址在对象范围内
            return mid;
 4002dc3:	8b 45 c8             	mov    -0x38(%rbp),%eax
 4002dc6:	eb 2d                	jmp    4002df5 <kpoolmemmgr_t::addr_to_HCB_MetaInfotb_Index(HCB_chainlist_node, unsigned char*)+0x141>
        } else if (offset < objStart) {
 4002dc8:	8b 45 cc             	mov    -0x34(%rbp),%eax
 4002dcb:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
 4002dce:	73 0b                	jae    4002ddb <kpoolmemmgr_t::addr_to_HCB_MetaInfotb_Index(HCB_chainlist_node, unsigned char*)+0x127>
            right = mid - 1;
 4002dd0:	8b 45 c8             	mov    -0x38(%rbp),%eax
 4002dd3:	83 e8 01             	sub    $0x1,%eax
 4002dd6:	89 45 f8             	mov    %eax,-0x8(%rbp)
 4002dd9:	eb 09                	jmp    4002de4 <kpoolmemmgr_t::addr_to_HCB_MetaInfotb_Index(HCB_chainlist_node, unsigned char*)+0x130>
        } else {
            left = mid + 1;
 4002ddb:	8b 45 c8             	mov    -0x38(%rbp),%eax
 4002dde:	83 c0 01             	add    $0x1,%eax
 4002de1:	89 45 fc             	mov    %eax,-0x4(%rbp)
    while (left <= right) {
 4002de4:	8b 45 fc             	mov    -0x4(%rbp),%eax
 4002de7:	3b 45 f8             	cmp    -0x8(%rbp),%eax
 4002dea:	0f 8e 60 ff ff ff    	jle    4002d50 <kpoolmemmgr_t::addr_to_HCB_MetaInfotb_Index(HCB_chainlist_node, unsigned char*)+0x9c>
        }
    }
    
    // 如果没有找到对象，地址在堆空洞中
    return OS_NOT_EXIST;
 4002df0:	b8 11 10 00 00       	mov    $0x1011,%eax
}
 4002df5:	c9                   	leave
 4002df6:	c3                   	ret
 4002df7:	90                   	nop

0000000004002df8 <kpoolmemmgr_t::is_space_available(HCB_chainlist_node, unsigned char*, unsigned long)>:
 * 此函数搜索堆内存块中某段内存是否可申请,若是则返回空指针，
 * 若否，则返回下一个可能的空闲内存块的起始地址
 * 
 */
uint8_t* kpoolmemmgr_t::is_space_available(HCB_chainlist_node Heap, uint8_t* addr, uint64_t size)
{
 4002df8:	55                   	push   %rbp
 4002df9:	48 89 e5             	mov    %rsp,%rbp
 4002dfc:	53                   	push   %rbx
 4002dfd:	48 83 ec 68          	sub    $0x68,%rsp
 4002e01:	48 89 7d a0          	mov    %rdi,-0x60(%rbp)
 4002e05:	48 89 75 98          	mov    %rsi,-0x68(%rbp)
 4002e09:	48 89 55 90          	mov    %rdx,-0x70(%rbp)
    HeapMetaInfoArray* metaInfo = &Heap.heap.metaInfo;
 4002e0d:	48 8d 45 30          	lea    0x30(%rbp),%rax
 4002e11:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    uint32_t objCount = metaInfo->header.objMetaCount;
 4002e15:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 4002e19:	48 8b 40 08          	mov    0x8(%rax),%rax
 4002e1d:	89 45 ec             	mov    %eax,-0x14(%rbp)
    HeapObjectMetav2* metaTable = metaInfo->objMetaTable;
 4002e20:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 4002e24:	48 8b 40 18          	mov    0x18(%rax),%rax
 4002e28:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    uint8_t* heapStart = (uint8_t*)Heap.heap.heapStart;
 4002e2c:	48 8b 45 10          	mov    0x10(%rbp),%rax
 4002e30:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    uint8_t* heapEnd = heapStart + Heap.heap.heapSize;
 4002e34:	48 8b 55 20          	mov    0x20(%rbp),%rdx
 4002e38:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4002e3c:	48 01 d0             	add    %rdx,%rax
 4002e3f:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    
    // 检查地址是否在堆范围内
    if (addr < heapStart || addr >= heapEnd) {
 4002e43:	48 8b 45 98          	mov    -0x68(%rbp),%rax
 4002e47:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
 4002e4b:	72 0a                	jb     4002e57 <kpoolmemmgr_t::is_space_available(HCB_chainlist_node, unsigned char*, unsigned long)+0x5f>
 4002e4d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
 4002e51:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
 4002e55:	72 09                	jb     4002e60 <kpoolmemmgr_t::is_space_available(HCB_chainlist_node, unsigned char*, unsigned long)+0x68>
        return heapEnd; // 超出堆范围，返回堆结束地址
 4002e57:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
 4002e5b:	e9 4a 01 00 00       	jmp    4002faa <kpoolmemmgr_t::is_space_available(HCB_chainlist_node, unsigned char*, unsigned long)+0x1b2>
    }
    
    // 检查请求的大小是否超过堆剩余空间
    if (size > Heap.heap.freeSize) {
 4002e60:	48 8b 45 28          	mov    0x28(%rbp),%rax
 4002e64:	48 3b 45 90          	cmp    -0x70(%rbp),%rax
 4002e68:	73 09                	jae    4002e73 <kpoolmemmgr_t::is_space_available(HCB_chainlist_node, unsigned char*, unsigned long)+0x7b>
        return heapEnd; // 空间不足，返回堆结束地址
 4002e6a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
 4002e6e:	e9 37 01 00 00       	jmp    4002faa <kpoolmemmgr_t::is_space_available(HCB_chainlist_node, unsigned char*, unsigned long)+0x1b2>
    }
    
    // 检查地址+大小是否超出堆范围
    if (addr + size > heapEnd) {
 4002e73:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
 4002e77:	48 8b 45 90          	mov    -0x70(%rbp),%rax
 4002e7b:	48 01 d0             	add    %rdx,%rax
 4002e7e:	48 39 45 d0          	cmp    %rax,-0x30(%rbp)
 4002e82:	73 09                	jae    4002e8d <kpoolmemmgr_t::is_space_available(HCB_chainlist_node, unsigned char*, unsigned long)+0x95>
        return heapEnd; // 超出堆范围，返回堆结束地址
 4002e84:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
 4002e88:	e9 1d 01 00 00       	jmp    4002faa <kpoolmemmgr_t::is_space_available(HCB_chainlist_node, unsigned char*, unsigned long)+0x1b2>
    }
    
    // 使用二分查找定位地址所在的元数据项
    int index = addr_to_HCB_MetaInfotb_Index(Heap, addr);
 4002e8d:	48 8b 75 98          	mov    -0x68(%rbp),%rsi
 4002e91:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
 4002e95:	48 83 ec 58          	sub    $0x58,%rsp
 4002e99:	48 89 e0             	mov    %rsp,%rax
 4002e9c:	48 8b 4d 10          	mov    0x10(%rbp),%rcx
 4002ea0:	48 8b 5d 18          	mov    0x18(%rbp),%rbx
 4002ea4:	48 89 08             	mov    %rcx,(%rax)
 4002ea7:	48 89 58 08          	mov    %rbx,0x8(%rax)
 4002eab:	48 8b 4d 20          	mov    0x20(%rbp),%rcx
 4002eaf:	48 8b 5d 28          	mov    0x28(%rbp),%rbx
 4002eb3:	48 89 48 10          	mov    %rcx,0x10(%rax)
 4002eb7:	48 89 58 18          	mov    %rbx,0x18(%rax)
 4002ebb:	48 8b 4d 30          	mov    0x30(%rbp),%rcx
 4002ebf:	48 8b 5d 38          	mov    0x38(%rbp),%rbx
 4002ec3:	48 89 48 20          	mov    %rcx,0x20(%rax)
 4002ec7:	48 89 58 28          	mov    %rbx,0x28(%rax)
 4002ecb:	48 8b 4d 40          	mov    0x40(%rbp),%rcx
 4002ecf:	48 8b 5d 48          	mov    0x48(%rbp),%rbx
 4002ed3:	48 89 48 30          	mov    %rcx,0x30(%rax)
 4002ed7:	48 89 58 38          	mov    %rbx,0x38(%rax)
 4002edb:	48 8b 4d 50          	mov    0x50(%rbp),%rcx
 4002edf:	48 8b 5d 58          	mov    0x58(%rbp),%rbx
 4002ee3:	48 89 48 40          	mov    %rcx,0x40(%rax)
 4002ee7:	48 89 58 48          	mov    %rbx,0x48(%rax)
 4002eeb:	48 8b 4d 60          	mov    0x60(%rbp),%rcx
 4002eef:	48 89 48 50          	mov    %rcx,0x50(%rax)
 4002ef3:	48 89 d7             	mov    %rdx,%rdi
 4002ef6:	e8 b9 fd ff ff       	call   4002cb4 <kpoolmemmgr_t::addr_to_HCB_MetaInfotb_Index(HCB_chainlist_node, unsigned char*)>
 4002efb:	48 83 c4 58          	add    $0x58,%rsp
 4002eff:	89 45 cc             	mov    %eax,-0x34(%rbp)
    
    // 处理地址不在堆范围内的情况
    if (index == OS_OUT_OF_RANGE) {
 4002f02:	81 7d cc 10 10 00 00 	cmpl   $0x1010,-0x34(%rbp)
 4002f09:	75 09                	jne    4002f14 <kpoolmemmgr_t::is_space_available(HCB_chainlist_node, unsigned char*, unsigned long)+0x11c>
        return heapEnd;
 4002f0b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
 4002f0f:	e9 96 00 00 00       	jmp    4002faa <kpoolmemmgr_t::is_space_available(HCB_chainlist_node, unsigned char*, unsigned long)+0x1b2>
    }
    
    // 处理地址在堆空洞中的情况
    if (index == OS_NOT_EXIST) {
 4002f14:	81 7d cc 11 10 00 00 	cmpl   $0x1011,-0x34(%rbp)
 4002f1b:	75 09                	jne    4002f26 <kpoolmemmgr_t::is_space_available(HCB_chainlist_node, unsigned char*, unsigned long)+0x12e>
        // 这种情况理论上不应该发生，因为元信息表应该覆盖整个堆
        // 但如果发生了，我们返回堆结束地址
        return heapEnd;
 4002f1d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
 4002f21:	e9 84 00 00 00       	jmp    4002faa <kpoolmemmgr_t::is_space_available(HCB_chainlist_node, unsigned char*, unsigned long)+0x1b2>
    }
    
    // 处理地址在对象内的情况
    if (index >= 0 && index < objCount) {
 4002f26:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
 4002f2a:	78 7a                	js     4002fa6 <kpoolmemmgr_t::is_space_available(HCB_chainlist_node, unsigned char*, unsigned long)+0x1ae>
 4002f2c:	8b 45 cc             	mov    -0x34(%rbp),%eax
 4002f2f:	3b 45 ec             	cmp    -0x14(%rbp),%eax
 4002f32:	73 72                	jae    4002fa6 <kpoolmemmgr_t::is_space_available(HCB_chainlist_node, unsigned char*, unsigned long)+0x1ae>
        HeapObjectMetav2* meta = &metaTable[index];
 4002f34:	8b 45 cc             	mov    -0x34(%rbp),%eax
 4002f37:	48 63 d0             	movslq %eax,%rdx
 4002f3a:	48 89 d0             	mov    %rdx,%rax
 4002f3d:	48 01 c0             	add    %rax,%rax
 4002f40:	48 01 d0             	add    %rdx,%rax
 4002f43:	48 c1 e0 02          	shl    $0x2,%rax
 4002f47:	48 89 c2             	mov    %rax,%rdx
 4002f4a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4002f4e:	48 01 d0             	add    %rdx,%rax
 4002f51:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
        
        // 计算对象的起始地址
        uint8_t* objStart = heapStart + meta->offset_in_heap;
 4002f55:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
 4002f59:	8b 00                	mov    (%rax),%eax
 4002f5b:	89 c2                	mov    %eax,%edx
 4002f5d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4002f61:	48 01 d0             	add    %rdx,%rax
 4002f64:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
        uint8_t* objEnd = objStart + meta->size;
 4002f68:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
 4002f6c:	8b 40 04             	mov    0x4(%rax),%eax
 4002f6f:	89 c2                	mov    %eax,%edx
 4002f71:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 4002f75:	48 01 d0             	add    %rdx,%rax
 4002f78:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
        
        // 如果对象是空闲的，检查是否有足够空间
        if (meta->type == OBJ_TYPE_FREE) {
 4002f7c:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
 4002f80:	0f b6 40 08          	movzbl 0x8(%rax),%eax
 4002f84:	3c 0c                	cmp    $0xc,%al
 4002f86:	75 18                	jne    4002fa0 <kpoolmemmgr_t::is_space_available(HCB_chainlist_node, unsigned char*, unsigned long)+0x1a8>
            // 检查从给定地址开始是否有足够空间
            if (addr + size <= objEnd) {
 4002f88:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
 4002f8c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
 4002f90:	48 01 d0             	add    %rdx,%rax
 4002f93:	48 39 45 b0          	cmp    %rax,-0x50(%rbp)
 4002f97:	72 07                	jb     4002fa0 <kpoolmemmgr_t::is_space_available(HCB_chainlist_node, unsigned char*, unsigned long)+0x1a8>
                return nullptr; // 空间可用
 4002f99:	b8 00 00 00 00       	mov    $0x0,%eax
 4002f9e:	eb 0a                	jmp    4002faa <kpoolmemmgr_t::is_space_available(HCB_chainlist_node, unsigned char*, unsigned long)+0x1b2>
            }
        }
        
        // 对象被占用或空间不足，返回对象结束地址
        return objEnd;
 4002fa0:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
 4002fa4:	eb 04                	jmp    4002faa <kpoolmemmgr_t::is_space_available(HCB_chainlist_node, unsigned char*, unsigned long)+0x1b2>
    }
    
    // 默认情况下返回堆结束地址
    return heapEnd;
 4002fa6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
}
 4002faa:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
 4002fae:	c9                   	leave
 4002faf:	c3                   	ret

0000000004002fb0 <kpoolmemmgr_t::kalloc(unsigned long, bool, unsigned char)>:
 * 没有提前清理地址以及相关内存，
 * 可能造成未定义后果
 * 不过可以用另外的成员函数来实现
 */
void *kpoolmemmgr_t::kalloc(uint64_t size_in_bytes, bool vaddraquire, uint8_t alignment)
{   
 4002fb0:	55                   	push   %rbp
 4002fb1:	48 89 e5             	mov    %rsp,%rbp
 4002fb4:	48 81 ec e0 00 00 00 	sub    $0xe0,%rsp
 4002fbb:	48 89 bd 38 ff ff ff 	mov    %rdi,-0xc8(%rbp)
 4002fc2:	48 89 b5 30 ff ff ff 	mov    %rsi,-0xd0(%rbp)
 4002fc9:	89 c8                	mov    %ecx,%eax
 4002fcb:	88 95 2c ff ff ff    	mov    %dl,-0xd4(%rbp)
 4002fd1:	88 85 28 ff ff ff    	mov    %al,-0xd8(%rbp)
    if(size_in_bytes == 0) return nullptr;
 4002fd7:	48 83 bd 30 ff ff ff 	cmpq   $0x0,-0xd0(%rbp)
 4002fde:	00 
 4002fdf:	75 0a                	jne    4002feb <kpoolmemmgr_t::kalloc(unsigned long, bool, unsigned char)+0x3b>
 4002fe1:	b8 00 00 00 00       	mov    $0x0,%eax
 4002fe6:	e9 cb 05 00 00       	jmp    40035b6 <kpoolmemmgr_t::kalloc(unsigned long, bool, unsigned char)+0x606>
    
    if (kpoolmemmgr_flags.ableto_Expand == 0) {
 4002feb:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
 4002ff2:	0f b6 00             	movzbl (%rax),%eax
 4002ff5:	83 e0 01             	and    $0x1,%eax
 4002ff8:	84 c0                	test   %al,%al
 4002ffa:	0f 85 b1 05 00 00    	jne    40035b1 <kpoolmemmgr_t::kalloc(unsigned long, bool, unsigned char)+0x601>
        // 直接根据hcb.status里面的各个位进行判断
        bool is_free = (first_static_heap.heap.heapSize == first_static_heap.heap.freeSize);
 4003000:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
 4003007:	48 8b 50 20          	mov    0x20(%rax),%rdx
 400300b:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
 4003012:	48 8b 40 28          	mov    0x28(%rax),%rax
 4003016:	48 39 c2             	cmp    %rax,%rdx
 4003019:	0f 94 c0             	sete   %al
 400301c:	88 45 f7             	mov    %al,-0x9(%rbp)
        
        bool is_partial_used = (first_static_heap.heap.status.block_exist && 
 400301f:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
 4003026:	0f b6 40 50          	movzbl 0x50(%rax),%eax
 400302a:	83 e0 01             	and    $0x1,%eax
                                !first_static_heap.heap.status.block_tb_full && 
                                !first_static_heap.heap.status.block_full && 
                                !first_static_heap.heap.status.block_reserved && 
 400302d:	84 c0                	test   %al,%al
 400302f:	74 4f                	je     4003080 <kpoolmemmgr_t::kalloc(unsigned long, bool, unsigned char)+0xd0>
                                !first_static_heap.heap.status.block_tb_full && 
 4003031:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
 4003038:	0f b6 40 50          	movzbl 0x50(%rax),%eax
 400303c:	83 e0 02             	and    $0x2,%eax
        bool is_partial_used = (first_static_heap.heap.status.block_exist && 
 400303f:	84 c0                	test   %al,%al
 4003041:	75 3d                	jne    4003080 <kpoolmemmgr_t::kalloc(unsigned long, bool, unsigned char)+0xd0>
                                !first_static_heap.heap.status.block_full && 
 4003043:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
 400304a:	0f b6 40 50          	movzbl 0x50(%rax),%eax
 400304e:	83 e0 04             	and    $0x4,%eax
                                !first_static_heap.heap.status.block_tb_full && 
 4003051:	84 c0                	test   %al,%al
 4003053:	75 2b                	jne    4003080 <kpoolmemmgr_t::kalloc(unsigned long, bool, unsigned char)+0xd0>
                                !first_static_heap.heap.status.block_reserved && 
 4003055:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
 400305c:	0f b6 40 50          	movzbl 0x50(%rax),%eax
 4003060:	83 e0 08             	and    $0x8,%eax
                                !first_static_heap.heap.status.block_full && 
 4003063:	84 c0                	test   %al,%al
 4003065:	75 19                	jne    4003080 <kpoolmemmgr_t::kalloc(unsigned long, bool, unsigned char)+0xd0>
                                !first_static_heap.heap.status.block_merged);
 4003067:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
 400306e:	0f b6 40 50          	movzbl 0x50(%rax),%eax
 4003072:	83 e0 10             	and    $0x10,%eax
                                !first_static_heap.heap.status.block_reserved && 
 4003075:	84 c0                	test   %al,%al
 4003077:	75 07                	jne    4003080 <kpoolmemmgr_t::kalloc(unsigned long, bool, unsigned char)+0xd0>
 4003079:	b8 01 00 00 00       	mov    $0x1,%eax
 400307e:	eb 05                	jmp    4003085 <kpoolmemmgr_t::kalloc(unsigned long, bool, unsigned char)+0xd5>
 4003080:	b8 00 00 00 00       	mov    $0x0,%eax
        bool is_partial_used = (first_static_heap.heap.status.block_exist && 
 4003085:	88 45 f6             	mov    %al,-0xa(%rbp)
        
        if(!is_free && !is_partial_used) {
 4003088:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
 400308c:	83 f0 01             	xor    $0x1,%eax
 400308f:	84 c0                	test   %al,%al
 4003091:	74 15                	je     40030a8 <kpoolmemmgr_t::kalloc(unsigned long, bool, unsigned char)+0xf8>
 4003093:	0f b6 45 f6          	movzbl -0xa(%rbp),%eax
 4003097:	83 f0 01             	xor    $0x1,%eax
 400309a:	84 c0                	test   %al,%al
 400309c:	74 0a                	je     40030a8 <kpoolmemmgr_t::kalloc(unsigned long, bool, unsigned char)+0xf8>
            return nullptr;
 400309e:	b8 00 00 00 00       	mov    $0x0,%eax
 40030a3:	e9 0e 05 00 00       	jmp    40035b6 <kpoolmemmgr_t::kalloc(unsigned long, bool, unsigned char)+0x606>
        }
        
        HeapObjectMetav2* infotb = first_static_heap.heap.metaInfo.objMetaTable;
 40030a8:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
 40030af:	48 8b 40 48          	mov    0x48(%rax),%rax
 40030b3:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
        uint64_t MaxObjCount = first_static_heap.heap.metaInfo.header.objMetaMaxCount;
 40030b7:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
 40030be:	8b 40 40             	mov    0x40(%rax),%eax
 40030c1:	89 c0                	mov    %eax,%eax
 40030c3:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
        uint64_t ObjCount = first_static_heap.heap.metaInfo.header.objMetaCount;
 40030c7:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
 40030ce:	48 8b 40 38          	mov    0x38(%rax),%rax
 40030d2:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
        uint8_t* heap_phys_base = (uint8_t*)first_static_heap.heap.heapStart;
 40030d6:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
 40030dd:	48 8b 40 10          	mov    0x10(%rax),%rax
 40030e1:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
        uint8_t* heap_virt_base = (uint8_t*)first_static_heap.heap.heapVStart;
 40030e5:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
 40030ec:	48 8b 40 18          	mov    0x18(%rax),%rax
 40030f0:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
        
        // 计算对齐掩码
        uint64_t align_value = (1ULL << alignment);
 40030f4:	0f b6 85 28 ff ff ff 	movzbl -0xd8(%rbp),%eax
 40030fb:	ba 01 00 00 00       	mov    $0x1,%edx
 4003100:	89 c1                	mov    %eax,%ecx
 4003102:	48 d3 e2             	shl    %cl,%rdx
 4003105:	48 89 d0             	mov    %rdx,%rax
 4003108:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
        uint64_t align_mask = align_value - 1;
 400310c:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
 4003110:	48 83 e8 01          	sub    $0x1,%rax
 4003114:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
        
        // 遍历元信息表寻找合适的空闲块
        for (uint32_t i = 0; i < ObjCount; i++) {
 4003118:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
 400311f:	e9 79 04 00 00       	jmp    400359d <kpoolmemmgr_t::kalloc(unsigned long, bool, unsigned char)+0x5ed>
            if (infotb[i].type == OBJ_TYPE_FREE) {
 4003124:	8b 55 fc             	mov    -0x4(%rbp),%edx
 4003127:	48 89 d0             	mov    %rdx,%rax
 400312a:	48 01 c0             	add    %rax,%rax
 400312d:	48 01 d0             	add    %rdx,%rax
 4003130:	48 c1 e0 02          	shl    $0x2,%rax
 4003134:	48 89 c2             	mov    %rax,%rdx
 4003137:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 400313b:	48 01 d0             	add    %rdx,%rax
 400313e:	0f b6 40 08          	movzbl 0x8(%rax),%eax
 4003142:	3c 0c                	cmp    $0xc,%al
 4003144:	0f 85 4f 04 00 00    	jne    4003599 <kpoolmemmgr_t::kalloc(unsigned long, bool, unsigned char)+0x5e9>
                // 计算块的物理和虚拟起始地址
                uint8_t* block_phys_start = heap_phys_base + infotb[i].offset_in_heap;
 400314a:	8b 55 fc             	mov    -0x4(%rbp),%edx
 400314d:	48 89 d0             	mov    %rdx,%rax
 4003150:	48 01 c0             	add    %rax,%rax
 4003153:	48 01 d0             	add    %rdx,%rax
 4003156:	48 c1 e0 02          	shl    $0x2,%rax
 400315a:	48 89 c2             	mov    %rax,%rdx
 400315d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4003161:	48 01 d0             	add    %rdx,%rax
 4003164:	8b 00                	mov    (%rax),%eax
 4003166:	89 c2                	mov    %eax,%edx
 4003168:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
 400316c:	48 01 d0             	add    %rdx,%rax
 400316f:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
                uint8_t* block_virt_start = heap_virt_base + infotb[i].offset_in_heap;
 4003173:	8b 55 fc             	mov    -0x4(%rbp),%edx
 4003176:	48 89 d0             	mov    %rdx,%rax
 4003179:	48 01 c0             	add    %rax,%rax
 400317c:	48 01 d0             	add    %rdx,%rax
 400317f:	48 c1 e0 02          	shl    $0x2,%rax
 4003183:	48 89 c2             	mov    %rax,%rdx
 4003186:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 400318a:	48 01 d0             	add    %rdx,%rax
 400318d:	8b 00                	mov    (%rax),%eax
 400318f:	89 c2                	mov    %eax,%edx
 4003191:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 4003195:	48 01 d0             	add    %rdx,%rax
 4003198:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
                uint64_t block_size = infotb[i].size;
 400319c:	8b 55 fc             	mov    -0x4(%rbp),%edx
 400319f:	48 89 d0             	mov    %rdx,%rax
 40031a2:	48 01 c0             	add    %rax,%rax
 40031a5:	48 01 d0             	add    %rdx,%rax
 40031a8:	48 c1 e0 02          	shl    $0x2,%rax
 40031ac:	48 89 c2             	mov    %rax,%rdx
 40031af:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 40031b3:	48 01 d0             	add    %rdx,%rax
 40031b6:	8b 40 04             	mov    0x4(%rax),%eax
 40031b9:	89 c0                	mov    %eax,%eax
 40031bb:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
                
                // 计算对齐后的物理起始地址
                uint8_t* aligned_phys_start = (uint8_t*)(((uint64_t)block_phys_start + align_mask) & ~align_mask);
 40031bf:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
 40031c3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 40031c7:	48 01 c2             	add    %rax,%rdx
 40031ca:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 40031ce:	48 f7 d0             	not    %rax
 40031d1:	48 21 d0             	and    %rdx,%rax
 40031d4:	48 89 45 98          	mov    %rax,-0x68(%rbp)
                uint64_t alignment_padding = aligned_phys_start - block_phys_start;
 40031d8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
 40031dc:	48 2b 45 b0          	sub    -0x50(%rbp),%rax
 40031e0:	48 89 45 90          	mov    %rax,-0x70(%rbp)
                
                // 计算对应的虚拟地址
                uint8_t* aligned_virt_start = block_virt_start + alignment_padding;
 40031e4:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
 40031e8:	48 8b 45 90          	mov    -0x70(%rbp),%rax
 40031ec:	48 01 d0             	add    %rdx,%rax
 40031ef:	48 89 45 88          	mov    %rax,-0x78(%rbp)
                
                // 检查是否有足够空间（包括对齐填充）
                if (alignment_padding + size_in_bytes <= block_size) {
 40031f3:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
 40031f7:	48 8b 85 30 ff ff ff 	mov    -0xd0(%rbp),%rax
 40031fe:	48 01 d0             	add    %rdx,%rax
 4003201:	48 39 45 a0          	cmp    %rax,-0x60(%rbp)
 4003205:	0f 82 8e 03 00 00    	jb     4003599 <kpoolmemmgr_t::kalloc(unsigned long, bool, unsigned char)+0x5e9>
                    // 计算剩余空间
                    uint64_t remaining_size = block_size - alignment_padding - size_in_bytes;
 400320b:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
 400320f:	48 2b 45 90          	sub    -0x70(%rbp),%rax
 4003213:	48 2b 85 30 ff ff ff 	sub    -0xd0(%rbp),%rax
 400321a:	48 89 45 80          	mov    %rax,-0x80(%rbp)
                    
                    // 检查是否有空间存储新的元信息
                    uint32_t needed_entries = 0;
 400321e:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
                    if (alignment_padding > 0) needed_entries++;
 4003225:	48 83 7d 90 00       	cmpq   $0x0,-0x70(%rbp)
 400322a:	74 04                	je     4003230 <kpoolmemmgr_t::kalloc(unsigned long, bool, unsigned char)+0x280>
 400322c:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
                    if (remaining_size > 0) needed_entries++;
 4003230:	48 83 7d 80 00       	cmpq   $0x0,-0x80(%rbp)
 4003235:	74 04                	je     400323b <kpoolmemmgr_t::kalloc(unsigned long, bool, unsigned char)+0x28b>
 4003237:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
                    
                    if (ObjCount + needed_entries <= MaxObjCount) {
 400323b:	8b 55 f8             	mov    -0x8(%rbp),%edx
 400323e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4003242:	48 01 d0             	add    %rdx,%rax
 4003245:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
 4003249:	0f 82 43 03 00 00    	jb     4003592 <kpoolmemmgr_t::kalloc(unsigned long, bool, unsigned char)+0x5e2>
                        // 处理对齐填充部分
                        if (alignment_padding > 0) {
 400324f:	48 83 7d 90 00       	cmpq   $0x0,-0x70(%rbp)
 4003254:	0f 84 bc 01 00 00    	je     4003416 <kpoolmemmgr_t::kalloc(unsigned long, bool, unsigned char)+0x466>
                            // 创建对齐填充空闲块
                            HeapObjectMetav2 padding_block;
                            padding_block.offset_in_heap = infotb[i].offset_in_heap;
 400325a:	8b 55 fc             	mov    -0x4(%rbp),%edx
 400325d:	48 89 d0             	mov    %rdx,%rax
 4003260:	48 01 c0             	add    %rax,%rax
 4003263:	48 01 d0             	add    %rdx,%rax
 4003266:	48 c1 e0 02          	shl    $0x2,%rax
 400326a:	48 89 c2             	mov    %rax,%rdx
 400326d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4003271:	48 01 d0             	add    %rdx,%rax
 4003274:	8b 00                	mov    (%rax),%eax
 4003276:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%rbp)
                            padding_block.size = alignment_padding;
 400327c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
 4003280:	89 85 78 ff ff ff    	mov    %eax,-0x88(%rbp)
                            padding_block.type = OBJ_TYPE_FREE;
 4003286:	c6 85 7c ff ff ff 0c 	movb   $0xc,-0x84(%rbp)
                            
                            // 更新当前块为对齐填充块
                            infotb[i] = padding_block;
 400328d:	8b 55 fc             	mov    -0x4(%rbp),%edx
 4003290:	48 89 d0             	mov    %rdx,%rax
 4003293:	48 01 c0             	add    %rax,%rax
 4003296:	48 01 d0             	add    %rdx,%rax
 4003299:	48 c1 e0 02          	shl    $0x2,%rax
 400329d:	48 89 c2             	mov    %rax,%rdx
 40032a0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 40032a4:	48 01 d0             	add    %rdx,%rax
 40032a7:	48 8b 95 74 ff ff ff 	mov    -0x8c(%rbp),%rdx
 40032ae:	48 89 10             	mov    %rdx,(%rax)
 40032b1:	8b 95 7c ff ff ff    	mov    -0x84(%rbp),%edx
 40032b7:	89 50 08             	mov    %edx,0x8(%rax)
                            
                            // 如果有剩余空间，需要插入分配块和剩余空间块
                            if (remaining_size > 0) {
 40032ba:	48 83 7d 80 00       	cmpq   $0x0,-0x80(%rbp)
 40032bf:	0f 84 d6 00 00 00    	je     400339b <kpoolmemmgr_t::kalloc(unsigned long, bool, unsigned char)+0x3eb>
                                // 创建分配块
                                HeapObjectMetav2 alloc_block;
                                alloc_block.offset_in_heap = infotb[i].offset_in_heap + alignment_padding;
 40032c5:	8b 55 fc             	mov    -0x4(%rbp),%edx
 40032c8:	48 89 d0             	mov    %rdx,%rax
 40032cb:	48 01 c0             	add    %rax,%rax
 40032ce:	48 01 d0             	add    %rdx,%rax
 40032d1:	48 c1 e0 02          	shl    $0x2,%rax
 40032d5:	48 89 c2             	mov    %rax,%rdx
 40032d8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 40032dc:	48 01 d0             	add    %rdx,%rax
 40032df:	8b 00                	mov    (%rax),%eax
 40032e1:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
 40032e5:	01 d0                	add    %edx,%eax
 40032e7:	89 85 68 ff ff ff    	mov    %eax,-0x98(%rbp)
                                alloc_block.size = size_in_bytes;
 40032ed:	48 8b 85 30 ff ff ff 	mov    -0xd0(%rbp),%rax
 40032f4:	89 85 6c ff ff ff    	mov    %eax,-0x94(%rbp)
                                alloc_block.type = OBJ_TYPE_NORMAL;
 40032fa:	c6 85 70 ff ff ff 0b 	movb   $0xb,-0x90(%rbp)
                                
                                // 创建剩余空间空闲块
                                HeapObjectMetav2 remaining_block;
                                remaining_block.offset_in_heap = alloc_block.offset_in_heap + size_in_bytes;
 4003301:	8b 85 68 ff ff ff    	mov    -0x98(%rbp),%eax
 4003307:	48 8b 95 30 ff ff ff 	mov    -0xd0(%rbp),%rdx
 400330e:	01 d0                	add    %edx,%eax
 4003310:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%rbp)
                                remaining_block.size = remaining_size;
 4003316:	48 8b 45 80          	mov    -0x80(%rbp),%rax
 400331a:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%rbp)
                                remaining_block.type = OBJ_TYPE_FREE;
 4003320:	c6 85 64 ff ff ff 0c 	movb   $0xc,-0x9c(%rbp)
                                
                                // 插入分配块和剩余空间块
                                linearTBSerialInsert(
                                    &first_static_heap.heap.metaInfo.header.objMetaCount,
                                    i + 1,
 4003327:	8b 45 fc             	mov    -0x4(%rbp),%eax
 400332a:	83 c0 01             	add    $0x1,%eax
                                linearTBSerialInsert(
 400332d:	89 c6                	mov    %eax,%esi
 400332f:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
 4003336:	48 8d 78 38          	lea    0x38(%rax),%rdi
 400333a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
 400333e:	48 8d 85 68 ff ff ff 	lea    -0x98(%rbp),%rax
 4003345:	41 b9 01 00 00 00    	mov    $0x1,%r9d
 400334b:	41 b8 0c 00 00 00    	mov    $0xc,%r8d
 4003351:	48 89 d1             	mov    %rdx,%rcx
 4003354:	48 89 c2             	mov    %rax,%rdx
 4003357:	e8 ea 51 00 00       	call   4008546 <linearTBSerialInsert(unsigned long*, unsigned long, void*, void*, unsigned int, unsigned long)>
                                    1
                                );
                                
                                linearTBSerialInsert(
                                    &first_static_heap.heap.metaInfo.header.objMetaCount,
                                    i + 2,
 400335c:	8b 45 fc             	mov    -0x4(%rbp),%eax
 400335f:	83 c0 02             	add    $0x2,%eax
                                linearTBSerialInsert(
 4003362:	89 c6                	mov    %eax,%esi
 4003364:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
 400336b:	48 8d 78 38          	lea    0x38(%rax),%rdi
 400336f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
 4003373:	48 8d 85 5c ff ff ff 	lea    -0xa4(%rbp),%rax
 400337a:	41 b9 01 00 00 00    	mov    $0x1,%r9d
 4003380:	41 b8 0c 00 00 00    	mov    $0xc,%r8d
 4003386:	48 89 d1             	mov    %rdx,%rcx
 4003389:	48 89 c2             	mov    %rax,%rdx
 400338c:	e8 b5 51 00 00       	call   4008546 <linearTBSerialInsert(unsigned long*, unsigned long, void*, void*, unsigned int, unsigned long)>
                                    sizeof(HeapObjectMetav2),
                                    1
                                );
                                
                                // 更新对象计数
                                ObjCount += 2;
 4003391:	48 83 45 d8 02       	addq   $0x2,-0x28(%rbp)
 4003396:	e9 6c 01 00 00       	jmp    4003507 <kpoolmemmgr_t::kalloc(unsigned long, bool, unsigned char)+0x557>
                            } else {
                                // 只有对齐填充，没有剩余空间
                                // 创建分配块
                                HeapObjectMetav2 alloc_block;
                                alloc_block.offset_in_heap = infotb[i].offset_in_heap + alignment_padding;
 400339b:	8b 55 fc             	mov    -0x4(%rbp),%edx
 400339e:	48 89 d0             	mov    %rdx,%rax
 40033a1:	48 01 c0             	add    %rax,%rax
 40033a4:	48 01 d0             	add    %rdx,%rax
 40033a7:	48 c1 e0 02          	shl    $0x2,%rax
 40033ab:	48 89 c2             	mov    %rax,%rdx
 40033ae:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 40033b2:	48 01 d0             	add    %rdx,%rax
 40033b5:	8b 00                	mov    (%rax),%eax
 40033b7:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
 40033bb:	01 d0                	add    %edx,%eax
 40033bd:	89 85 50 ff ff ff    	mov    %eax,-0xb0(%rbp)
                                alloc_block.size = size_in_bytes;
 40033c3:	48 8b 85 30 ff ff ff 	mov    -0xd0(%rbp),%rax
 40033ca:	89 85 54 ff ff ff    	mov    %eax,-0xac(%rbp)
                                alloc_block.type = OBJ_TYPE_NORMAL;
 40033d0:	c6 85 58 ff ff ff 0b 	movb   $0xb,-0xa8(%rbp)
                                
                                // 插入分配块
                                linearTBSerialInsert(
                                    &first_static_heap.heap.metaInfo.header.objMetaCount,
                                    i + 1,
 40033d7:	8b 45 fc             	mov    -0x4(%rbp),%eax
 40033da:	83 c0 01             	add    $0x1,%eax
                                linearTBSerialInsert(
 40033dd:	89 c6                	mov    %eax,%esi
 40033df:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
 40033e6:	48 8d 78 38          	lea    0x38(%rax),%rdi
 40033ea:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
 40033ee:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
 40033f5:	41 b9 01 00 00 00    	mov    $0x1,%r9d
 40033fb:	41 b8 0c 00 00 00    	mov    $0xc,%r8d
 4003401:	48 89 d1             	mov    %rdx,%rcx
 4003404:	48 89 c2             	mov    %rax,%rdx
 4003407:	e8 3a 51 00 00       	call   4008546 <linearTBSerialInsert(unsigned long*, unsigned long, void*, void*, unsigned int, unsigned long)>
                                    sizeof(HeapObjectMetav2),
                                    1
                                );
                                
                                // 更新对象计数
                                ObjCount += 1;
 400340c:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
 4003411:	e9 f1 00 00 00       	jmp    4003507 <kpoolmemmgr_t::kalloc(unsigned long, bool, unsigned char)+0x557>
                            }
                        } else {
                            // 没有对齐填充，但有剩余空间
                            // 更新当前块为分配块
                            infotb[i].offset_in_heap += 0; // 偏移量不变
 4003416:	8b 55 fc             	mov    -0x4(%rbp),%edx
 4003419:	48 89 d0             	mov    %rdx,%rax
 400341c:	48 01 c0             	add    %rax,%rax
 400341f:	48 01 d0             	add    %rdx,%rax
 4003422:	48 c1 e0 02          	shl    $0x2,%rax
 4003426:	48 89 c2             	mov    %rax,%rdx
 4003429:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 400342d:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
 4003431:	8b 55 fc             	mov    -0x4(%rbp),%edx
 4003434:	48 89 d0             	mov    %rdx,%rax
 4003437:	48 01 c0             	add    %rax,%rax
 400343a:	48 01 d0             	add    %rdx,%rax
 400343d:	48 c1 e0 02          	shl    $0x2,%rax
 4003441:	48 89 c2             	mov    %rax,%rdx
 4003444:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4003448:	48 01 c2             	add    %rax,%rdx
 400344b:	8b 01                	mov    (%rcx),%eax
 400344d:	89 02                	mov    %eax,(%rdx)
                            infotb[i].size = size_in_bytes;
 400344f:	8b 55 fc             	mov    -0x4(%rbp),%edx
 4003452:	48 89 d0             	mov    %rdx,%rax
 4003455:	48 01 c0             	add    %rax,%rax
 4003458:	48 01 d0             	add    %rdx,%rax
 400345b:	48 c1 e0 02          	shl    $0x2,%rax
 400345f:	48 89 c2             	mov    %rax,%rdx
 4003462:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4003466:	48 01 d0             	add    %rdx,%rax
 4003469:	48 8b 95 30 ff ff ff 	mov    -0xd0(%rbp),%rdx
 4003470:	89 50 04             	mov    %edx,0x4(%rax)
                            infotb[i].type = OBJ_TYPE_NORMAL;
 4003473:	8b 55 fc             	mov    -0x4(%rbp),%edx
 4003476:	48 89 d0             	mov    %rdx,%rax
 4003479:	48 01 c0             	add    %rax,%rax
 400347c:	48 01 d0             	add    %rdx,%rax
 400347f:	48 c1 e0 02          	shl    $0x2,%rax
 4003483:	48 89 c2             	mov    %rax,%rdx
 4003486:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 400348a:	48 01 d0             	add    %rdx,%rax
 400348d:	c6 40 08 0b          	movb   $0xb,0x8(%rax)
                            
                            // 创建剩余空间空闲块
                            HeapObjectMetav2 remaining_block;
                            remaining_block.offset_in_heap = infotb[i].offset_in_heap + size_in_bytes;
 4003491:	8b 55 fc             	mov    -0x4(%rbp),%edx
 4003494:	48 89 d0             	mov    %rdx,%rax
 4003497:	48 01 c0             	add    %rax,%rax
 400349a:	48 01 d0             	add    %rdx,%rax
 400349d:	48 c1 e0 02          	shl    $0x2,%rax
 40034a1:	48 89 c2             	mov    %rax,%rdx
 40034a4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 40034a8:	48 01 d0             	add    %rdx,%rax
 40034ab:	8b 00                	mov    (%rax),%eax
 40034ad:	48 8b 95 30 ff ff ff 	mov    -0xd0(%rbp),%rdx
 40034b4:	01 d0                	add    %edx,%eax
 40034b6:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%rbp)
                            remaining_block.size = remaining_size;
 40034bc:	48 8b 45 80          	mov    -0x80(%rbp),%rax
 40034c0:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%rbp)
                            remaining_block.type = OBJ_TYPE_FREE;
 40034c6:	c6 85 4c ff ff ff 0c 	movb   $0xc,-0xb4(%rbp)
                            
                            // 插入剩余空间块
                            linearTBSerialInsert(
                                &first_static_heap.heap.metaInfo.header.objMetaCount,
                                i + 1,
 40034cd:	8b 45 fc             	mov    -0x4(%rbp),%eax
 40034d0:	83 c0 01             	add    $0x1,%eax
                            linearTBSerialInsert(
 40034d3:	89 c6                	mov    %eax,%esi
 40034d5:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
 40034dc:	48 8d 78 38          	lea    0x38(%rax),%rdi
 40034e0:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
 40034e4:	48 8d 85 44 ff ff ff 	lea    -0xbc(%rbp),%rax
 40034eb:	41 b9 01 00 00 00    	mov    $0x1,%r9d
 40034f1:	41 b8 0c 00 00 00    	mov    $0xc,%r8d
 40034f7:	48 89 d1             	mov    %rdx,%rcx
 40034fa:	48 89 c2             	mov    %rax,%rdx
 40034fd:	e8 44 50 00 00       	call   4008546 <linearTBSerialInsert(unsigned long*, unsigned long, void*, void*, unsigned int, unsigned long)>
                                sizeof(HeapObjectMetav2),
                                1
                            );
                            
                            // 更新对象计数
                            ObjCount += 1;
 4003502:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
                        }
                        
                        // 更新堆的剩余空间
                        first_static_heap.heap.freeSize -= size_in_bytes;
 4003507:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
 400350e:	48 8b 40 28          	mov    0x28(%rax),%rax
 4003512:	48 2b 85 30 ff ff ff 	sub    -0xd0(%rbp),%rax
 4003519:	48 89 c2             	mov    %rax,%rdx
 400351c:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
 4003523:	48 89 50 28          	mov    %rdx,0x28(%rax)
                        
                        if(first_static_heap.heap.freeSize) {
 4003527:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
 400352e:	48 8b 40 28          	mov    0x28(%rax),%rax
 4003532:	48 85 c0             	test   %rax,%rax
 4003535:	74 24                	je     400355b <kpoolmemmgr_t::kalloc(unsigned long, bool, unsigned char)+0x5ab>
                            // 设置为部分使用状态
                            first_static_heap.heap.status.block_exist = 1;
 4003537:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
 400353e:	0f b6 50 50          	movzbl 0x50(%rax),%edx
 4003542:	83 ca 01             	or     $0x1,%edx
 4003545:	88 50 50             	mov    %dl,0x50(%rax)
                            first_static_heap.heap.status.block_full = 0;
 4003548:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
 400354f:	0f b6 50 50          	movzbl 0x50(%rax),%edx
 4003553:	83 e2 fb             	and    $0xfffffffb,%edx
 4003556:	88 50 50             	mov    %dl,0x50(%rax)
 4003559:	eb 22                	jmp    400357d <kpoolmemmgr_t::kalloc(unsigned long, bool, unsigned char)+0x5cd>
                        } else {
                            // 设置为完全使用状态
                            first_static_heap.heap.status.block_exist = 1;
 400355b:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
 4003562:	0f b6 50 50          	movzbl 0x50(%rax),%edx
 4003566:	83 ca 01             	or     $0x1,%edx
 4003569:	88 50 50             	mov    %dl,0x50(%rax)
                            first_static_heap.heap.status.block_full = 1;
 400356c:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
 4003573:	0f b6 50 50          	movzbl 0x50(%rax),%edx
 4003577:	83 ca 04             	or     $0x4,%edx
 400357a:	88 50 50             	mov    %dl,0x50(%rax)
                        }
                        
                        // 返回分配的内存地址
                        if (vaddraquire) {
 400357d:	80 bd 2c ff ff ff 00 	cmpb   $0x0,-0xd4(%rbp)
 4003584:	74 06                	je     400358c <kpoolmemmgr_t::kalloc(unsigned long, bool, unsigned char)+0x5dc>
                            return aligned_virt_start;
 4003586:	48 8b 45 88          	mov    -0x78(%rbp),%rax
 400358a:	eb 2a                	jmp    40035b6 <kpoolmemmgr_t::kalloc(unsigned long, bool, unsigned char)+0x606>
                        } else {
                            return aligned_phys_start;
 400358c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
 4003590:	eb 24                	jmp    40035b6 <kpoolmemmgr_t::kalloc(unsigned long, bool, unsigned char)+0x606>
                        }
                    } else {
                       return nullptr;  
 4003592:	b8 00 00 00 00       	mov    $0x0,%eax
 4003597:	eb 1d                	jmp    40035b6 <kpoolmemmgr_t::kalloc(unsigned long, bool, unsigned char)+0x606>
        for (uint32_t i = 0; i < ObjCount; i++) {
 4003599:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
 400359d:	8b 45 fc             	mov    -0x4(%rbp),%eax
 40035a0:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
 40035a4:	0f 82 7a fb ff ff    	jb     4003124 <kpoolmemmgr_t::kalloc(unsigned long, bool, unsigned char)+0x174>
                }
            }
        }
        
        // 没有找到合适的空闲块
        return nullptr;
 40035aa:	b8 00 00 00 00       	mov    $0x0,%eax
 40035af:	eb 05                	jmp    40035b6 <kpoolmemmgr_t::kalloc(unsigned long, bool, unsigned char)+0x606>
    } else {
        // ableto_Expand位开启的情况，暂不实现
        return nullptr;
 40035b1:	b8 00 00 00 00       	mov    $0x0,%eax
    }
}
 40035b6:	c9                   	leave
 40035b7:	c3                   	ret

00000000040035b8 <kpoolmemmgr_t::Init()>:
void kpoolmemmgr_t::Init()
{
 40035b8:	55                   	push   %rbp
 40035b9:	48 89 e5             	mov    %rsp,%rbp
 40035bc:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
#ifdef KERNEL_MODE
    // 获取内核堆的起始地址和大小
    first_static_heap.heap.heapStart = (phyaddr_t)&__heap_start;
 40035c0:	48 8d 15 39 ca 1f 00 	lea    0x1fca39(%rip),%rdx        # 4200000 <__heap_start>
 40035c7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 40035cb:	48 89 50 10          	mov    %rdx,0x10(%rax)
    first_static_heap.heap.heapVStart = (vaddr_t)&__heap_start;
 40035cf:	48 8d 15 2a ca 1f 00 	lea    0x1fca2a(%rip),%rdx        # 4200000 <__heap_start>
 40035d6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 40035da:	48 89 50 18          	mov    %rdx,0x18(%rax)
    first_static_heap.heap.heapSize = (uint64_t)(&__heap_end - &__heap_start);
 40035de:	48 8d 15 1b ca 5f 00 	lea    0x5fca1b(%rip),%rdx        # 4600000 <__heap_end>
 40035e5:	48 8d 05 14 ca 1f 00 	lea    0x1fca14(%rip),%rax        # 4200000 <__heap_start>
 40035ec:	48 29 c2             	sub    %rax,%rdx
 40035ef:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 40035f3:	48 89 50 20          	mov    %rdx,0x20(%rax)
    first_static_heap.heap.freeSize = (uint64_t)(&__heap_end - &__heap_start);
 40035f7:	48 8d 15 02 ca 5f 00 	lea    0x5fca02(%rip),%rdx        # 4600000 <__heap_end>
 40035fe:	48 8d 05 fb c9 1f 00 	lea    0x1fc9fb(%rip),%rax        # 4200000 <__heap_start>
 4003605:	48 29 c2             	sub    %rax,%rdx
 4003608:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 400360c:	48 89 50 28          	mov    %rdx,0x28(%rax)
#endif    
    first_static_heap.heap.status.block_exist = 0;
 4003610:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4003614:	0f b6 50 50          	movzbl 0x50(%rax),%edx
 4003618:	83 e2 fe             	and    $0xfffffffe,%edx
 400361b:	88 50 50             	mov    %dl,0x50(%rax)
    first_static_heap.heap.status.block_tb_full = 0;
 400361e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4003622:	0f b6 50 50          	movzbl 0x50(%rax),%edx
 4003626:	83 e2 fd             	and    $0xfffffffd,%edx
 4003629:	88 50 50             	mov    %dl,0x50(%rax)
    first_static_heap.heap.status.block_full = 0;
 400362c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4003630:	0f b6 50 50          	movzbl 0x50(%rax),%edx
 4003634:	83 e2 fb             	and    $0xfffffffb,%edx
 4003637:	88 50 50             	mov    %dl,0x50(%rax)
    first_static_heap.heap.status.block_reserved = 0;
 400363a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 400363e:	0f b6 50 50          	movzbl 0x50(%rax),%edx
 4003642:	83 e2 f7             	and    $0xfffffff7,%edx
 4003645:	88 50 50             	mov    %dl,0x50(%rax)
    first_static_heap.heap.status.block_merged = 0;
 4003648:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 400364c:	0f b6 50 50          	movzbl 0x50(%rax),%edx
 4003650:	83 e2 ef             	and    $0xffffffef,%edx
 4003653:	88 50 50             	mov    %dl,0x50(%rax)
    
    // 初始化元信息数组
    first_static_heap.heap.metaInfo.header.magic = 0x48504D41; // "HPM A"
 4003656:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 400365a:	c7 40 30 41 4d 50 48 	movl   $0x48504d41,0x30(%rax)
    first_static_heap.heap.metaInfo.header.version = 2; // 版本改为2，表示使用v2元信息
 4003661:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4003665:	c7 40 34 02 00 00 00 	movl   $0x2,0x34(%rax)
    first_static_heap.heap.metaInfo.header.objMetaCount = 1;  // 初始时有一个空闲对象
 400366c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4003670:	48 c7 40 38 01 00 00 	movq   $0x1,0x38(%rax)
 4003677:	00 
    first_static_heap.heap.metaInfo.header.objMetaMaxCount = FirstStaticHeapMaxObjCount;
 4003678:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 400367c:	c7 40 40 00 10 00 00 	movl   $0x1000,0x40(%rax)
    first_static_heap.heap.metaInfo.objMetaTable = objMetaTable_for_FirstStaticHeap;
 4003683:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4003687:	48 8d 15 72 ca 7f 00 	lea    0x7fca72(%rip),%rdx        # 4800100 <objMetaTable_for_FirstStaticHeap>
 400368e:	48 89 50 48          	mov    %rdx,0x48(%rax)
    
    // 初始化第一个元信息项（整个堆作为空闲块）
    objMetaTable_for_FirstStaticHeap[0].offset_in_heap = 0;
 4003692:	c7 05 64 ca 7f 00 00 	movl   $0x0,0x7fca64(%rip)        # 4800100 <objMetaTable_for_FirstStaticHeap>
 4003699:	00 00 00 
    objMetaTable_for_FirstStaticHeap[0].size = first_static_heap.heap.heapSize;
 400369c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 40036a0:	48 8b 40 20          	mov    0x20(%rax),%rax
 40036a4:	89 05 5a ca 7f 00    	mov    %eax,0x7fca5a(%rip)        # 4800104 <objMetaTable_for_FirstStaticHeap+0x4>
    objMetaTable_for_FirstStaticHeap[0].type = OBJ_TYPE_FREE;
 40036aa:	c6 05 57 ca 7f 00 0c 	movb   $0xc,0x7fca57(%rip)        # 4800108 <objMetaTable_for_FirstStaticHeap+0x8>
    
    // 初始化链表指针
    first_static_heap.prev = nullptr;
 40036b1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 40036b5:	48 c7 40 58 00 00 00 	movq   $0x0,0x58(%rax)
 40036bc:	00 
    first_static_heap.next = nullptr;
 40036bd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 40036c1:	48 c7 40 60 00 00 00 	movq   $0x0,0x60(%rax)
 40036c8:	00 
    last_heap_node = &first_static_heap;
 40036c9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 40036cd:	48 8d 50 10          	lea    0x10(%rax),%rdx
 40036d1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 40036d5:	48 89 50 68          	mov    %rdx,0x68(%rax)
    
    // 初始化flags结构
    kpoolmemmgr_flags.ableto_Expand = 0;
 40036d9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 40036dd:	0f b6 10             	movzbl (%rax),%edx
 40036e0:	83 e2 fe             	and    $0xfffffffe,%edx
 40036e3:	88 10                	mov    %dl,(%rax)
    kpoolmemmgr_flags.heap_vaddr_enabled = 1; // 默认启用虚拟地址
 40036e5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 40036e9:	0f b6 10             	movzbl (%rax),%edx
 40036ec:	83 ca 02             	or     $0x2,%edx
 40036ef:	88 10                	mov    %dl,(%rax)
    kpoolmemmgr_flags.alignment = 3; // 默认8字节对齐 (2^3=8)
 40036f1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 40036f5:	0f b7 10             	movzwl (%rax),%edx
 40036f8:	66 81 e2 03 fc       	and    $0xfc03,%dx
 40036fd:	83 ca 0c             	or     $0xc,%edx
 4003700:	66 89 10             	mov    %dx,(%rax)
    
    HCB_count = 1;
 4003703:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4003707:	48 c7 40 08 01 00 00 	movq   $0x1,0x8(%rax)
 400370e:	00 
}
 400370f:	90                   	nop
 4003710:	5d                   	pop    %rbp
 4003711:	c3                   	ret

0000000004003712 <kpoolmemmgr_t::getFirst_static_heap()>:
HCB_chainlist_node *kpoolmemmgr_t::getFirst_static_heap()
{
 4003712:	55                   	push   %rbp
 4003713:	48 89 e5             	mov    %rsp,%rbp
 4003716:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    return &first_static_heap;
 400371a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 400371e:	48 83 c0 10          	add    $0x10,%rax
}
 4003722:	5d                   	pop    %rbp
 4003723:	c3                   	ret

0000000004003724 <kpoolmemmgr_t::getkpoolmemmgr_flags()>:
kpoolmemmgr_flags_t kpoolmemmgr_t::getkpoolmemmgr_flags()
{
 4003724:	55                   	push   %rbp
 4003725:	48 89 e5             	mov    %rsp,%rbp
 4003728:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    return kpoolmemmgr_flags;
 400372c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4003730:	48 8b 00             	mov    (%rax),%rax
}
 4003733:	5d                   	pop    %rbp
 4003734:	c3                   	ret
 4003735:	90                   	nop

0000000004003736 <kpoolmemmgr_t::mgr_vaddr_enabled()>:

// 实现mgr_vaddr_enabled方法
int kpoolmemmgr_t::mgr_vaddr_enabled()
{
 4003736:	55                   	push   %rbp
 4003737:	48 89 e5             	mov    %rsp,%rbp
 400373a:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    return kpoolmemmgr_flags.heap_vaddr_enabled;
 400373e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4003742:	0f b6 00             	movzbl (%rax),%eax
 4003745:	d0 e8                	shr    $1,%al
 4003747:	83 e0 01             	and    $0x1,%eax
 400374a:	0f b6 c0             	movzbl %al,%eax
}
 400374d:	5d                   	pop    %rbp
 400374e:	c3                   	ret
 400374f:	90                   	nop

0000000004003750 <kpoolmemmgr_t::kfree(void*)>:

void kpoolmemmgr_t::kfree(void* ptr)
{
 4003750:	55                   	push   %rbp
 4003751:	48 89 e5             	mov    %rsp,%rbp
 4003754:	48 83 ec 70          	sub    $0x70,%rsp
 4003758:	48 89 7d 98          	mov    %rdi,-0x68(%rbp)
 400375c:	48 89 75 90          	mov    %rsi,-0x70(%rbp)
    if (kpoolmemmgr_flags.ableto_Expand == 0) {
 4003760:	48 8b 45 98          	mov    -0x68(%rbp),%rax
 4003764:	0f b6 00             	movzbl (%rax),%eax
 4003767:	83 e0 01             	and    $0x1,%eax
 400376a:	84 c0                	test   %al,%al
 400376c:	0f 85 14 04 00 00    	jne    4003b86 <kpoolmemmgr_t::kfree(void*)+0x436>
        HeapObjectMetav2* infotb = first_static_heap.heap.metaInfo.objMetaTable;
 4003772:	48 8b 45 98          	mov    -0x68(%rbp),%rax
 4003776:	48 8b 40 48          	mov    0x48(%rax),%rax
 400377a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
        uint64_t ObjCount = first_static_heap.heap.metaInfo.header.objMetaCount;
 400377e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
 4003782:	48 8b 40 38          	mov    0x38(%rax),%rax
 4003786:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
        uint8_t* heap_phys_base = (uint8_t*)first_static_heap.heap.heapStart;
 400378a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
 400378e:	48 8b 40 10          	mov    0x10(%rax),%rax
 4003792:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
        uint8_t* heap_virt_base = (uint8_t*)first_static_heap.heap.heapVStart;
 4003796:	48 8b 45 98          	mov    -0x68(%rbp),%rax
 400379a:	48 8b 40 18          	mov    0x18(%rax),%rax
 400379e:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
        
        // 判断ptr是物理地址还是虚拟地址
        bool is_virtual_addr = false;
 40037a2:	c6 45 f7 00          	movb   $0x0,-0x9(%rbp)
        uint8_t* target_addr = (uint8_t*)ptr;
 40037a6:	48 8b 45 90          	mov    -0x70(%rbp),%rax
 40037aa:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
        
        // 检查高16位是否全1（虚拟地址特征）
        if ((reinterpret_cast<uint64_t>(ptr) >> 48) == 0xFFFF) {
 40037ae:	48 8b 45 90          	mov    -0x70(%rbp),%rax
 40037b2:	48 c1 e8 30          	shr    $0x30,%rax
 40037b6:	48 3d ff ff 00 00    	cmp    $0xffff,%rax
 40037bc:	75 04                	jne    40037c2 <kpoolmemmgr_t::kfree(void*)+0x72>
            is_virtual_addr = true;
 40037be:	c6 45 f7 01          	movb   $0x1,-0x9(%rbp)
        }
        
        // 计算目标地址在堆中的偏移量
        uint32_t target_offset;
        if (is_virtual_addr) {
 40037c2:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
 40037c6:	74 1c                	je     40037e4 <kpoolmemmgr_t::kfree(void*)+0x94>
            target_offset = virt_addr_to_offset(&first_static_heap, target_addr);
 40037c8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
 40037cc:	48 8d 50 10          	lea    0x10(%rax),%rdx
 40037d0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 40037d4:	48 89 c6             	mov    %rax,%rsi
 40037d7:	48 89 d7             	mov    %rdx,%rdi
 40037da:	e8 b5 f4 ff ff       	call   4002c94 <virt_addr_to_offset(HCB_chainlist_node*, unsigned char*)>
 40037df:	89 45 f0             	mov    %eax,-0x10(%rbp)
 40037e2:	eb 1a                	jmp    40037fe <kpoolmemmgr_t::kfree(void*)+0xae>
        } else {
            target_offset = phys_addr_to_offset(&first_static_heap, target_addr);
 40037e4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
 40037e8:	48 8d 50 10          	lea    0x10(%rax),%rdx
 40037ec:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 40037f0:	48 89 c6             	mov    %rax,%rsi
 40037f3:	48 89 d7             	mov    %rdx,%rdi
 40037f6:	e8 7a f4 ff ff       	call   4002c75 <phys_addr_to_offset(HCB_chainlist_node*, unsigned char*)>
 40037fb:	89 45 f0             	mov    %eax,-0x10(%rbp)
        }
        
        // 遍历元信息表查找对应的对象
        for (uint32_t i = 0; i < ObjCount; i++) {
 40037fe:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
 4003805:	e9 6f 03 00 00       	jmp    4003b79 <kpoolmemmgr_t::kfree(void*)+0x429>
            uint32_t obj_offset = infotb[i].offset_in_heap;
 400380a:	8b 55 ec             	mov    -0x14(%rbp),%edx
 400380d:	48 89 d0             	mov    %rdx,%rax
 4003810:	48 01 c0             	add    %rax,%rax
 4003813:	48 01 d0             	add    %rdx,%rax
 4003816:	48 c1 e0 02          	shl    $0x2,%rax
 400381a:	48 89 c2             	mov    %rax,%rdx
 400381d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4003821:	48 01 d0             	add    %rdx,%rax
 4003824:	8b 00                	mov    (%rax),%eax
 4003826:	89 45 c4             	mov    %eax,-0x3c(%rbp)
            uint32_t obj_end = obj_offset + infotb[i].size;
 4003829:	8b 55 ec             	mov    -0x14(%rbp),%edx
 400382c:	48 89 d0             	mov    %rdx,%rax
 400382f:	48 01 c0             	add    %rax,%rax
 4003832:	48 01 d0             	add    %rdx,%rax
 4003835:	48 c1 e0 02          	shl    $0x2,%rax
 4003839:	48 89 c2             	mov    %rax,%rdx
 400383c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4003840:	48 01 d0             	add    %rdx,%rax
 4003843:	8b 50 04             	mov    0x4(%rax),%edx
 4003846:	8b 45 c4             	mov    -0x3c(%rbp),%eax
 4003849:	01 d0                	add    %edx,%eax
 400384b:	89 45 c0             	mov    %eax,-0x40(%rbp)
            
            // 检查地址是否匹配
            bool addr_match = (target_offset >= obj_offset && target_offset < obj_end);
 400384e:	8b 45 f0             	mov    -0x10(%rbp),%eax
 4003851:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
 4003854:	72 0f                	jb     4003865 <kpoolmemmgr_t::kfree(void*)+0x115>
 4003856:	8b 45 f0             	mov    -0x10(%rbp),%eax
 4003859:	3b 45 c0             	cmp    -0x40(%rbp),%eax
 400385c:	73 07                	jae    4003865 <kpoolmemmgr_t::kfree(void*)+0x115>
 400385e:	b8 01 00 00 00       	mov    $0x1,%eax
 4003863:	eb 05                	jmp    400386a <kpoolmemmgr_t::kfree(void*)+0x11a>
 4003865:	b8 00 00 00 00       	mov    $0x0,%eax
 400386a:	88 45 bf             	mov    %al,-0x41(%rbp)
            
            if (addr_match && infotb[i].type != OBJ_TYPE_FREE) {
 400386d:	80 7d bf 00          	cmpb   $0x0,-0x41(%rbp)
 4003871:	0f 84 fe 02 00 00    	je     4003b75 <kpoolmemmgr_t::kfree(void*)+0x425>
 4003877:	8b 55 ec             	mov    -0x14(%rbp),%edx
 400387a:	48 89 d0             	mov    %rdx,%rax
 400387d:	48 01 c0             	add    %rax,%rax
 4003880:	48 01 d0             	add    %rdx,%rax
 4003883:	48 c1 e0 02          	shl    $0x2,%rax
 4003887:	48 89 c2             	mov    %rax,%rdx
 400388a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 400388e:	48 01 d0             	add    %rdx,%rax
 4003891:	0f b6 40 08          	movzbl 0x8(%rax),%eax
 4003895:	3c 0c                	cmp    $0xc,%al
 4003897:	0f 84 d8 02 00 00    	je     4003b75 <kpoolmemmgr_t::kfree(void*)+0x425>
                // 找到要释放的对象
                uint64_t freed_size = infotb[i].size;
 400389d:	8b 55 ec             	mov    -0x14(%rbp),%edx
 40038a0:	48 89 d0             	mov    %rdx,%rax
 40038a3:	48 01 c0             	add    %rax,%rax
 40038a6:	48 01 d0             	add    %rdx,%rax
 40038a9:	48 c1 e0 02          	shl    $0x2,%rax
 40038ad:	48 89 c2             	mov    %rax,%rdx
 40038b0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 40038b4:	48 01 d0             	add    %rdx,%rax
 40038b7:	8b 40 04             	mov    0x4(%rax),%eax
 40038ba:	89 c0                	mov    %eax,%eax
 40038bc:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
                
                // 标记为空闲块
                infotb[i].type = OBJ_TYPE_FREE;
 40038c0:	8b 55 ec             	mov    -0x14(%rbp),%edx
 40038c3:	48 89 d0             	mov    %rdx,%rax
 40038c6:	48 01 c0             	add    %rax,%rax
 40038c9:	48 01 d0             	add    %rdx,%rax
 40038cc:	48 c1 e0 02          	shl    $0x2,%rax
 40038d0:	48 89 c2             	mov    %rax,%rdx
 40038d3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 40038d7:	48 01 d0             	add    %rdx,%rax
 40038da:	c6 40 08 0c          	movb   $0xc,0x8(%rax)
                
                // 更新堆的空闲空间
                first_static_heap.heap.freeSize += freed_size;
 40038de:	48 8b 45 98          	mov    -0x68(%rbp),%rax
 40038e2:	48 8b 50 28          	mov    0x28(%rax),%rdx
 40038e6:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
 40038ea:	48 01 c2             	add    %rax,%rdx
 40038ed:	48 8b 45 98          	mov    -0x68(%rbp),%rax
 40038f1:	48 89 50 28          	mov    %rdx,0x28(%rax)
                
                // 尝试与相邻的空闲块合并
                bool merged;
                do {
                    merged = false;
 40038f5:	c6 45 eb 00          	movb   $0x0,-0x15(%rbp)
                    
                    // 尝试与前一个块合并
                    if (i > 0 && infotb[i-1].type == OBJ_TYPE_FREE) {
 40038f9:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
 40038fd:	0f 84 2d 01 00 00    	je     4003a30 <kpoolmemmgr_t::kfree(void*)+0x2e0>
 4003903:	8b 45 ec             	mov    -0x14(%rbp),%eax
 4003906:	83 e8 01             	sub    $0x1,%eax
 4003909:	89 c2                	mov    %eax,%edx
 400390b:	48 89 d0             	mov    %rdx,%rax
 400390e:	48 01 c0             	add    %rax,%rax
 4003911:	48 01 d0             	add    %rdx,%rax
 4003914:	48 c1 e0 02          	shl    $0x2,%rax
 4003918:	48 89 c2             	mov    %rax,%rdx
 400391b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 400391f:	48 01 d0             	add    %rdx,%rax
 4003922:	0f b6 40 08          	movzbl 0x8(%rax),%eax
 4003926:	3c 0c                	cmp    $0xc,%al
 4003928:	0f 85 02 01 00 00    	jne    4003a30 <kpoolmemmgr_t::kfree(void*)+0x2e0>
                        uint32_t prev_end = infotb[i-1].offset_in_heap + infotb[i-1].size;
 400392e:	8b 45 ec             	mov    -0x14(%rbp),%eax
 4003931:	83 e8 01             	sub    $0x1,%eax
 4003934:	89 c2                	mov    %eax,%edx
 4003936:	48 89 d0             	mov    %rdx,%rax
 4003939:	48 01 c0             	add    %rax,%rax
 400393c:	48 01 d0             	add    %rdx,%rax
 400393f:	48 c1 e0 02          	shl    $0x2,%rax
 4003943:	48 89 c2             	mov    %rax,%rdx
 4003946:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 400394a:	48 01 d0             	add    %rdx,%rax
 400394d:	8b 10                	mov    (%rax),%edx
 400394f:	8b 45 ec             	mov    -0x14(%rbp),%eax
 4003952:	83 e8 01             	sub    $0x1,%eax
 4003955:	89 c1                	mov    %eax,%ecx
 4003957:	48 89 c8             	mov    %rcx,%rax
 400395a:	48 01 c0             	add    %rax,%rax
 400395d:	48 01 c8             	add    %rcx,%rax
 4003960:	48 c1 e0 02          	shl    $0x2,%rax
 4003964:	48 89 c1             	mov    %rax,%rcx
 4003967:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 400396b:	48 01 c8             	add    %rcx,%rax
 400396e:	8b 40 04             	mov    0x4(%rax),%eax
 4003971:	01 d0                	add    %edx,%eax
 4003973:	89 45 ac             	mov    %eax,-0x54(%rbp)
                        
                        // 检查偏移量是否连续
                        if (prev_end == infotb[i].offset_in_heap) {
 4003976:	8b 55 ec             	mov    -0x14(%rbp),%edx
 4003979:	48 89 d0             	mov    %rdx,%rax
 400397c:	48 01 c0             	add    %rax,%rax
 400397f:	48 01 d0             	add    %rdx,%rax
 4003982:	48 c1 e0 02          	shl    $0x2,%rax
 4003986:	48 89 c2             	mov    %rax,%rdx
 4003989:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 400398d:	48 01 d0             	add    %rdx,%rax
 4003990:	8b 00                	mov    (%rax),%eax
 4003992:	39 45 ac             	cmp    %eax,-0x54(%rbp)
 4003995:	0f 85 95 00 00 00    	jne    4003a30 <kpoolmemmgr_t::kfree(void*)+0x2e0>
                            // 合并块
                            infotb[i-1].size += infotb[i].size;
 400399b:	8b 45 ec             	mov    -0x14(%rbp),%eax
 400399e:	83 e8 01             	sub    $0x1,%eax
 40039a1:	89 c2                	mov    %eax,%edx
 40039a3:	48 89 d0             	mov    %rdx,%rax
 40039a6:	48 01 c0             	add    %rax,%rax
 40039a9:	48 01 d0             	add    %rdx,%rax
 40039ac:	48 c1 e0 02          	shl    $0x2,%rax
 40039b0:	48 89 c2             	mov    %rax,%rdx
 40039b3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 40039b7:	48 01 d0             	add    %rdx,%rax
 40039ba:	8b 48 04             	mov    0x4(%rax),%ecx
 40039bd:	8b 55 ec             	mov    -0x14(%rbp),%edx
 40039c0:	48 89 d0             	mov    %rdx,%rax
 40039c3:	48 01 c0             	add    %rax,%rax
 40039c6:	48 01 d0             	add    %rdx,%rax
 40039c9:	48 c1 e0 02          	shl    $0x2,%rax
 40039cd:	48 89 c2             	mov    %rax,%rdx
 40039d0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 40039d4:	48 01 d0             	add    %rdx,%rax
 40039d7:	8b 50 04             	mov    0x4(%rax),%edx
 40039da:	8b 45 ec             	mov    -0x14(%rbp),%eax
 40039dd:	83 e8 01             	sub    $0x1,%eax
 40039e0:	89 c6                	mov    %eax,%esi
 40039e2:	48 89 f0             	mov    %rsi,%rax
 40039e5:	48 01 c0             	add    %rax,%rax
 40039e8:	48 01 f0             	add    %rsi,%rax
 40039eb:	48 c1 e0 02          	shl    $0x2,%rax
 40039ef:	48 89 c6             	mov    %rax,%rsi
 40039f2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 40039f6:	48 01 f0             	add    %rsi,%rax
 40039f9:	01 ca                	add    %ecx,%edx
 40039fb:	89 50 04             	mov    %edx,0x4(%rax)
                            
                            // 删除当前块
                            linearTBSerialDelete(
 40039fe:	8b 55 ec             	mov    -0x14(%rbp),%edx
 4003a01:	8b 45 ec             	mov    -0x14(%rbp),%eax
 4003a04:	48 8b 4d 98          	mov    -0x68(%rbp),%rcx
 4003a08:	48 8d 79 38          	lea    0x38(%rcx),%rdi
 4003a0c:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
 4003a10:	41 b8 0c 00 00 00    	mov    $0xc,%r8d
 4003a16:	48 89 c6             	mov    %rax,%rsi
 4003a19:	e8 83 4a 00 00       	call   40084a1 <linearTBSerialDelete(unsigned long*, unsigned long, unsigned long, void*, unsigned int)>
                                infotb,
                                sizeof(HeapObjectMetav2)
                            );
                            
                            // 更新对象计数和索引
                            ObjCount--;
 4003a1e:	48 83 6d f8 01       	subq   $0x1,-0x8(%rbp)
                            i--;
 4003a23:	83 6d ec 01          	subl   $0x1,-0x14(%rbp)
                            merged = true;
 4003a27:	c6 45 eb 01          	movb   $0x1,-0x15(%rbp)
                            continue;
 4003a2b:	e9 39 01 00 00       	jmp    4003b69 <kpoolmemmgr_t::kfree(void*)+0x419>
                        }
                    }
                    
                    // 尝试与后一个块合并
                    if (i < ObjCount - 1 && infotb[i+1].type == OBJ_TYPE_FREE) {
 4003a30:	8b 55 ec             	mov    -0x14(%rbp),%edx
 4003a33:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4003a37:	48 83 e8 01          	sub    $0x1,%rax
 4003a3b:	48 39 c2             	cmp    %rax,%rdx
 4003a3e:	0f 83 25 01 00 00    	jae    4003b69 <kpoolmemmgr_t::kfree(void*)+0x419>
 4003a44:	8b 45 ec             	mov    -0x14(%rbp),%eax
 4003a47:	83 c0 01             	add    $0x1,%eax
 4003a4a:	89 c2                	mov    %eax,%edx
 4003a4c:	48 89 d0             	mov    %rdx,%rax
 4003a4f:	48 01 c0             	add    %rax,%rax
 4003a52:	48 01 d0             	add    %rdx,%rax
 4003a55:	48 c1 e0 02          	shl    $0x2,%rax
 4003a59:	48 89 c2             	mov    %rax,%rdx
 4003a5c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4003a60:	48 01 d0             	add    %rdx,%rax
 4003a63:	0f b6 40 08          	movzbl 0x8(%rax),%eax
 4003a67:	3c 0c                	cmp    $0xc,%al
 4003a69:	0f 85 fa 00 00 00    	jne    4003b69 <kpoolmemmgr_t::kfree(void*)+0x419>
                        uint32_t curr_end = infotb[i].offset_in_heap + infotb[i].size;
 4003a6f:	8b 55 ec             	mov    -0x14(%rbp),%edx
 4003a72:	48 89 d0             	mov    %rdx,%rax
 4003a75:	48 01 c0             	add    %rax,%rax
 4003a78:	48 01 d0             	add    %rdx,%rax
 4003a7b:	48 c1 e0 02          	shl    $0x2,%rax
 4003a7f:	48 89 c2             	mov    %rax,%rdx
 4003a82:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4003a86:	48 01 d0             	add    %rdx,%rax
 4003a89:	8b 08                	mov    (%rax),%ecx
 4003a8b:	8b 55 ec             	mov    -0x14(%rbp),%edx
 4003a8e:	48 89 d0             	mov    %rdx,%rax
 4003a91:	48 01 c0             	add    %rax,%rax
 4003a94:	48 01 d0             	add    %rdx,%rax
 4003a97:	48 c1 e0 02          	shl    $0x2,%rax
 4003a9b:	48 89 c2             	mov    %rax,%rdx
 4003a9e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4003aa2:	48 01 d0             	add    %rdx,%rax
 4003aa5:	8b 40 04             	mov    0x4(%rax),%eax
 4003aa8:	01 c8                	add    %ecx,%eax
 4003aaa:	89 45 a8             	mov    %eax,-0x58(%rbp)
                        
                        // 检查偏移量是否连续
                        if (curr_end == infotb[i+1].offset_in_heap) {
 4003aad:	8b 45 ec             	mov    -0x14(%rbp),%eax
 4003ab0:	83 c0 01             	add    $0x1,%eax
 4003ab3:	89 c2                	mov    %eax,%edx
 4003ab5:	48 89 d0             	mov    %rdx,%rax
 4003ab8:	48 01 c0             	add    %rax,%rax
 4003abb:	48 01 d0             	add    %rdx,%rax
 4003abe:	48 c1 e0 02          	shl    $0x2,%rax
 4003ac2:	48 89 c2             	mov    %rax,%rdx
 4003ac5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4003ac9:	48 01 d0             	add    %rdx,%rax
 4003acc:	8b 00                	mov    (%rax),%eax
 4003ace:	39 45 a8             	cmp    %eax,-0x58(%rbp)
 4003ad1:	0f 85 92 00 00 00    	jne    4003b69 <kpoolmemmgr_t::kfree(void*)+0x419>
                            // 合并块
                            infotb[i].size += infotb[i+1].size;
 4003ad7:	8b 55 ec             	mov    -0x14(%rbp),%edx
 4003ada:	48 89 d0             	mov    %rdx,%rax
 4003add:	48 01 c0             	add    %rax,%rax
 4003ae0:	48 01 d0             	add    %rdx,%rax
 4003ae3:	48 c1 e0 02          	shl    $0x2,%rax
 4003ae7:	48 89 c2             	mov    %rax,%rdx
 4003aea:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4003aee:	48 01 d0             	add    %rdx,%rax
 4003af1:	8b 70 04             	mov    0x4(%rax),%esi
 4003af4:	8b 45 ec             	mov    -0x14(%rbp),%eax
 4003af7:	83 c0 01             	add    $0x1,%eax
 4003afa:	89 c2                	mov    %eax,%edx
 4003afc:	48 89 d0             	mov    %rdx,%rax
 4003aff:	48 01 c0             	add    %rax,%rax
 4003b02:	48 01 d0             	add    %rdx,%rax
 4003b05:	48 c1 e0 02          	shl    $0x2,%rax
 4003b09:	48 89 c2             	mov    %rax,%rdx
 4003b0c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4003b10:	48 01 d0             	add    %rdx,%rax
 4003b13:	8b 48 04             	mov    0x4(%rax),%ecx
 4003b16:	8b 55 ec             	mov    -0x14(%rbp),%edx
 4003b19:	48 89 d0             	mov    %rdx,%rax
 4003b1c:	48 01 c0             	add    %rax,%rax
 4003b1f:	48 01 d0             	add    %rdx,%rax
 4003b22:	48 c1 e0 02          	shl    $0x2,%rax
 4003b26:	48 89 c2             	mov    %rax,%rdx
 4003b29:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4003b2d:	48 01 d0             	add    %rdx,%rax
 4003b30:	8d 14 0e             	lea    (%rsi,%rcx,1),%edx
 4003b33:	89 50 04             	mov    %edx,0x4(%rax)
                            
                            // 删除后一个块
                            linearTBSerialDelete(
                                &first_static_heap.heap.metaInfo.header.objMetaCount,
                                i+1,
                                i+1,
 4003b36:	8b 45 ec             	mov    -0x14(%rbp),%eax
 4003b39:	83 c0 01             	add    $0x1,%eax
                            linearTBSerialDelete(
 4003b3c:	89 c2                	mov    %eax,%edx
                                i+1,
 4003b3e:	8b 45 ec             	mov    -0x14(%rbp),%eax
 4003b41:	83 c0 01             	add    $0x1,%eax
                            linearTBSerialDelete(
 4003b44:	89 c6                	mov    %eax,%esi
 4003b46:	48 8b 45 98          	mov    -0x68(%rbp),%rax
 4003b4a:	48 8d 78 38          	lea    0x38(%rax),%rdi
 4003b4e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4003b52:	41 b8 0c 00 00 00    	mov    $0xc,%r8d
 4003b58:	48 89 c1             	mov    %rax,%rcx
 4003b5b:	e8 41 49 00 00       	call   40084a1 <linearTBSerialDelete(unsigned long*, unsigned long, unsigned long, void*, unsigned int)>
                                infotb,
                                sizeof(HeapObjectMetav2)
                            );
                            
                            // 更新对象计数
                            ObjCount--;
 4003b60:	48 83 6d f8 01       	subq   $0x1,-0x8(%rbp)
                            merged = true;
 4003b65:	c6 45 eb 01          	movb   $0x1,-0x15(%rbp)
                do {
 4003b69:	80 7d eb 00          	cmpb   $0x0,-0x15(%rbp)
 4003b6d:	0f 85 82 fd ff ff    	jne    40038f5 <kpoolmemmgr_t::kfree(void*)+0x1a5>
                        }
                    }
                } while (merged);
                
                return; // 释放完成
 4003b73:	eb 11                	jmp    4003b86 <kpoolmemmgr_t::kfree(void*)+0x436>
        for (uint32_t i = 0; i < ObjCount; i++) {
 4003b75:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
 4003b79:	8b 45 ec             	mov    -0x14(%rbp),%eax
 4003b7c:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
 4003b80:	0f 82 84 fc ff ff    	jb     400380a <kpoolmemmgr_t::kfree(void*)+0xba>
        // 如果没有找到匹配的对象，可能是错误的释放请求
        // 在内核环境中，可能需要记录错误或触发断言
    } else {
        // ableto_Expand位开启的情况，暂不实现
    }
}
 4003b86:	c9                   	leave
 4003b87:	c3                   	ret

0000000004003b88 <kpoolmemmgr_t::kpoolmemmgr_t()>:

kpoolmemmgr_t::kpoolmemmgr_t() {
 4003b88:	55                   	push   %rbp
 4003b89:	48 89 e5             	mov    %rsp,%rbp
 4003b8c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    first_static_heap.heap.heapSize = first_static_heap.heap.freeSize = 1ULL<<22;
#endif  
#ifdef KERNEL_MODE
    // 获取内核堆的起始地址和大小
    
    first_static_heap.heap.heapStart = (phyaddr_t)&__heap_start;
 4003b90:	48 8d 15 69 c4 1f 00 	lea    0x1fc469(%rip),%rdx        # 4200000 <__heap_start>
 4003b97:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4003b9b:	48 89 50 10          	mov    %rdx,0x10(%rax)
    first_static_heap.heap.heapVStart = (vaddr_t)&__heap_start;
 4003b9f:	48 8d 15 5a c4 1f 00 	lea    0x1fc45a(%rip),%rdx        # 4200000 <__heap_start>
 4003ba6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4003baa:	48 89 50 18          	mov    %rdx,0x18(%rax)
    first_static_heap.heap.heapSize = (uint64_t)(&__heap_end - &__heap_start);
 4003bae:	48 8d 15 4b c4 5f 00 	lea    0x5fc44b(%rip),%rdx        # 4600000 <__heap_end>
 4003bb5:	48 8d 05 44 c4 1f 00 	lea    0x1fc444(%rip),%rax        # 4200000 <__heap_start>
 4003bbc:	48 29 c2             	sub    %rax,%rdx
 4003bbf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4003bc3:	48 89 50 20          	mov    %rdx,0x20(%rax)
    first_static_heap.heap.freeSize = (uint64_t)(&__heap_end - &__heap_start);
 4003bc7:	48 8d 15 32 c4 5f 00 	lea    0x5fc432(%rip),%rdx        # 4600000 <__heap_end>
 4003bce:	48 8d 05 2b c4 1f 00 	lea    0x1fc42b(%rip),%rax        # 4200000 <__heap_start>
 4003bd5:	48 29 c2             	sub    %rax,%rdx
 4003bd8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4003bdc:	48 89 50 28          	mov    %rdx,0x28(%rax)
#endif    
    // 初始化status为HEAP_BLOCK_FREE状态
    first_static_heap.heap.status.block_exist = 0;
 4003be0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4003be4:	0f b6 50 50          	movzbl 0x50(%rax),%edx
 4003be8:	83 e2 fe             	and    $0xfffffffe,%edx
 4003beb:	88 50 50             	mov    %dl,0x50(%rax)
    first_static_heap.heap.status.block_tb_full = 0;
 4003bee:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4003bf2:	0f b6 50 50          	movzbl 0x50(%rax),%edx
 4003bf6:	83 e2 fd             	and    $0xfffffffd,%edx
 4003bf9:	88 50 50             	mov    %dl,0x50(%rax)
    first_static_heap.heap.status.block_full = 0;
 4003bfc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4003c00:	0f b6 50 50          	movzbl 0x50(%rax),%edx
 4003c04:	83 e2 fb             	and    $0xfffffffb,%edx
 4003c07:	88 50 50             	mov    %dl,0x50(%rax)
    first_static_heap.heap.status.block_reserved = 0;
 4003c0a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4003c0e:	0f b6 50 50          	movzbl 0x50(%rax),%edx
 4003c12:	83 e2 f7             	and    $0xfffffff7,%edx
 4003c15:	88 50 50             	mov    %dl,0x50(%rax)
    first_static_heap.heap.status.block_merged = 0;
 4003c18:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4003c1c:	0f b6 50 50          	movzbl 0x50(%rax),%edx
 4003c20:	83 e2 ef             	and    $0xffffffef,%edx
 4003c23:	88 50 50             	mov    %dl,0x50(%rax)
    
    // 初始化元信息数组
    first_static_heap.heap.metaInfo.header.magic = 0x48504D41; // "HPM A"
 4003c26:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4003c2a:	c7 40 30 41 4d 50 48 	movl   $0x48504d41,0x30(%rax)
    first_static_heap.heap.metaInfo.header.version = 2; // 版本改为2，表示使用v2元信息
 4003c31:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4003c35:	c7 40 34 02 00 00 00 	movl   $0x2,0x34(%rax)
    first_static_heap.heap.metaInfo.header.objMetaCount = 1;  // 初始时有一个空闲对象
 4003c3c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4003c40:	48 c7 40 38 01 00 00 	movq   $0x1,0x38(%rax)
 4003c47:	00 
    first_static_heap.heap.metaInfo.header.objMetaMaxCount = FirstStaticHeapMaxObjCount;
 4003c48:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4003c4c:	c7 40 40 00 10 00 00 	movl   $0x1000,0x40(%rax)
    first_static_heap.heap.metaInfo.objMetaTable = objMetaTable_for_FirstStaticHeap;
 4003c53:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4003c57:	48 8d 15 a2 c4 7f 00 	lea    0x7fc4a2(%rip),%rdx        # 4800100 <objMetaTable_for_FirstStaticHeap>
 4003c5e:	48 89 50 48          	mov    %rdx,0x48(%rax)
    
    // 初始化第一个元信息项（整个堆作为空闲块）
    objMetaTable_for_FirstStaticHeap[0].offset_in_heap = 0;
 4003c62:	c7 05 94 c4 7f 00 00 	movl   $0x0,0x7fc494(%rip)        # 4800100 <objMetaTable_for_FirstStaticHeap>
 4003c69:	00 00 00 
    objMetaTable_for_FirstStaticHeap[0].size = first_static_heap.heap.heapSize;
 4003c6c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4003c70:	48 8b 40 20          	mov    0x20(%rax),%rax
 4003c74:	89 05 8a c4 7f 00    	mov    %eax,0x7fc48a(%rip)        # 4800104 <objMetaTable_for_FirstStaticHeap+0x4>
    objMetaTable_for_FirstStaticHeap[0].type = OBJ_TYPE_FREE;
 4003c7a:	c6 05 87 c4 7f 00 0c 	movb   $0xc,0x7fc487(%rip)        # 4800108 <objMetaTable_for_FirstStaticHeap+0x8>
    
    // 初始化链表指针
    first_static_heap.prev = nullptr;
 4003c81:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4003c85:	48 c7 40 58 00 00 00 	movq   $0x0,0x58(%rax)
 4003c8c:	00 
    first_static_heap.next = nullptr;
 4003c8d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4003c91:	48 c7 40 60 00 00 00 	movq   $0x0,0x60(%rax)
 4003c98:	00 
    last_heap_node = &first_static_heap;
 4003c99:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4003c9d:	48 8d 50 10          	lea    0x10(%rax),%rdx
 4003ca1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4003ca5:	48 89 50 68          	mov    %rdx,0x68(%rax)
    
    // 初始化flags结构
    kpoolmemmgr_flags.ableto_Expand = 0;
 4003ca9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4003cad:	0f b6 10             	movzbl (%rax),%edx
 4003cb0:	83 e2 fe             	and    $0xfffffffe,%edx
 4003cb3:	88 10                	mov    %dl,(%rax)
    kpoolmemmgr_flags.heap_vaddr_enabled = 1; // 默认启用虚拟地址
 4003cb5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4003cb9:	0f b6 10             	movzbl (%rax),%edx
 4003cbc:	83 ca 02             	or     $0x2,%edx
 4003cbf:	88 10                	mov    %dl,(%rax)
    kpoolmemmgr_flags.alignment = 3; // 默认8字节对齐 (2^3=8)
 4003cc1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4003cc5:	0f b7 10             	movzwl (%rax),%edx
 4003cc8:	66 81 e2 03 fc       	and    $0xfc03,%dx
 4003ccd:	83 ca 0c             	or     $0xc,%edx
 4003cd0:	66 89 10             	mov    %dx,(%rax)
    
    HCB_count = 1;
 4003cd3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4003cd7:	48 c7 40 08 01 00 00 	movq   $0x1,0x8(%rax)
 4003cde:	00 
}
 4003cdf:	90                   	nop
 4003ce0:	5d                   	pop    %rbp
 4003ce1:	c3                   	ret

0000000004003ce2 <kpoolmemmgr_t::print_hcb_status(HCB_chainlist_node*)>:
// 实现新的成员函数
void kpoolmemmgr_t::print_hcb_status(HCB_chainlist_node* node) {
 4003ce2:	55                   	push   %rbp
 4003ce3:	48 89 e5             	mov    %rsp,%rbp
 4003ce6:	48 83 ec 20          	sub    $0x20,%rsp
 4003cea:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
 4003cee:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
    const char* status_str = "UNKNOWN";
 4003cf2:	48 8d 05 b9 bf 00 00 	lea    0xbfb9(%rip),%rax        # 400fcb2 <FirstStaticHeapMaxObjCount+0x2>
 4003cf9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    
    // 直接根据hcb.status里面的各个位进行判断
    if (node->heap.heapSize == node->heap.freeSize) {
 4003cfd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4003d01:	48 8b 50 10          	mov    0x10(%rax),%rdx
 4003d05:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4003d09:	48 8b 40 18          	mov    0x18(%rax),%rax
 4003d0d:	48 39 c2             	cmp    %rax,%rdx
 4003d10:	75 10                	jne    4003d22 <kpoolmemmgr_t::print_hcb_status(HCB_chainlist_node*)+0x40>
        status_str = "FREE";  // HEAP_BLOCK_FREE = 0
 4003d12:	48 8d 05 a1 bf 00 00 	lea    0xbfa1(%rip),%rax        # 400fcba <FirstStaticHeapMaxObjCount+0xa>
 4003d19:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
 4003d1d:	e9 e5 00 00 00       	jmp    4003e07 <kpoolmemmgr_t::print_hcb_status(HCB_chainlist_node*)+0x125>
    } 
    else if (node->heap.status.block_exist && 
 4003d22:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4003d26:	0f b6 40 40          	movzbl 0x40(%rax),%eax
 4003d2a:	83 e0 01             	and    $0x1,%eax
 4003d2d:	84 c0                	test   %al,%al
 4003d2f:	74 2c                	je     4003d5d <kpoolmemmgr_t::print_hcb_status(HCB_chainlist_node*)+0x7b>
             
             !node->heap.status.block_full &&
 4003d31:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4003d35:	0f b6 40 40          	movzbl 0x40(%rax),%eax
 4003d39:	83 e0 04             	and    $0x4,%eax
    else if (node->heap.status.block_exist && 
 4003d3c:	84 c0                	test   %al,%al
 4003d3e:	75 1d                	jne    4003d5d <kpoolmemmgr_t::print_hcb_status(HCB_chainlist_node*)+0x7b>
             node->heap.freeSize!=0
 4003d40:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4003d44:	48 8b 40 18          	mov    0x18(%rax),%rax
             !node->heap.status.block_full &&
 4003d48:	48 85 c0             	test   %rax,%rax
 4003d4b:	74 10                	je     4003d5d <kpoolmemmgr_t::print_hcb_status(HCB_chainlist_node*)+0x7b>
            ) {
        status_str = "USED";  // HEAP_BLOCK_PARTIAL_USED = 1
 4003d4d:	48 8d 05 6b bf 00 00 	lea    0xbf6b(%rip),%rax        # 400fcbf <FirstStaticHeapMaxObjCount+0xf>
 4003d54:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
 4003d58:	e9 aa 00 00 00       	jmp    4003e07 <kpoolmemmgr_t::print_hcb_status(HCB_chainlist_node*)+0x125>
    }
    else if (node->heap.status.block_exist && 
 4003d5d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4003d61:	0f b6 40 40          	movzbl 0x40(%rax),%eax
 4003d65:	83 e0 01             	and    $0x1,%eax
 4003d68:	84 c0                	test   %al,%al
 4003d6a:	74 1c                	je     4003d88 <kpoolmemmgr_t::print_hcb_status(HCB_chainlist_node*)+0xa6>

             node->heap.status.block_reserved) {
 4003d6c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4003d70:	0f b6 40 40          	movzbl 0x40(%rax),%eax
 4003d74:	83 e0 08             	and    $0x8,%eax
    else if (node->heap.status.block_exist && 
 4003d77:	84 c0                	test   %al,%al
 4003d79:	74 0d                	je     4003d88 <kpoolmemmgr_t::print_hcb_status(HCB_chainlist_node*)+0xa6>
        status_str = "RESERVED";  // HEAP_BLOCK_RESERVED = 2
 4003d7b:	48 8d 05 42 bf 00 00 	lea    0xbf42(%rip),%rax        # 400fcc4 <FirstStaticHeapMaxObjCount+0x14>
 4003d82:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
 4003d86:	eb 7f                	jmp    4003e07 <kpoolmemmgr_t::print_hcb_status(HCB_chainlist_node*)+0x125>
    }
    else if (node->heap.status.block_exist && 
 4003d88:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4003d8c:	0f b6 40 40          	movzbl 0x40(%rax),%eax
 4003d90:	83 e0 01             	and    $0x1,%eax
 4003d93:	84 c0                	test   %al,%al
 4003d95:	74 1c                	je     4003db3 <kpoolmemmgr_t::print_hcb_status(HCB_chainlist_node*)+0xd1>
             node->heap.status.block_merged) {
 4003d97:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4003d9b:	0f b6 40 40          	movzbl 0x40(%rax),%eax
 4003d9f:	83 e0 10             	and    $0x10,%eax
    else if (node->heap.status.block_exist && 
 4003da2:	84 c0                	test   %al,%al
 4003da4:	74 0d                	je     4003db3 <kpoolmemmgr_t::print_hcb_status(HCB_chainlist_node*)+0xd1>
        status_str = "MERGED";  // HEAP_BLOCK_MERGED = 3
 4003da6:	48 8d 05 20 bf 00 00 	lea    0xbf20(%rip),%rax        # 400fccd <FirstStaticHeapMaxObjCount+0x1d>
 4003dad:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
 4003db1:	eb 54                	jmp    4003e07 <kpoolmemmgr_t::print_hcb_status(HCB_chainlist_node*)+0x125>
    }
    else if (node->heap.status.block_exist && 
 4003db3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4003db7:	0f b6 40 40          	movzbl 0x40(%rax),%eax
 4003dbb:	83 e0 01             	and    $0x1,%eax
 4003dbe:	84 c0                	test   %al,%al
 4003dc0:	74 1c                	je     4003dde <kpoolmemmgr_t::print_hcb_status(HCB_chainlist_node*)+0xfc>
             node->heap.status.block_full
 4003dc2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4003dc6:	0f b6 40 40          	movzbl 0x40(%rax),%eax
 4003dca:	83 e0 04             	and    $0x4,%eax
    else if (node->heap.status.block_exist && 
 4003dcd:	84 c0                	test   %al,%al
 4003dcf:	74 0d                	je     4003dde <kpoolmemmgr_t::print_hcb_status(HCB_chainlist_node*)+0xfc>
            ) {
        status_str = "FULL";  // HEAP_BLOCK_FULL = 4
 4003dd1:	48 8d 05 fc be 00 00 	lea    0xbefc(%rip),%rax        # 400fcd4 <FirstStaticHeapMaxObjCount+0x24>
 4003dd8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
 4003ddc:	eb 29                	jmp    4003e07 <kpoolmemmgr_t::print_hcb_status(HCB_chainlist_node*)+0x125>
    }else if (node->heap.status.block_exist && 
 4003dde:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4003de2:	0f b6 40 40          	movzbl 0x40(%rax),%eax
 4003de6:	83 e0 01             	and    $0x1,%eax
 4003de9:	84 c0                	test   %al,%al
 4003deb:	74 1a                	je     4003e07 <kpoolmemmgr_t::print_hcb_status(HCB_chainlist_node*)+0x125>
             node->heap.status.block_tb_full)
 4003ded:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4003df1:	0f b6 40 40          	movzbl 0x40(%rax),%eax
 4003df5:	83 e0 02             	and    $0x2,%eax
    }else if (node->heap.status.block_exist && 
 4003df8:	84 c0                	test   %al,%al
 4003dfa:	74 0b                	je     4003e07 <kpoolmemmgr_t::print_hcb_status(HCB_chainlist_node*)+0x125>
    {
        status_str = "TB_FULL";
 4003dfc:	48 8d 05 d6 be 00 00 	lea    0xbed6(%rip),%rax        # 400fcd9 <FirstStaticHeapMaxObjCount+0x29>
 4003e03:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    }
    
    
    kputsSecure("Heap Control Block Status:");
 4003e07:	48 8d 05 d3 be 00 00 	lea    0xbed3(%rip),%rax        # 400fce1 <FirstStaticHeapMaxObjCount+0x31>
 4003e0e:	48 89 c7             	mov    %rax,%rdi
 4003e11:	e8 af 63 00 00       	call   400a1c5 <kputsSecure>
    kputsSecure("\n  Physical Start: 0x");
 4003e16:	48 8d 05 df be 00 00 	lea    0xbedf(%rip),%rax        # 400fcfc <FirstStaticHeapMaxObjCount+0x4c>
 4003e1d:	48 89 c7             	mov    %rax,%rdi
 4003e20:	e8 a0 63 00 00       	call   400a1c5 <kputsSecure>
    kpnumSecure(&node->heap.heapStart, UNHEX, sizeof(phyaddr_t));
 4003e25:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4003e29:	ba 08 00 00 00       	mov    $0x8,%edx
 4003e2e:	be 05 00 00 00       	mov    $0x5,%esi
 4003e33:	48 89 c7             	mov    %rax,%rdi
 4003e36:	e8 cb 64 00 00       	call   400a306 <kpnumSecure>
    
    kputsSecure("\n  Virtual Start: 0x");
 4003e3b:	48 8d 05 d0 be 00 00 	lea    0xbed0(%rip),%rax        # 400fd12 <FirstStaticHeapMaxObjCount+0x62>
 4003e42:	48 89 c7             	mov    %rax,%rdi
 4003e45:	e8 7b 63 00 00       	call   400a1c5 <kputsSecure>
    kpnumSecure(&node->heap.heapVStart, UNHEX, sizeof(vaddr_t));
 4003e4a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4003e4e:	48 83 c0 08          	add    $0x8,%rax
 4003e52:	ba 08 00 00 00       	mov    $0x8,%edx
 4003e57:	be 05 00 00 00       	mov    $0x5,%esi
 4003e5c:	48 89 c7             	mov    %rax,%rdi
 4003e5f:	e8 a2 64 00 00       	call   400a306 <kpnumSecure>
    
    kputsSecure("\n  Total Size: ");
 4003e64:	48 8d 05 bc be 00 00 	lea    0xbebc(%rip),%rax        # 400fd27 <FirstStaticHeapMaxObjCount+0x77>
 4003e6b:	48 89 c7             	mov    %rax,%rdi
 4003e6e:	e8 52 63 00 00       	call   400a1c5 <kputsSecure>
    kpnumSecure(&node->heap.heapSize, UNDEC, 0);
 4003e73:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4003e77:	48 83 c0 10          	add    $0x10,%rax
 4003e7b:	ba 00 00 00 00       	mov    $0x0,%edx
 4003e80:	be 03 00 00 00       	mov    $0x3,%esi
 4003e85:	48 89 c7             	mov    %rax,%rdi
 4003e88:	e8 79 64 00 00       	call   400a306 <kpnumSecure>
    kputsSecure(" bytes");
 4003e8d:	48 8d 05 a3 be 00 00 	lea    0xbea3(%rip),%rax        # 400fd37 <FirstStaticHeapMaxObjCount+0x87>
 4003e94:	48 89 c7             	mov    %rax,%rdi
 4003e97:	e8 29 63 00 00       	call   400a1c5 <kputsSecure>
    
    kputsSecure("\n  Free Size: ");
 4003e9c:	48 8d 05 9b be 00 00 	lea    0xbe9b(%rip),%rax        # 400fd3e <FirstStaticHeapMaxObjCount+0x8e>
 4003ea3:	48 89 c7             	mov    %rax,%rdi
 4003ea6:	e8 1a 63 00 00       	call   400a1c5 <kputsSecure>
    kpnumSecure(&node->heap.freeSize, UNDEC, 0);
 4003eab:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4003eaf:	48 83 c0 18          	add    $0x18,%rax
 4003eb3:	ba 00 00 00 00       	mov    $0x0,%edx
 4003eb8:	be 03 00 00 00       	mov    $0x3,%esi
 4003ebd:	48 89 c7             	mov    %rax,%rdi
 4003ec0:	e8 41 64 00 00       	call   400a306 <kpnumSecure>
    kputsSecure(" bytes");
 4003ec5:	48 8d 05 6b be 00 00 	lea    0xbe6b(%rip),%rax        # 400fd37 <FirstStaticHeapMaxObjCount+0x87>
 4003ecc:	48 89 c7             	mov    %rax,%rdi
 4003ecf:	e8 f1 62 00 00       	call   400a1c5 <kputsSecure>
    
    kputsSecure("\n  Status: ");
 4003ed4:	48 8d 05 72 be 00 00 	lea    0xbe72(%rip),%rax        # 400fd4d <FirstStaticHeapMaxObjCount+0x9d>
 4003edb:	48 89 c7             	mov    %rax,%rdi
 4003ede:	e8 e2 62 00 00       	call   400a1c5 <kputsSecure>
    kputsSecure(const_cast<char*>(status_str));
 4003ee3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4003ee7:	48 89 c7             	mov    %rax,%rdi
 4003eea:	e8 d6 62 00 00       	call   400a1c5 <kputsSecure>
    
    kputsSecure("\n  Meta Entries: ");
 4003eef:	48 8d 05 63 be 00 00 	lea    0xbe63(%rip),%rax        # 400fd59 <FirstStaticHeapMaxObjCount+0xa9>
 4003ef6:	48 89 c7             	mov    %rax,%rdi
 4003ef9:	e8 c7 62 00 00       	call   400a1c5 <kputsSecure>
    uint64_t count = node->heap.metaInfo.header.objMetaCount;
 4003efe:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4003f02:	48 8b 40 28          	mov    0x28(%rax),%rax
 4003f06:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    kpnumSecure(&count, UNDEC, 0);
 4003f0a:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
 4003f0e:	ba 00 00 00 00       	mov    $0x0,%edx
 4003f13:	be 03 00 00 00       	mov    $0x3,%esi
 4003f18:	48 89 c7             	mov    %rax,%rdi
 4003f1b:	e8 e6 63 00 00       	call   400a306 <kpnumSecure>
    kputsSecure("/");
 4003f20:	48 8d 05 44 be 00 00 	lea    0xbe44(%rip),%rax        # 400fd6b <FirstStaticHeapMaxObjCount+0xbb>
 4003f27:	48 89 c7             	mov    %rax,%rdi
 4003f2a:	e8 96 62 00 00       	call   400a1c5 <kputsSecure>
    kpnumSecure(&node->heap.metaInfo.header.objMetaMaxCount, UNDEC, 0);
 4003f2f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4003f33:	48 83 c0 30          	add    $0x30,%rax
 4003f37:	ba 00 00 00 00       	mov    $0x0,%edx
 4003f3c:	be 03 00 00 00       	mov    $0x3,%esi
 4003f41:	48 89 c7             	mov    %rax,%rdi
 4003f44:	e8 bd 63 00 00       	call   400a306 <kpnumSecure>
    kputsSecure("\n");
 4003f49:	48 8d 05 1d be 00 00 	lea    0xbe1d(%rip),%rax        # 400fd6d <FirstStaticHeapMaxObjCount+0xbd>
 4003f50:	48 89 c7             	mov    %rax,%rdi
 4003f53:	e8 6d 62 00 00       	call   400a1c5 <kputsSecure>
}
 4003f58:	90                   	nop
 4003f59:	c9                   	leave
 4003f5a:	c3                   	ret

0000000004003f5b <obj_type_to_str(KernelObjType)>:

const char* obj_type_to_str(KernelObjType type) {
 4003f5b:	55                   	push   %rbp
 4003f5c:	48 89 e5             	mov    %rsp,%rbp
 4003f5f:	89 f8                	mov    %edi,%eax
 4003f61:	88 45 fc             	mov    %al,-0x4(%rbp)
    switch(type) {
 4003f64:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
 4003f68:	83 f8 0d             	cmp    $0xd,%eax
 4003f6b:	0f 84 25 01 00 00    	je     4004096 <obj_type_to_str(KernelObjType)+0x13b>
 4003f71:	83 f8 0d             	cmp    $0xd,%eax
 4003f74:	0f 8f 25 01 00 00    	jg     400409f <obj_type_to_str(KernelObjType)+0x144>
 4003f7a:	83 f8 0c             	cmp    $0xc,%eax
 4003f7d:	0f 84 0a 01 00 00    	je     400408d <obj_type_to_str(KernelObjType)+0x132>
 4003f83:	83 f8 0c             	cmp    $0xc,%eax
 4003f86:	0f 8f 13 01 00 00    	jg     400409f <obj_type_to_str(KernelObjType)+0x144>
 4003f8c:	83 f8 0b             	cmp    $0xb,%eax
 4003f8f:	0f 84 ef 00 00 00    	je     4004084 <obj_type_to_str(KernelObjType)+0x129>
 4003f95:	83 f8 0b             	cmp    $0xb,%eax
 4003f98:	0f 8f 01 01 00 00    	jg     400409f <obj_type_to_str(KernelObjType)+0x144>
 4003f9e:	83 f8 0a             	cmp    $0xa,%eax
 4003fa1:	0f 84 d4 00 00 00    	je     400407b <obj_type_to_str(KernelObjType)+0x120>
 4003fa7:	83 f8 0a             	cmp    $0xa,%eax
 4003faa:	0f 8f ef 00 00 00    	jg     400409f <obj_type_to_str(KernelObjType)+0x144>
 4003fb0:	83 f8 09             	cmp    $0x9,%eax
 4003fb3:	0f 84 b9 00 00 00    	je     4004072 <obj_type_to_str(KernelObjType)+0x117>
 4003fb9:	83 f8 09             	cmp    $0x9,%eax
 4003fbc:	0f 8f dd 00 00 00    	jg     400409f <obj_type_to_str(KernelObjType)+0x144>
 4003fc2:	83 f8 08             	cmp    $0x8,%eax
 4003fc5:	0f 84 9e 00 00 00    	je     4004069 <obj_type_to_str(KernelObjType)+0x10e>
 4003fcb:	83 f8 08             	cmp    $0x8,%eax
 4003fce:	0f 8f cb 00 00 00    	jg     400409f <obj_type_to_str(KernelObjType)+0x144>
 4003fd4:	83 f8 07             	cmp    $0x7,%eax
 4003fd7:	0f 84 83 00 00 00    	je     4004060 <obj_type_to_str(KernelObjType)+0x105>
 4003fdd:	83 f8 07             	cmp    $0x7,%eax
 4003fe0:	0f 8f b9 00 00 00    	jg     400409f <obj_type_to_str(KernelObjType)+0x144>
 4003fe6:	83 f8 06             	cmp    $0x6,%eax
 4003fe9:	74 6c                	je     4004057 <obj_type_to_str(KernelObjType)+0xfc>
 4003feb:	83 f8 06             	cmp    $0x6,%eax
 4003fee:	0f 8f ab 00 00 00    	jg     400409f <obj_type_to_str(KernelObjType)+0x144>
 4003ff4:	83 f8 05             	cmp    $0x5,%eax
 4003ff7:	74 55                	je     400404e <obj_type_to_str(KernelObjType)+0xf3>
 4003ff9:	83 f8 05             	cmp    $0x5,%eax
 4003ffc:	0f 8f 9d 00 00 00    	jg     400409f <obj_type_to_str(KernelObjType)+0x144>
 4004002:	83 f8 04             	cmp    $0x4,%eax
 4004005:	74 3e                	je     4004045 <obj_type_to_str(KernelObjType)+0xea>
 4004007:	83 f8 04             	cmp    $0x4,%eax
 400400a:	0f 8f 8f 00 00 00    	jg     400409f <obj_type_to_str(KernelObjType)+0x144>
 4004010:	83 f8 03             	cmp    $0x3,%eax
 4004013:	74 27                	je     400403c <obj_type_to_str(KernelObjType)+0xe1>
 4004015:	83 f8 03             	cmp    $0x3,%eax
 4004018:	0f 8f 81 00 00 00    	jg     400409f <obj_type_to_str(KernelObjType)+0x144>
 400401e:	83 f8 01             	cmp    $0x1,%eax
 4004021:	74 07                	je     400402a <obj_type_to_str(KernelObjType)+0xcf>
 4004023:	83 f8 02             	cmp    $0x2,%eax
 4004026:	74 0b                	je     4004033 <obj_type_to_str(KernelObjType)+0xd8>
 4004028:	eb 75                	jmp    400409f <obj_type_to_str(KernelObjType)+0x144>
        case OBJ_TYPE_TASK: return "TASK";
 400402a:	48 8d 05 3e bd 00 00 	lea    0xbd3e(%rip),%rax        # 400fd6f <FirstStaticHeapMaxObjCount+0xbf>
 4004031:	eb 73                	jmp    40040a6 <obj_type_to_str(KernelObjType)+0x14b>
        case OBJ_TYPE_THREAD: return "THREAD";
 4004033:	48 8d 05 3a bd 00 00 	lea    0xbd3a(%rip),%rax        # 400fd74 <FirstStaticHeapMaxObjCount+0xc4>
 400403a:	eb 6a                	jmp    40040a6 <obj_type_to_str(KernelObjType)+0x14b>
        case OBJ_TYPE_MUTEX: return "MUTEX";
 400403c:	48 8d 05 38 bd 00 00 	lea    0xbd38(%rip),%rax        # 400fd7b <FirstStaticHeapMaxObjCount+0xcb>
 4004043:	eb 61                	jmp    40040a6 <obj_type_to_str(KernelObjType)+0x14b>
        case OBJ_TYPE_SEMAPHORE: return "SEM";
 4004045:	48 8d 05 35 bd 00 00 	lea    0xbd35(%rip),%rax        # 400fd81 <FirstStaticHeapMaxObjCount+0xd1>
 400404c:	eb 58                	jmp    40040a6 <obj_type_to_str(KernelObjType)+0x14b>
        case OBJ_TYPE_EVENT: return "EVENT";
 400404e:	48 8d 05 30 bd 00 00 	lea    0xbd30(%rip),%rax        # 400fd85 <FirstStaticHeapMaxObjCount+0xd5>
 4004055:	eb 4f                	jmp    40040a6 <obj_type_to_str(KernelObjType)+0x14b>
        case OBJ_TYPE_QUEUE: return "QUEUE";
 4004057:	48 8d 05 2d bd 00 00 	lea    0xbd2d(%rip),%rax        # 400fd8b <FirstStaticHeapMaxObjCount+0xdb>
 400405e:	eb 46                	jmp    40040a6 <obj_type_to_str(KernelObjType)+0x14b>
        case OBJ_TYPE_TIMER: return "TIMER";
 4004060:	48 8d 05 2a bd 00 00 	lea    0xbd2a(%rip),%rax        # 400fd91 <FirstStaticHeapMaxObjCount+0xe1>
 4004067:	eb 3d                	jmp    40040a6 <obj_type_to_str(KernelObjType)+0x14b>
        case OBJ_TYPE_DEVICE: return "DEVICE";
 4004069:	48 8d 05 27 bd 00 00 	lea    0xbd27(%rip),%rax        # 400fd97 <FirstStaticHeapMaxObjCount+0xe7>
 4004070:	eb 34                	jmp    40040a6 <obj_type_to_str(KernelObjType)+0x14b>
        case OBJ_TYPE_FILE: return "FILE";
 4004072:	48 8d 05 25 bd 00 00 	lea    0xbd25(%rip),%rax        # 400fd9e <FirstStaticHeapMaxObjCount+0xee>
 4004079:	eb 2b                	jmp    40040a6 <obj_type_to_str(KernelObjType)+0x14b>
        case OBJ_TYPE_SHM: return "SHM";
 400407b:	48 8d 05 21 bd 00 00 	lea    0xbd21(%rip),%rax        # 400fda3 <FirstStaticHeapMaxObjCount+0xf3>
 4004082:	eb 22                	jmp    40040a6 <obj_type_to_str(KernelObjType)+0x14b>
        case OBJ_TYPE_NORMAL: return "NORMAL";
 4004084:	48 8d 05 1c bd 00 00 	lea    0xbd1c(%rip),%rax        # 400fda7 <FirstStaticHeapMaxObjCount+0xf7>
 400408b:	eb 19                	jmp    40040a6 <obj_type_to_str(KernelObjType)+0x14b>
        case OBJ_TYPE_FREE: return "FREE";
 400408d:	48 8d 05 26 bc 00 00 	lea    0xbc26(%rip),%rax        # 400fcba <FirstStaticHeapMaxObjCount+0xa>
 4004094:	eb 10                	jmp    40040a6 <obj_type_to_str(KernelObjType)+0x14b>
        case OBJ_TYPE_FIXED: return "FIXED";
 4004096:	48 8d 05 11 bd 00 00 	lea    0xbd11(%rip),%rax        # 400fdae <FirstStaticHeapMaxObjCount+0xfe>
 400409d:	eb 07                	jmp    40040a6 <obj_type_to_str(KernelObjType)+0x14b>
        default: return "UNKNOWN";
 400409f:	48 8d 05 0c bc 00 00 	lea    0xbc0c(%rip),%rax        # 400fcb2 <FirstStaticHeapMaxObjCount+0x2>
    }
}
 40040a6:	5d                   	pop    %rbp
 40040a7:	c3                   	ret

00000000040040a8 <kpoolmemmgr_t::print_meta_table(HCB_chainlist_node*)>:

void kpoolmemmgr_t::print_meta_table(HCB_chainlist_node* node) {
 40040a8:	55                   	push   %rbp
 40040a9:	48 89 e5             	mov    %rsp,%rbp
 40040ac:	48 83 ec 50          	sub    $0x50,%rsp
 40040b0:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
 40040b4:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
    HeapMetaInfoArray* meta = &node->heap.metaInfo;
 40040b8:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
 40040bc:	48 83 c0 20          	add    $0x20,%rax
 40040c0:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    uint64_t count = meta->header.objMetaCount;
 40040c4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 40040c8:	48 8b 40 08          	mov    0x8(%rax),%rax
 40040cc:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    
    kputsSecure("\nHeap Meta Table (");
 40040d0:	48 8d 05 dd bc 00 00 	lea    0xbcdd(%rip),%rax        # 400fdb4 <FirstStaticHeapMaxObjCount+0x104>
 40040d7:	48 89 c7             	mov    %rax,%rdi
 40040da:	e8 e6 60 00 00       	call   400a1c5 <kputsSecure>
    kpnumSecure(&count, UNDEC, 0);
 40040df:	48 8d 45 d8          	lea    -0x28(%rbp),%rax
 40040e3:	ba 00 00 00 00       	mov    $0x0,%edx
 40040e8:	be 03 00 00 00       	mov    $0x3,%esi
 40040ed:	48 89 c7             	mov    %rax,%rdi
 40040f0:	e8 11 62 00 00       	call   400a306 <kpnumSecure>
    kputsSecure(" entries):\n");
 40040f5:	48 8d 05 cb bc 00 00 	lea    0xbccb(%rip),%rax        # 400fdc7 <FirstStaticHeapMaxObjCount+0x117>
 40040fc:	48 89 c7             	mov    %rax,%rdi
 40040ff:	e8 c1 60 00 00       	call   400a1c5 <kputsSecure>
    
    kputsSecure("IDX | PHYS ADDR    | SIZE       | TYPE    | VADDR\n");
 4004104:	48 8d 05 cd bc 00 00 	lea    0xbccd(%rip),%rax        # 400fdd8 <FirstStaticHeapMaxObjCount+0x128>
 400410b:	48 89 c7             	mov    %rax,%rdi
 400410e:	e8 b2 60 00 00       	call   400a1c5 <kputsSecure>
    kputsSecure("----+-------------+------------+---------+------------\n");
 4004113:	48 8d 05 f6 bc 00 00 	lea    0xbcf6(%rip),%rax        # 400fe10 <FirstStaticHeapMaxObjCount+0x160>
 400411a:	48 89 c7             	mov    %rax,%rdi
 400411d:	e8 a3 60 00 00       	call   400a1c5 <kputsSecure>
    uint64_t phyaddr_temp = 0;
 4004122:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
 4004129:	00 
    uint64_t vaddr_temp = 0;
 400412a:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
 4004131:	00 
    for(uint32_t i = 0; i < count; i++) {
 4004132:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%rbp)
 4004139:	e9 59 01 00 00       	jmp    4004297 <kpoolmemmgr_t::print_meta_table(HCB_chainlist_node*)+0x1ef>
        HeapObjectMetav2* entry = &meta->objMetaTable[i];
 400413e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 4004142:	48 8b 50 18          	mov    0x18(%rax),%rdx
 4004146:	8b 45 c4             	mov    -0x3c(%rbp),%eax
 4004149:	89 c1                	mov    %eax,%ecx
 400414b:	48 89 c8             	mov    %rcx,%rax
 400414e:	48 01 c0             	add    %rax,%rax
 4004151:	48 01 c8             	add    %rcx,%rax
 4004154:	48 c1 e0 02          	shl    $0x2,%rax
 4004158:	48 01 d0             	add    %rdx,%rax
 400415b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
        
        // 打印索引
        kpnumSecure(&i, UNDEC, 3);
 400415f:	48 8d 45 c4          	lea    -0x3c(%rbp),%rax
 4004163:	ba 03 00 00 00       	mov    $0x3,%edx
 4004168:	be 03 00 00 00       	mov    $0x3,%esi
 400416d:	48 89 c7             	mov    %rax,%rdi
 4004170:	e8 91 61 00 00       	call   400a306 <kpnumSecure>
        kputsSecure(" | ");
 4004175:	48 8d 05 cc bc 00 00 	lea    0xbccc(%rip),%rax        # 400fe48 <FirstStaticHeapMaxObjCount+0x198>
 400417c:	48 89 c7             	mov    %rax,%rdi
 400417f:	e8 41 60 00 00       	call   400a1c5 <kputsSecure>
        
        // 物理地址
        phyaddr_temp = entry->offset_in_heap+node->heap.heapStart;
 4004184:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4004188:	8b 00                	mov    (%rax),%eax
 400418a:	89 c2                	mov    %eax,%edx
 400418c:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
 4004190:	48 8b 00             	mov    (%rax),%rax
 4004193:	48 01 d0             	add    %rdx,%rax
 4004196:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
        kpnumSecure(&phyaddr_temp, UNHEX, sizeof(phyaddr_t));
 400419a:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
 400419e:	ba 08 00 00 00       	mov    $0x8,%edx
 40041a3:	be 05 00 00 00       	mov    $0x5,%esi
 40041a8:	48 89 c7             	mov    %rax,%rdi
 40041ab:	e8 56 61 00 00       	call   400a306 <kpnumSecure>
        kputsSecure(" | ");
 40041b0:	48 8d 05 91 bc 00 00 	lea    0xbc91(%rip),%rax        # 400fe48 <FirstStaticHeapMaxObjCount+0x198>
 40041b7:	48 89 c7             	mov    %rax,%rdi
 40041ba:	e8 06 60 00 00       	call   400a1c5 <kputsSecure>
        
        // 大小
        kpnumSecure(&entry->size, UNHEX, 8);
 40041bf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 40041c3:	48 83 c0 04          	add    $0x4,%rax
 40041c7:	ba 08 00 00 00       	mov    $0x8,%edx
 40041cc:	be 05 00 00 00       	mov    $0x5,%esi
 40041d1:	48 89 c7             	mov    %rax,%rdi
 40041d4:	e8 2d 61 00 00       	call   400a306 <kpnumSecure>
        kputsSecure(" | ");
 40041d9:	48 8d 05 68 bc 00 00 	lea    0xbc68(%rip),%rax        # 400fe48 <FirstStaticHeapMaxObjCount+0x198>
 40041e0:	48 89 c7             	mov    %rax,%rdi
 40041e3:	e8 dd 5f 00 00       	call   400a1c5 <kputsSecure>
        
        // 类型
        const char* type = obj_type_to_str(entry->type);
 40041e8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 40041ec:	0f b6 40 08          	movzbl 0x8(%rax),%eax
 40041f0:	0f b6 c0             	movzbl %al,%eax
 40041f3:	89 c7                	mov    %eax,%edi
 40041f5:	e8 61 fd ff ff       	call   4003f5b <obj_type_to_str(KernelObjType)>
 40041fa:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
        kputsSecure(const_cast<char*> (type));
 40041fe:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4004202:	48 89 c7             	mov    %rax,%rdi
 4004205:	e8 bb 5f 00 00       	call   400a1c5 <kputsSecure>
        for(int s = 0; s < (7 - strlen(type)); s++) kputsSecure(" ");
 400420a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
 4004211:	eb 13                	jmp    4004226 <kpoolmemmgr_t::print_meta_table(HCB_chainlist_node*)+0x17e>
 4004213:	48 8d 05 32 bc 00 00 	lea    0xbc32(%rip),%rax        # 400fe4c <FirstStaticHeapMaxObjCount+0x19c>
 400421a:	48 89 c7             	mov    %rax,%rdi
 400421d:	e8 a3 5f 00 00       	call   400a1c5 <kputsSecure>
 4004222:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
 4004226:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 400422a:	48 89 c7             	mov    %rax,%rdi
 400422d:	e8 fc 3f 00 00       	call   400822e <strlen(char const*)>
 4004232:	ba 07 00 00 00       	mov    $0x7,%edx
 4004237:	29 c2                	sub    %eax,%edx
 4004239:	39 55 fc             	cmp    %edx,-0x4(%rbp)
 400423c:	0f 9c c0             	setl   %al
 400423f:	84 c0                	test   %al,%al
 4004241:	75 d0                	jne    4004213 <kpoolmemmgr_t::print_meta_table(HCB_chainlist_node*)+0x16b>
        kputsSecure(" | ");
 4004243:	48 8d 05 fe bb 00 00 	lea    0xbbfe(%rip),%rax        # 400fe48 <FirstStaticHeapMaxObjCount+0x198>
 400424a:	48 89 c7             	mov    %rax,%rdi
 400424d:	e8 73 5f 00 00       	call   400a1c5 <kputsSecure>
        
        // 虚拟地址
        vaddr_temp = entry->offset_in_heap+node->heap.heapVStart;
 4004252:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4004256:	8b 00                	mov    (%rax),%eax
 4004258:	89 c2                	mov    %eax,%edx
 400425a:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
 400425e:	48 8b 40 08          	mov    0x8(%rax),%rax
 4004262:	48 01 d0             	add    %rdx,%rax
 4004265:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
        kpnumSecure(&vaddr_temp, UNHEX, sizeof(vaddr_t));
 4004269:	48 8d 45 c8          	lea    -0x38(%rbp),%rax
 400426d:	ba 08 00 00 00       	mov    $0x8,%edx
 4004272:	be 05 00 00 00       	mov    $0x5,%esi
 4004277:	48 89 c7             	mov    %rax,%rdi
 400427a:	e8 87 60 00 00       	call   400a306 <kpnumSecure>
        kputsSecure("\n");
 400427f:	48 8d 05 e7 ba 00 00 	lea    0xbae7(%rip),%rax        # 400fd6d <FirstStaticHeapMaxObjCount+0xbd>
 4004286:	48 89 c7             	mov    %rax,%rdi
 4004289:	e8 37 5f 00 00       	call   400a1c5 <kputsSecure>
    for(uint32_t i = 0; i < count; i++) {
 400428e:	8b 45 c4             	mov    -0x3c(%rbp),%eax
 4004291:	83 c0 01             	add    $0x1,%eax
 4004294:	89 45 c4             	mov    %eax,-0x3c(%rbp)
 4004297:	8b 45 c4             	mov    -0x3c(%rbp),%eax
 400429a:	89 c2                	mov    %eax,%edx
 400429c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 40042a0:	48 39 c2             	cmp    %rax,%rdx
 40042a3:	0f 82 95 fe ff ff    	jb     400413e <kpoolmemmgr_t::print_meta_table(HCB_chainlist_node*)+0x96>
    }
}
 40042a9:	90                   	nop
 40042aa:	90                   	nop
 40042ab:	c9                   	leave
 40042ac:	c3                   	ret
 40042ad:	90                   	nop

00000000040042ae <kpoolmemmgr_t::print_all_hcb_status()>:

void kpoolmemmgr_t::print_all_hcb_status() {
 40042ae:	55                   	push   %rbp
 40042af:	48 89 e5             	mov    %rsp,%rbp
 40042b2:	48 83 ec 20          	sub    $0x20,%rsp
 40042b6:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    HCB_chainlist_node* current = &first_static_heap;
 40042ba:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 40042be:	48 83 c0 10          	add    $0x10,%rax
 40042c2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    uint64_t index = 0;
 40042c6:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
 40042cd:	00 
    
    while(current) {
 40042ce:	eb 72                	jmp    4004342 <kpoolmemmgr_t::print_all_hcb_status()+0x94>
        kputsSecure("\n=== HCB Node #");
 40042d0:	48 8d 05 77 bb 00 00 	lea    0xbb77(%rip),%rax        # 400fe4e <FirstStaticHeapMaxObjCount+0x19e>
 40042d7:	48 89 c7             	mov    %rax,%rdi
 40042da:	e8 e6 5e 00 00       	call   400a1c5 <kputsSecure>
        kpnumSecure(&index, UNDEC, 0);
 40042df:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
 40042e3:	ba 00 00 00 00       	mov    $0x0,%edx
 40042e8:	be 03 00 00 00       	mov    $0x3,%esi
 40042ed:	48 89 c7             	mov    %rax,%rdi
 40042f0:	e8 11 60 00 00       	call   400a306 <kpnumSecure>
        kputsSecure(" ===\n");
 40042f5:	48 8d 05 62 bb 00 00 	lea    0xbb62(%rip),%rax        # 400fe5e <FirstStaticHeapMaxObjCount+0x1ae>
 40042fc:	48 89 c7             	mov    %rax,%rdi
 40042ff:	e8 c1 5e 00 00       	call   400a1c5 <kputsSecure>
        
        print_hcb_status(current);
 4004304:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
 4004308:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 400430c:	48 89 d6             	mov    %rdx,%rsi
 400430f:	48 89 c7             	mov    %rax,%rdi
 4004312:	e8 cb f9 ff ff       	call   4003ce2 <kpoolmemmgr_t::print_hcb_status(HCB_chainlist_node*)>
        print_meta_table(current);
 4004317:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
 400431b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 400431f:	48 89 d6             	mov    %rdx,%rsi
 4004322:	48 89 c7             	mov    %rax,%rdi
 4004325:	e8 7e fd ff ff       	call   40040a8 <kpoolmemmgr_t::print_meta_table(HCB_chainlist_node*)>
        
        current = current->next;
 400432a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 400432e:	48 8b 40 50          	mov    0x50(%rax),%rax
 4004332:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
        index++;
 4004336:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 400433a:	48 83 c0 01          	add    $0x1,%rax
 400433e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    while(current) {
 4004342:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
 4004347:	75 87                	jne    40042d0 <kpoolmemmgr_t::print_all_hcb_status()+0x22>
    }
    
    kputsSecure("\nTotal HCBs: ");
 4004349:	48 8d 05 14 bb 00 00 	lea    0xbb14(%rip),%rax        # 400fe64 <FirstStaticHeapMaxObjCount+0x1b4>
 4004350:	48 89 c7             	mov    %rax,%rdi
 4004353:	e8 6d 5e 00 00       	call   400a1c5 <kputsSecure>
    kpnumSecure(&index, UNDEC, 0);
 4004358:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
 400435c:	ba 00 00 00 00       	mov    $0x0,%edx
 4004361:	be 03 00 00 00       	mov    $0x3,%esi
 4004366:	48 89 c7             	mov    %rax,%rdi
 4004369:	e8 98 5f 00 00       	call   400a306 <kpnumSecure>
    kputsSecure("\n");
 400436e:	48 8d 05 f8 b9 00 00 	lea    0xb9f8(%rip),%rax        # 400fd6d <FirstStaticHeapMaxObjCount+0xbd>
 4004375:	48 89 c7             	mov    %rax,%rdi
 4004378:	e8 48 5e 00 00       	call   400a1c5 <kputsSecure>
}
 400437d:	90                   	nop
 400437e:	c9                   	leave
 400437f:	c3                   	ret

0000000004004380 <find_object_by_offset(HeapMetaInfoArray*, unsigned int)>:
// 高效的内存设置函数

static inline int find_object_by_offset(HeapMetaInfoArray* metaInfo, uint32_t target_offset) {
 4004380:	55                   	push   %rbp
 4004381:	48 89 e5             	mov    %rsp,%rbp
 4004384:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
 4004388:	89 75 d4             	mov    %esi,-0x2c(%rbp)
    uint32_t objCount = metaInfo->header.objMetaCount;
 400438b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 400438f:	48 8b 40 08          	mov    0x8(%rax),%rax
 4004393:	89 45 f4             	mov    %eax,-0xc(%rbp)
    HeapObjectMetav2* metaTable = metaInfo->objMetaTable;
 4004396:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 400439a:	48 8b 40 18          	mov    0x18(%rax),%rax
 400439e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    
    int32_t left = 0;
 40043a2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
    int32_t right = objCount - 1;
 40043a9:	8b 45 f4             	mov    -0xc(%rbp),%eax
 40043ac:	83 e8 01             	sub    $0x1,%eax
 40043af:	89 45 f8             	mov    %eax,-0x8(%rbp)
    
    while (left <= right) {
 40043b2:	eb 64                	jmp    4004418 <find_object_by_offset(HeapMetaInfoArray*, unsigned int)+0x98>
        int32_t mid = left + (right - left) / 2;
 40043b4:	8b 45 f8             	mov    -0x8(%rbp),%eax
 40043b7:	2b 45 fc             	sub    -0x4(%rbp),%eax
 40043ba:	89 c2                	mov    %eax,%edx
 40043bc:	c1 ea 1f             	shr    $0x1f,%edx
 40043bf:	01 d0                	add    %edx,%eax
 40043c1:	d1 f8                	sar    $1,%eax
 40043c3:	89 c2                	mov    %eax,%edx
 40043c5:	8b 45 fc             	mov    -0x4(%rbp),%eax
 40043c8:	01 d0                	add    %edx,%eax
 40043ca:	89 45 e4             	mov    %eax,-0x1c(%rbp)
        uint32_t obj_offset = metaTable[mid].offset_in_heap;
 40043cd:	8b 45 e4             	mov    -0x1c(%rbp),%eax
 40043d0:	48 63 d0             	movslq %eax,%rdx
 40043d3:	48 89 d0             	mov    %rdx,%rax
 40043d6:	48 01 c0             	add    %rax,%rax
 40043d9:	48 01 d0             	add    %rdx,%rax
 40043dc:	48 c1 e0 02          	shl    $0x2,%rax
 40043e0:	48 89 c2             	mov    %rax,%rdx
 40043e3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 40043e7:	48 01 d0             	add    %rdx,%rax
 40043ea:	8b 00                	mov    (%rax),%eax
 40043ec:	89 45 e0             	mov    %eax,-0x20(%rbp)
        
        if (obj_offset == target_offset) {
 40043ef:	8b 45 e0             	mov    -0x20(%rbp),%eax
 40043f2:	3b 45 d4             	cmp    -0x2c(%rbp),%eax
 40043f5:	75 05                	jne    40043fc <find_object_by_offset(HeapMetaInfoArray*, unsigned int)+0x7c>
            return mid; // 找到匹配的对象
 40043f7:	8b 45 e4             	mov    -0x1c(%rbp),%eax
 40043fa:	eb 29                	jmp    4004425 <find_object_by_offset(HeapMetaInfoArray*, unsigned int)+0xa5>
        } else if (obj_offset < target_offset) {
 40043fc:	8b 45 e0             	mov    -0x20(%rbp),%eax
 40043ff:	3b 45 d4             	cmp    -0x2c(%rbp),%eax
 4004402:	73 0b                	jae    400440f <find_object_by_offset(HeapMetaInfoArray*, unsigned int)+0x8f>
            left = mid + 1;
 4004404:	8b 45 e4             	mov    -0x1c(%rbp),%eax
 4004407:	83 c0 01             	add    $0x1,%eax
 400440a:	89 45 fc             	mov    %eax,-0x4(%rbp)
 400440d:	eb 09                	jmp    4004418 <find_object_by_offset(HeapMetaInfoArray*, unsigned int)+0x98>
        } else {
            right = mid - 1;
 400440f:	8b 45 e4             	mov    -0x1c(%rbp),%eax
 4004412:	83 e8 01             	sub    $0x1,%eax
 4004415:	89 45 f8             	mov    %eax,-0x8(%rbp)
    while (left <= right) {
 4004418:	8b 45 fc             	mov    -0x4(%rbp),%eax
 400441b:	3b 45 f8             	cmp    -0x8(%rbp),%eax
 400441e:	7e 94                	jle    40043b4 <find_object_by_offset(HeapMetaInfoArray*, unsigned int)+0x34>
        }
    }
    
    return -1; // 没有找到匹配的对象
 4004420:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
 4004425:	5d                   	pop    %rbp
 4004426:	c3                   	ret
 4004427:	90                   	nop

0000000004004428 <kpoolmemmgr_t::clear(void*)>:
void kpoolmemmgr_t::clear(void* ptr)
{
 4004428:	55                   	push   %rbp
 4004429:	48 89 e5             	mov    %rsp,%rbp
 400442c:	48 83 ec 50          	sub    $0x50,%rsp
 4004430:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
 4004434:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
    if (ptr == nullptr) {
 4004438:	48 83 7d b0 00       	cmpq   $0x0,-0x50(%rbp)
 400443d:	0f 84 4d 01 00 00    	je     4004590 <kpoolmemmgr_t::clear(void*)+0x168>
        return;
    }
    
    if (kpoolmemmgr_flags.ableto_Expand == 0) {
 4004443:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 4004447:	0f b6 00             	movzbl (%rax),%eax
 400444a:	83 e0 01             	and    $0x1,%eax
 400444d:	84 c0                	test   %al,%al
 400444f:	0f 85 3c 01 00 00    	jne    4004591 <kpoolmemmgr_t::clear(void*)+0x169>
        HeapMetaInfoArray* metaInfo = &first_static_heap.heap.metaInfo;
 4004455:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 4004459:	48 83 c0 30          	add    $0x30,%rax
 400445d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
        uint8_t* heap_phys_base = (uint8_t*)first_static_heap.heap.heapStart;
 4004461:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 4004465:	48 8b 40 10          	mov    0x10(%rax),%rax
 4004469:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
        uint8_t* heap_virt_base = (uint8_t*)first_static_heap.heap.heapVStart;
 400446d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 4004471:	48 8b 40 18          	mov    0x18(%rax),%rax
 4004475:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
        
        // 判断ptr是物理地址还是虚拟地址
        bool is_virtual_addr = false;
 4004479:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
        uint8_t* target_addr = (uint8_t*)ptr;
 400447d:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
 4004481:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
        
        // 检查高16位是否全1（虚拟地址特征）
        if ((reinterpret_cast<uint64_t>(ptr) >> 48) == 0xFFFF) {
 4004485:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
 4004489:	48 c1 e8 30          	shr    $0x30,%rax
 400448d:	48 3d ff ff 00 00    	cmp    $0xffff,%rax
 4004493:	75 04                	jne    4004499 <kpoolmemmgr_t::clear(void*)+0x71>
            is_virtual_addr = true;
 4004495:	c6 45 ff 01          	movb   $0x1,-0x1(%rbp)
        }
        
        // 计算目标地址在堆中的偏移量
        uint32_t target_offset;
        if (is_virtual_addr) {
 4004499:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
 400449d:	74 1c                	je     40044bb <kpoolmemmgr_t::clear(void*)+0x93>
            target_offset = virt_addr_to_offset(&first_static_heap, target_addr);
 400449f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 40044a3:	48 8d 50 10          	lea    0x10(%rax),%rdx
 40044a7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
 40044ab:	48 89 c6             	mov    %rax,%rsi
 40044ae:	48 89 d7             	mov    %rdx,%rdi
 40044b1:	e8 de e7 ff ff       	call   4002c94 <virt_addr_to_offset(HCB_chainlist_node*, unsigned char*)>
 40044b6:	89 45 f8             	mov    %eax,-0x8(%rbp)
 40044b9:	eb 1a                	jmp    40044d5 <kpoolmemmgr_t::clear(void*)+0xad>
        } else {
            target_offset = phys_addr_to_offset(&first_static_heap, target_addr);
 40044bb:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 40044bf:	48 8d 50 10          	lea    0x10(%rax),%rdx
 40044c3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
 40044c7:	48 89 c6             	mov    %rax,%rsi
 40044ca:	48 89 d7             	mov    %rdx,%rdi
 40044cd:	e8 a3 e7 ff ff       	call   4002c75 <phys_addr_to_offset(HCB_chainlist_node*, unsigned char*)>
 40044d2:	89 45 f8             	mov    %eax,-0x8(%rbp)
        }
        
        // 使用二分查找在元信息表中查找对象
        int index = find_object_by_offset(metaInfo, target_offset);
 40044d5:	8b 55 f8             	mov    -0x8(%rbp),%edx
 40044d8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 40044dc:	89 d6                	mov    %edx,%esi
 40044de:	48 89 c7             	mov    %rax,%rdi
 40044e1:	e8 9a fe ff ff       	call   4004380 <find_object_by_offset(HeapMetaInfoArray*, unsigned int)>
 40044e6:	89 45 cc             	mov    %eax,-0x34(%rbp)
        
        if (index >= 0 && metaInfo->objMetaTable[index].type != OBJ_TYPE_FREE) {
 40044e9:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
 40044ed:	0f 88 9e 00 00 00    	js     4004591 <kpoolmemmgr_t::clear(void*)+0x169>
 40044f3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 40044f7:	48 8b 48 18          	mov    0x18(%rax),%rcx
 40044fb:	8b 45 cc             	mov    -0x34(%rbp),%eax
 40044fe:	48 63 d0             	movslq %eax,%rdx
 4004501:	48 89 d0             	mov    %rdx,%rax
 4004504:	48 01 c0             	add    %rax,%rax
 4004507:	48 01 d0             	add    %rdx,%rax
 400450a:	48 c1 e0 02          	shl    $0x2,%rax
 400450e:	48 01 c8             	add    %rcx,%rax
 4004511:	0f b6 40 08          	movzbl 0x8(%rax),%eax
 4004515:	3c 0c                	cmp    $0xc,%al
 4004517:	74 78                	je     4004591 <kpoolmemmgr_t::clear(void*)+0x169>
            // 找到匹配的对象，计算要清零的内存区域
            uint8_t* clear_start;
            if (is_virtual_addr) {
 4004519:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
 400451d:	74 1b                	je     400453a <kpoolmemmgr_t::clear(void*)+0x112>
                clear_start = offset_to_virt_addr(&first_static_heap, target_offset);
 400451f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 4004523:	48 8d 50 10          	lea    0x10(%rax),%rdx
 4004527:	8b 45 f8             	mov    -0x8(%rbp),%eax
 400452a:	89 c6                	mov    %eax,%esi
 400452c:	48 89 d7             	mov    %rdx,%rdi
 400452f:	e8 26 e7 ff ff       	call   4002c5a <offset_to_virt_addr(HCB_chainlist_node*, unsigned int)>
 4004534:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
 4004538:	eb 19                	jmp    4004553 <kpoolmemmgr_t::clear(void*)+0x12b>
            } else {
                clear_start = offset_to_phys_addr(&first_static_heap, target_offset);
 400453a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 400453e:	48 8d 50 10          	lea    0x10(%rax),%rdx
 4004542:	8b 45 f8             	mov    -0x8(%rbp),%eax
 4004545:	89 c6                	mov    %eax,%esi
 4004547:	48 89 d7             	mov    %rdx,%rdi
 400454a:	e8 f1 e6 ff ff       	call   4002c40 <offset_to_phys_addr(HCB_chainlist_node*, unsigned int)>
 400454f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
            }
            
            uint32_t clear_size = metaInfo->objMetaTable[index].size;
 4004553:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4004557:	48 8b 48 18          	mov    0x18(%rax),%rcx
 400455b:	8b 45 cc             	mov    -0x34(%rbp),%eax
 400455e:	48 63 d0             	movslq %eax,%rdx
 4004561:	48 89 d0             	mov    %rdx,%rax
 4004564:	48 01 c0             	add    %rax,%rax
 4004567:	48 01 d0             	add    %rdx,%rax
 400456a:	48 c1 e0 02          	shl    $0x2,%rax
 400456e:	48 01 c8             	add    %rcx,%rax
 4004571:	8b 40 04             	mov    0x4(%rax),%eax
 4004574:	89 45 c8             	mov    %eax,-0x38(%rbp)
            
            // 使用优化的setmem函数将内存区域清零
            setmem(clear_start, clear_size, 0);
 4004577:	8b 4d c8             	mov    -0x38(%rbp),%ecx
 400457a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 400457e:	ba 00 00 00 00       	mov    $0x0,%edx
 4004583:	48 89 ce             	mov    %rcx,%rsi
 4004586:	48 89 c7             	mov    %rax,%rdi
 4004589:	e8 d2 3c 00 00       	call   4008260 <setmem(void*, unsigned long, unsigned char)>
 400458e:	eb 01                	jmp    4004591 <kpoolmemmgr_t::clear(void*)+0x169>
        return;
 4004590:	90                   	nop
            // 在内核环境中，可能需要记录错误或触发断言
        }
    } else {
        // ableto_Expand位开启的情况，暂不实现
    }
}
 4004591:	c9                   	leave
 4004592:	c3                   	ret
 4004593:	90                   	nop

0000000004004594 <kpoolmemmgr_t::~kpoolmemmgr_t()>:

kpoolmemmgr_t::~kpoolmemmgr_t()
 4004594:	55                   	push   %rbp
 4004595:	48 89 e5             	mov    %rsp,%rbp
 4004598:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
{
}
 400459c:	90                   	nop
 400459d:	5d                   	pop    %rbp
 400459e:	c3                   	ret

000000000400459f <operator new(unsigned long)>:
// 重载全局 new/delete 操作符
void* operator new(size_t size) {
 400459f:	55                   	push   %rbp
 40045a0:	48 89 e5             	mov    %rsp,%rbp
 40045a3:	48 83 ec 10          	sub    $0x10,%rsp
 40045a7:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    return gKpoolmemmgr.kalloc(size, gKpoolmemmgr.getkpoolmemmgr_flags().heap_vaddr_enabled, 3);
 40045ab:	48 8d 05 ce ba 7f 00 	lea    0x7fbace(%rip),%rax        # 4800080 <gKpoolmemmgr>
 40045b2:	48 89 c7             	mov    %rax,%rdi
 40045b5:	e8 6a f1 ff ff       	call   4003724 <kpoolmemmgr_t::getkpoolmemmgr_flags()>
 40045ba:	83 e0 02             	and    $0x2,%eax
 40045bd:	d0 e8                	shr    $1,%al
 40045bf:	83 e0 01             	and    $0x1,%eax
 40045c2:	0f b6 d0             	movzbl %al,%edx
 40045c5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 40045c9:	48 8d 3d b0 ba 7f 00 	lea    0x7fbab0(%rip),%rdi        # 4800080 <gKpoolmemmgr>
 40045d0:	b9 03 00 00 00       	mov    $0x3,%ecx
 40045d5:	48 89 c6             	mov    %rax,%rsi
 40045d8:	e8 d3 e9 ff ff       	call   4002fb0 <kpoolmemmgr_t::kalloc(unsigned long, bool, unsigned char)>
}
 40045dd:	c9                   	leave
 40045de:	c3                   	ret

00000000040045df <operator new(unsigned long, bool, unsigned char)>:

void* operator new(size_t size, bool vaddraquire, uint8_t alignment) {
 40045df:	55                   	push   %rbp
 40045e0:	48 89 e5             	mov    %rsp,%rbp
 40045e3:	48 83 ec 10          	sub    $0x10,%rsp
 40045e7:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
 40045eb:	89 f1                	mov    %esi,%ecx
 40045ed:	89 d0                	mov    %edx,%eax
 40045ef:	89 ca                	mov    %ecx,%edx
 40045f1:	88 55 f4             	mov    %dl,-0xc(%rbp)
 40045f4:	88 45 f0             	mov    %al,-0x10(%rbp)
    return gKpoolmemmgr.kalloc(size, vaddraquire, alignment);
 40045f7:	0f b6 4d f0          	movzbl -0x10(%rbp),%ecx
 40045fb:	0f b6 55 f4          	movzbl -0xc(%rbp),%edx
 40045ff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4004603:	48 8d 3d 76 ba 7f 00 	lea    0x7fba76(%rip),%rdi        # 4800080 <gKpoolmemmgr>
 400460a:	48 89 c6             	mov    %rax,%rsi
 400460d:	e8 9e e9 ff ff       	call   4002fb0 <kpoolmemmgr_t::kalloc(unsigned long, bool, unsigned char)>
}
 4004612:	c9                   	leave
 4004613:	c3                   	ret

0000000004004614 <operator new[](unsigned long)>:

void* operator new[](size_t size) {
 4004614:	55                   	push   %rbp
 4004615:	48 89 e5             	mov    %rsp,%rbp
 4004618:	48 83 ec 10          	sub    $0x10,%rsp
 400461c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    return gKpoolmemmgr.kalloc(size, gKpoolmemmgr.getkpoolmemmgr_flags().heap_vaddr_enabled, 3);
 4004620:	48 8d 05 59 ba 7f 00 	lea    0x7fba59(%rip),%rax        # 4800080 <gKpoolmemmgr>
 4004627:	48 89 c7             	mov    %rax,%rdi
 400462a:	e8 f5 f0 ff ff       	call   4003724 <kpoolmemmgr_t::getkpoolmemmgr_flags()>
 400462f:	83 e0 02             	and    $0x2,%eax
 4004632:	d0 e8                	shr    $1,%al
 4004634:	83 e0 01             	and    $0x1,%eax
 4004637:	0f b6 d0             	movzbl %al,%edx
 400463a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 400463e:	48 8d 3d 3b ba 7f 00 	lea    0x7fba3b(%rip),%rdi        # 4800080 <gKpoolmemmgr>
 4004645:	b9 03 00 00 00       	mov    $0x3,%ecx
 400464a:	48 89 c6             	mov    %rax,%rsi
 400464d:	e8 5e e9 ff ff       	call   4002fb0 <kpoolmemmgr_t::kalloc(unsigned long, bool, unsigned char)>
}
 4004652:	c9                   	leave
 4004653:	c3                   	ret

0000000004004654 <operator new[](unsigned long, bool, unsigned char)>:

void* operator new[](size_t size, bool vaddraquire, uint8_t alignment) {
 4004654:	55                   	push   %rbp
 4004655:	48 89 e5             	mov    %rsp,%rbp
 4004658:	48 83 ec 10          	sub    $0x10,%rsp
 400465c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
 4004660:	89 f1                	mov    %esi,%ecx
 4004662:	89 d0                	mov    %edx,%eax
 4004664:	89 ca                	mov    %ecx,%edx
 4004666:	88 55 f4             	mov    %dl,-0xc(%rbp)
 4004669:	88 45 f0             	mov    %al,-0x10(%rbp)
    return gKpoolmemmgr.kalloc(size, vaddraquire, alignment);
 400466c:	0f b6 4d f0          	movzbl -0x10(%rbp),%ecx
 4004670:	0f b6 55 f4          	movzbl -0xc(%rbp),%edx
 4004674:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4004678:	48 8d 3d 01 ba 7f 00 	lea    0x7fba01(%rip),%rdi        # 4800080 <gKpoolmemmgr>
 400467f:	48 89 c6             	mov    %rax,%rsi
 4004682:	e8 29 e9 ff ff       	call   4002fb0 <kpoolmemmgr_t::kalloc(unsigned long, bool, unsigned char)>
}
 4004687:	c9                   	leave
 4004688:	c3                   	ret

0000000004004689 <operator delete(void*)>:

void operator delete(void* ptr) noexcept {
 4004689:	55                   	push   %rbp
 400468a:	48 89 e5             	mov    %rsp,%rbp
 400468d:	48 83 ec 10          	sub    $0x10,%rsp
 4004691:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    gKpoolmemmgr.kfree(ptr);
 4004695:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4004699:	48 8d 15 e0 b9 7f 00 	lea    0x7fb9e0(%rip),%rdx        # 4800080 <gKpoolmemmgr>
 40046a0:	48 89 c6             	mov    %rax,%rsi
 40046a3:	48 89 d7             	mov    %rdx,%rdi
 40046a6:	e8 a5 f0 ff ff       	call   4003750 <kpoolmemmgr_t::kfree(void*)>
}
 40046ab:	90                   	nop
 40046ac:	c9                   	leave
 40046ad:	c3                   	ret

00000000040046ae <operator delete(void*, unsigned long)>:

void operator delete(void* ptr, size_t) noexcept {
 40046ae:	55                   	push   %rbp
 40046af:	48 89 e5             	mov    %rsp,%rbp
 40046b2:	48 83 ec 10          	sub    $0x10,%rsp
 40046b6:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
 40046ba:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
    gKpoolmemmgr.kfree(ptr);
 40046be:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 40046c2:	48 8d 15 b7 b9 7f 00 	lea    0x7fb9b7(%rip),%rdx        # 4800080 <gKpoolmemmgr>
 40046c9:	48 89 c6             	mov    %rax,%rsi
 40046cc:	48 89 d7             	mov    %rdx,%rdi
 40046cf:	e8 7c f0 ff ff       	call   4003750 <kpoolmemmgr_t::kfree(void*)>
}
 40046d4:	90                   	nop
 40046d5:	c9                   	leave
 40046d6:	c3                   	ret

00000000040046d7 <operator delete[](void*)>:

void operator delete[](void* ptr) noexcept {
 40046d7:	55                   	push   %rbp
 40046d8:	48 89 e5             	mov    %rsp,%rbp
 40046db:	48 83 ec 10          	sub    $0x10,%rsp
 40046df:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    gKpoolmemmgr.kfree(ptr);
 40046e3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 40046e7:	48 8d 15 92 b9 7f 00 	lea    0x7fb992(%rip),%rdx        # 4800080 <gKpoolmemmgr>
 40046ee:	48 89 c6             	mov    %rax,%rsi
 40046f1:	48 89 d7             	mov    %rdx,%rdi
 40046f4:	e8 57 f0 ff ff       	call   4003750 <kpoolmemmgr_t::kfree(void*)>
}
 40046f9:	90                   	nop
 40046fa:	c9                   	leave
 40046fb:	c3                   	ret

00000000040046fc <operator delete[](void*, unsigned long)>:

void operator delete[](void* ptr, size_t) noexcept {
 40046fc:	55                   	push   %rbp
 40046fd:	48 89 e5             	mov    %rsp,%rbp
 4004700:	48 83 ec 10          	sub    $0x10,%rsp
 4004704:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
 4004708:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
    gKpoolmemmgr.kfree(ptr);
 400470c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4004710:	48 8d 15 69 b9 7f 00 	lea    0x7fb969(%rip),%rdx        # 4800080 <gKpoolmemmgr>
 4004717:	48 89 c6             	mov    %rax,%rsi
 400471a:	48 89 d7             	mov    %rdx,%rdi
 400471d:	e8 2e f0 ff ff       	call   4003750 <kpoolmemmgr_t::kfree(void*)>
}
 4004722:	90                   	nop
 4004723:	c9                   	leave
 4004724:	c3                   	ret

0000000004004725 <operator new(unsigned long, void*)>:

// 放置 new 操作符
void* operator new(size_t, void* ptr) noexcept {
 4004725:	55                   	push   %rbp
 4004726:	48 89 e5             	mov    %rsp,%rbp
 4004729:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
 400472d:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
    return ptr;
 4004731:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
 4004735:	5d                   	pop    %rbp
 4004736:	c3                   	ret

0000000004004737 <operator new[](unsigned long, void*)>:

void* operator new[](size_t, void* ptr) noexcept {
 4004737:	55                   	push   %rbp
 4004738:	48 89 e5             	mov    %rsp,%rbp
 400473b:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
 400473f:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
    return ptr;
 4004743:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
 4004747:	5d                   	pop    %rbp
 4004748:	c3                   	ret
 4004749:	90                   	nop

000000000400474a <HCB::HCB()>:
HCB::HCB(/* args */)
 400474a:	55                   	push   %rbp
 400474b:	48 89 e5             	mov    %rsp,%rbp
 400474e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
{
}
 4004752:	90                   	nop
 4004753:	5d                   	pop    %rbp
 4004754:	c3                   	ret
 4004755:	90                   	nop

0000000004004756 <HCB::~HCB()>:

HCB::~HCB()
 4004756:	55                   	push   %rbp
 4004757:	48 89 e5             	mov    %rsp,%rbp
 400475a:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
{
 400475e:	90                   	nop
 400475f:	5d                   	pop    %rbp
 4004760:	c3                   	ret

0000000004004761 <__static_initialization_and_destruction_0()>:
 4004761:	55                   	push   %rbp
 4004762:	48 89 e5             	mov    %rsp,%rbp
kpoolmemmgr_t gKpoolmemmgr;
 4004765:	48 8d 05 14 b9 7f 00 	lea    0x7fb914(%rip),%rax        # 4800080 <gKpoolmemmgr>
 400476c:	48 89 c7             	mov    %rax,%rdi
 400476f:	e8 14 f4 ff ff       	call   4003b88 <kpoolmemmgr_t::kpoolmemmgr_t()>
 4004774:	90                   	nop
 4004775:	5d                   	pop    %rbp
 4004776:	c3                   	ret

0000000004004777 <__static_initialization_and_destruction_1()>:
 4004777:	55                   	push   %rbp
 4004778:	48 89 e5             	mov    %rsp,%rbp
kpoolmemmgr_t gKpoolmemmgr;
 400477b:	48 8d 05 fe b8 7f 00 	lea    0x7fb8fe(%rip),%rax        # 4800080 <gKpoolmemmgr>
 4004782:	48 89 c7             	mov    %rax,%rdi
 4004785:	e8 0a fe ff ff       	call   4004594 <kpoolmemmgr_t::~kpoolmemmgr_t()>
 400478a:	90                   	nop
 400478b:	5d                   	pop    %rbp
 400478c:	c3                   	ret

000000000400478d <_GLOBAL__sub_I_gKpoolmemmgr>:
 400478d:	55                   	push   %rbp
 400478e:	48 89 e5             	mov    %rsp,%rbp
 4004791:	e8 cb ff ff ff       	call   4004761 <__static_initialization_and_destruction_0()>
 4004796:	5d                   	pop    %rbp
 4004797:	c3                   	ret

0000000004004798 <_GLOBAL__sub_D_gKpoolmemmgr>:
 4004798:	55                   	push   %rbp
 4004799:	48 89 e5             	mov    %rsp,%rbp
 400479c:	e8 d6 ff ff ff       	call   4004777 <__static_initialization_and_destruction_1()>
 40047a1:	5d                   	pop    %rbp
 40047a2:	c3                   	ret
 40047a3:	90                   	nop

00000000040047a4 <KernelSpacePgsMemMgr::Init()>:
 *根据全局物理内存描述符表初始化一个类页表的数据结构，
 * 以便后面转换为真正页表
 * 为了兼容五级页表在四级页表的情况下lv4级别的表是只有一项的，也只为其分配一项
 */
void KernelSpacePgsMemMgr::Init()
{
 40047a4:	55                   	push   %rbp
 40047a5:	48 89 e5             	mov    %rsp,%rbp
 40047a8:	53                   	push   %rbx
 40047a9:	48 83 ec 38          	sub    $0x38,%rsp
 40047ad:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
    uint64_t cr4_tmp;
    PgCBtb_query_func[0] = &KernelSpacePgsMemMgr::PgCBtb_lv0_entry_query;
 40047b1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 40047b5:	48 c7 c2 e8 78 00 04 	mov    $0x40078e8,%rdx
 40047bc:	48 89 90 78 10 00 00 	mov    %rdx,0x1078(%rax)
 40047c3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 40047c7:	48 c7 80 80 10 00 00 	movq   $0x0,0x1080(%rax)
 40047ce:	00 00 00 00 
PgCBtb_query_func[1] = &KernelSpacePgsMemMgr::PgCBtb_lv1_entry_query;
 40047d2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 40047d6:	48 c7 c2 a6 77 00 04 	mov    $0x40077a6,%rdx
 40047dd:	48 89 90 88 10 00 00 	mov    %rdx,0x1088(%rax)
 40047e4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 40047e8:	48 c7 80 90 10 00 00 	movq   $0x0,0x1090(%rax)
 40047ef:	00 00 00 00 
PgCBtb_query_func[2] = &KernelSpacePgsMemMgr::PgCBtb_lv2_entry_query;
 40047f3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 40047f7:	48 c7 c2 b8 76 00 04 	mov    $0x40076b8,%rdx
 40047fe:	48 89 90 98 10 00 00 	mov    %rdx,0x1098(%rax)
 4004805:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 4004809:	48 c7 80 a0 10 00 00 	movq   $0x0,0x10a0(%rax)
 4004810:	00 00 00 00 
PgCBtb_query_func[3] = &KernelSpacePgsMemMgr::PgCBtb_lv3_entry_query;
 4004814:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 4004818:	48 c7 c2 1c 76 00 04 	mov    $0x400761c,%rdx
 400481f:	48 89 90 a8 10 00 00 	mov    %rdx,0x10a8(%rax)
 4004826:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 400482a:	48 c7 80 b0 10 00 00 	movq   $0x0,0x10b0(%rax)
 4004831:	00 00 00 00 
PgCBtb_query_func[4] = &KernelSpacePgsMemMgr::PgCBtb_lv4_entry_query;
 4004835:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 4004839:	48 c7 c2 ea 75 00 04 	mov    $0x40075ea,%rdx
 4004840:	48 89 90 b8 10 00 00 	mov    %rdx,0x10b8(%rax)
 4004847:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 400484b:	48 c7 80 c0 10 00 00 	movq   $0x0,0x10c0(%rax)
 4004852:	00 00 00 00 
PgCBtb_construct_func[0] = &KernelSpacePgsMemMgr::PgCBtb_lv0_entry_construct;
 4004856:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 400485a:	48 8d 15 21 0a 00 00 	lea    0xa21(%rip),%rdx        # 4005282 <KernelSpacePgsMemMgr::PgCBtb_lv0_entry_construct(unsigned long, pgflags)>
 4004861:	48 89 90 28 10 00 00 	mov    %rdx,0x1028(%rax)
 4004868:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 400486c:	48 c7 80 30 10 00 00 	movq   $0x0,0x1030(%rax)
 4004873:	00 00 00 00 
PgCBtb_construct_func[1] = &KernelSpacePgsMemMgr::PgCBtb_lv1_entry_construct;
 4004877:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 400487b:	48 8d 15 88 06 00 00 	lea    0x688(%rip),%rdx        # 4004f0a <KernelSpacePgsMemMgr::PgCBtb_lv1_entry_construct(unsigned long, pgflags)>
 4004882:	48 89 90 38 10 00 00 	mov    %rdx,0x1038(%rax)
 4004889:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 400488d:	48 c7 80 40 10 00 00 	movq   $0x0,0x1040(%rax)
 4004894:	00 00 00 00 
PgCBtb_construct_func[2] = &KernelSpacePgsMemMgr::PgCBtb_lv2_entry_construct;
 4004898:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 400489c:	48 8d 15 03 04 00 00 	lea    0x403(%rip),%rdx        # 4004ca6 <KernelSpacePgsMemMgr::PgCBtb_lv2_entry_construct(unsigned long, pgflags)>
 40048a3:	48 89 90 48 10 00 00 	mov    %rdx,0x1048(%rax)
 40048aa:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 40048ae:	48 c7 80 50 10 00 00 	movq   $0x0,0x1050(%rax)
 40048b5:	00 00 00 00 
PgCBtb_construct_func[3] = &KernelSpacePgsMemMgr::PgCBtb_lv3_entry_construct;
 40048b9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 40048bd:	48 8d 15 7a 02 00 00 	lea    0x27a(%rip),%rdx        # 4004b3e <KernelSpacePgsMemMgr::PgCBtb_lv3_entry_construct(unsigned long, pgflags)>
 40048c4:	48 89 90 58 10 00 00 	mov    %rdx,0x1058(%rax)
 40048cb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 40048cf:	48 c7 80 60 10 00 00 	movq   $0x0,0x1060(%rax)
 40048d6:	00 00 00 00 
PgCBtb_construct_func[4] = &KernelSpacePgsMemMgr::PgCBtb_lv4_entry_construct;
 40048da:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 40048de:	48 8d 15 61 01 00 00 	lea    0x161(%rip),%rdx        # 4004a46 <KernelSpacePgsMemMgr::PgCBtb_lv4_entry_construct(unsigned long, pgflags)>
 40048e5:	48 89 90 68 10 00 00 	mov    %rdx,0x1068(%rax)
 40048ec:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 40048f0:	48 c7 80 70 10 00 00 	movq   $0x0,0x1070(%rax)
 40048f7:	00 00 00 00 
    int status=0;
 40048fb:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%rbp)
#ifdef     KERNEL_MODE
    asm volatile("mov %%cr4,%0" : "=r"(cr4_tmp));
 4004902:	0f 20 e0             	mov    %cr4,%rax
 4004905:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

     cpu_pglv=(cr4_tmp&(1ULL<<12))?5:4;
 4004909:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 400490d:	25 00 10 00 00       	and    $0x1000,%eax
 4004912:	48 85 c0             	test   %rax,%rax
 4004915:	74 07                	je     400491e <KernelSpacePgsMemMgr::Init()+0x17a>
 4004917:	ba 05 00 00 00       	mov    $0x5,%edx
 400491c:	eb 05                	jmp    4004923 <KernelSpacePgsMemMgr::Init()+0x17f>
 400491e:	ba 04 00 00 00       	mov    $0x4,%edx
 4004923:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 4004927:	88 10                	mov    %dl,(%rax)
#endif
#ifdef TEST_MODE
    cpu_pglv=4;
#endif  
     if(cpu_pglv==5)
 4004929:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 400492d:	0f b6 00             	movzbl (%rax),%eax
 4004930:	3c 05                	cmp    $0x5,%al
 4004932:	75 1a                	jne    400494e <KernelSpacePgsMemMgr::Init()+0x1aa>
     rootlv4PgCBtb=new PgControlBlockHeader[512];
 4004934:	bf 00 20 00 00       	mov    $0x2000,%edi
 4004939:	e8 d6 fc ff ff       	call   4004614 <operator new[](unsigned long)>
 400493e:	48 89 c2             	mov    %rax,%rdx
 4004941:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 4004945:	48 89 90 20 10 00 00 	mov    %rdx,0x1020(%rax)
 400494c:	eb 18                	jmp    4004966 <KernelSpacePgsMemMgr::Init()+0x1c2>
     else rootlv4PgCBtb=new PgControlBlockHeader;
 400494e:	bf 10 00 00 00       	mov    $0x10,%edi
 4004953:	e8 47 fc ff ff       	call   400459f <operator new(unsigned long)>
 4004958:	48 89 c2             	mov    %rax,%rdx
 400495b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 400495f:	48 89 90 20 10 00 00 	mov    %rdx,0x1020(%rax)
     phy_memDesriptor* phy_memDesTb=gBaseMemMgr.getGlobalPhysicalMemoryInfo();
 4004966:	48 8d 05 d3 b6 7f 00 	lea    0x7fb6d3(%rip),%rax        # 4800040 <gBaseMemMgr>
 400496d:	48 89 c7             	mov    %rax,%rdi
 4004970:	e8 87 c3 ff ff       	call   4000cfc <GlobalMemoryPGlevelMgr_t::getGlobalPhysicalMemoryInfo()>
 4004975:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
     uint64_t entryCount=gBaseMemMgr.getRootPhysicalMemoryDescriptorTableEntryCount();
 4004979:	48 8d 05 c0 b6 7f 00 	lea    0x7fb6c0(%rip),%rax        # 4800040 <gBaseMemMgr>
 4004980:	48 89 c7             	mov    %rax,%rdi
 4004983:	e8 86 c3 ff ff       	call   4000d0e <GlobalMemoryPGlevelMgr_t::getRootPhysicalMemoryDescriptorTableEntryCount()>
 4004988:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    RootAddr_ofpgtb_inlv4=nullptr;
 400498c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 4004990:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
 4004997:	00 
    RootAddr_ofpgtb_inlv5=nullptr;
 4004998:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 400499c:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
 40049a3:	00 
    kernel_sapce_PCID=0;
     for(int i=0;i<entryCount;i++)
 40049a4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
 40049ab:	e9 80 00 00 00       	jmp    4004a30 <KernelSpacePgsMemMgr::Init()+0x28c>
     {
        status=construct_pgsbasedon_phy_memDescriptor(phy_memDesTb[i]);
 40049b0:	8b 45 ec             	mov    -0x14(%rbp),%eax
 40049b3:	48 63 d0             	movslq %eax,%rdx
 40049b6:	48 89 d0             	mov    %rdx,%rax
 40049b9:	48 01 c0             	add    %rax,%rax
 40049bc:	48 01 d0             	add    %rdx,%rax
 40049bf:	48 c1 e0 04          	shl    $0x4,%rax
 40049c3:	48 89 c2             	mov    %rax,%rdx
 40049c6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 40049ca:	48 01 d0             	add    %rdx,%rax
 40049cd:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
 40049d1:	48 83 ec 30          	sub    $0x30,%rsp
 40049d5:	48 89 e2             	mov    %rsp,%rdx
 40049d8:	48 8b 08             	mov    (%rax),%rcx
 40049db:	48 8b 58 08          	mov    0x8(%rax),%rbx
 40049df:	48 89 0a             	mov    %rcx,(%rdx)
 40049e2:	48 89 5a 08          	mov    %rbx,0x8(%rdx)
 40049e6:	48 8b 48 10          	mov    0x10(%rax),%rcx
 40049ea:	48 8b 58 18          	mov    0x18(%rax),%rbx
 40049ee:	48 89 4a 10          	mov    %rcx,0x10(%rdx)
 40049f2:	48 89 5a 18          	mov    %rbx,0x18(%rdx)
 40049f6:	48 8b 48 20          	mov    0x20(%rax),%rcx
 40049fa:	48 8b 58 28          	mov    0x28(%rax),%rbx
 40049fe:	48 89 4a 20          	mov    %rcx,0x20(%rdx)
 4004a02:	48 89 5a 28          	mov    %rbx,0x28(%rdx)
 4004a06:	48 89 f7             	mov    %rsi,%rdi
 4004a09:	e8 9c 0c 00 00       	call   40056aa <KernelSpacePgsMemMgr::construct_pgsbasedon_phy_memDescriptor(phy_memDesriptor)>
 4004a0e:	48 83 c4 30          	add    $0x30,%rsp
 4004a12:	89 45 e8             	mov    %eax,-0x18(%rbp)
        if (status!=OS_SUCCESS)
 4004a15:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
 4004a19:	74 11                	je     4004a2c <KernelSpacePgsMemMgr::Init()+0x288>
        {
            kputsSecure("construct_pgsbasedon_phy_memDescriptor failed");
 4004a1b:	48 8d 05 86 b7 00 00 	lea    0xb786(%rip),%rax        # 40101a8 <INDEX_NOT_EXIST+0x8>
 4004a22:	48 89 c7             	mov    %rax,%rdi
 4004a25:	e8 9b 57 00 00       	call   400a1c5 <kputsSecure>
            return ;
 4004a2a:	eb 13                	jmp    4004a3f <KernelSpacePgsMemMgr::Init()+0x29b>
     for(int i=0;i<entryCount;i++)
 4004a2c:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
 4004a30:	8b 45 ec             	mov    -0x14(%rbp),%eax
 4004a33:	48 98                	cltq
 4004a35:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
 4004a39:	0f 82 71 ff ff ff    	jb     40049b0 <KernelSpacePgsMemMgr::Init()+0x20c>
        }   
     }
}
KernelSpacePgsMemMgr::allocatable_mem_segs_manager::allocatable_mem_segs_manager()
 4004a3f:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
 4004a43:	c9                   	leave
 4004a44:	c3                   	ret
 4004a45:	90                   	nop

0000000004004a46 <KernelSpacePgsMemMgr::PgCBtb_lv4_entry_construct(unsigned long, pgflags)>:
{
    allocatable_mem_seg_count=0;
 4004a46:	55                   	push   %rbp
 4004a47:	48 89 e5             	mov    %rsp,%rbp
 4004a4a:	53                   	push   %rbx
 4004a4b:	48 83 ec 38          	sub    $0x38,%rsp
 4004a4f:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
 4004a53:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
 4004a57:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
    setmem(&allocatable_mem_seg[0],sizeof(allocatable_mem_seg_t)*max_entry_count,0);
 4004a5b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%rbp)
}
 4004a62:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
 4004a66:	48 c1 e8 30          	shr    $0x30,%rax
 4004a6a:	25 ff 01 00 00       	and    $0x1ff,%eax
 4004a6f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
void KernelSpacePgsMemMgr::allocatable_mem_segs_manager::append(phy_memDesriptor *p)
 4004a73:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4004a77:	0f b6 00             	movzbl (%rax),%eax
 4004a7a:	3c 05                	cmp    $0x5,%al
 4004a7c:	74 08                	je     4004a86 <KernelSpacePgsMemMgr::PgCBtb_lv4_entry_construct(unsigned long, pgflags)+0x40>
 4004a7e:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
 4004a85:	00 
{
 4004a86:	0f b6 45 c9          	movzbl -0x37(%rbp),%eax
 4004a8a:	83 e0 e3             	and    $0xffffffe3,%eax
 4004a8d:	83 c8 10             	or     $0x10,%eax
 4004a90:	88 45 c9             	mov    %al,-0x37(%rbp)
}
 4004a93:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4004a97:	48 8b 80 20 10 00 00 	mov    0x1020(%rax),%rax
 4004a9e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
 4004aa2:	48 c1 e2 04          	shl    $0x4,%rdx
 4004aa6:	48 01 c2             	add    %rax,%rdx
 4004aa9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 4004aad:	48 89 02             	mov    %rax,(%rdx)
int KernelSpacePgsMemMgr::PgCBtb_lv4_entry_construct(phyaddr_t addr, pgflags flags)
 4004ab0:	0f b6 45 c8          	movzbl -0x38(%rbp),%eax
 4004ab4:	83 e0 04             	and    $0x4,%eax
 4004ab7:	84 c0                	test   %al,%al
 4004ab9:	75 77                	jne    4004b32 <KernelSpacePgsMemMgr::PgCBtb_lv4_entry_construct(unsigned long, pgflags)+0xec>
{
    int status=0;
    uint64_t lv4_index=(addr&PML5_INDEX_MASK_lv4)>>48;
 4004abb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4004abf:	48 8b 80 20 10 00 00 	mov    0x1020(%rax),%rax
 4004ac6:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
 4004aca:	48 c1 e2 04          	shl    $0x4,%rdx
 4004ace:	48 8d 1c 10          	lea    (%rax,%rdx,1),%rbx
 4004ad2:	bf 08 20 00 00       	mov    $0x2008,%edi
 4004ad7:	e8 c3 fa ff ff       	call   400459f <operator new(unsigned long)>
 4004adc:	48 89 43 08          	mov    %rax,0x8(%rbx)
    lv4_index=cpu_pglv==5?lv4_index:0;
 4004ae0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4004ae4:	48 8b 80 20 10 00 00 	mov    0x1020(%rax),%rax
 4004aeb:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
 4004aef:	48 c1 e2 04          	shl    $0x4,%rdx
 4004af3:	48 01 d0             	add    %rdx,%rax
 4004af6:	48 8b 40 08          	mov    0x8(%rax),%rax
 4004afa:	48 85 c0             	test   %rax,%rax
 4004afd:	75 07                	jne    4004b06 <KernelSpacePgsMemMgr::PgCBtb_lv4_entry_construct(unsigned long, pgflags)+0xc0>
    flags.pg_lv=4;
    rootlv4PgCBtb[lv4_index].flags = flags;
 4004aff:	b8 01 10 00 00       	mov    $0x1001,%eax
 4004b04:	eb 31                	jmp    4004b37 <KernelSpacePgsMemMgr::PgCBtb_lv4_entry_construct(unsigned long, pgflags)+0xf1>
    if (flags.is_atom==0)
    {
 4004b06:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4004b0a:	48 8b 80 20 10 00 00 	mov    0x1020(%rax),%rax
 4004b11:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
 4004b15:	48 c1 e2 04          	shl    $0x4,%rdx
 4004b19:	48 01 d0             	add    %rdx,%rax
 4004b1c:	48 8b 40 08          	mov    0x8(%rax),%rax
 4004b20:	48 8d 15 59 b5 7f 00 	lea    0x7fb559(%rip),%rdx        # 4800080 <gKpoolmemmgr>
 4004b27:	48 89 c6             	mov    %rax,%rsi
 4004b2a:	48 89 d7             	mov    %rdx,%rdi
 4004b2d:	e8 f6 f8 ff ff       	call   4004428 <kpoolmemmgr_t::clear(void*)>
      
            rootlv4PgCBtb[lv4_index].base.lowerlvPgCBtb= new lowerlv_PgCBtb;
            if (rootlv4PgCBtb[lv4_index].base.lowerlvPgCBtb==nullptr)
            {
                return OS_OUT_OF_MEMORY;
 4004b32:	b8 00 00 00 00       	mov    $0x0,%eax
            }
 4004b37:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
 4004b3b:	c9                   	leave
 4004b3c:	c3                   	ret
 4004b3d:	90                   	nop

0000000004004b3e <KernelSpacePgsMemMgr::PgCBtb_lv3_entry_construct(unsigned long, pgflags)>:
            gKpoolmemmgr.clear(rootlv4PgCBtb[lv4_index].base.lowerlvPgCBtb);
        
        
 4004b3e:	55                   	push   %rbp
 4004b3f:	48 89 e5             	mov    %rsp,%rbp
 4004b42:	48 83 ec 50          	sub    $0x50,%rsp
 4004b46:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
 4004b4a:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
 4004b4e:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
    }
    
 4004b52:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
 4004b56:	48 c1 e8 27          	shr    $0x27,%rax
 4004b5a:	66 25 ff 01          	and    $0x1ff,%ax
 4004b5e:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
    return OS_SUCCESS;
 4004b62:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
 4004b66:	48 c1 e8 30          	shr    $0x30,%rax
 4004b6a:	25 ff 01 00 00       	and    $0x1ff,%eax
 4004b6f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
}
 4004b73:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 4004b77:	0f b6 00             	movzbl (%rax),%eax
 4004b7a:	3c 05                	cmp    $0x5,%al
 4004b7c:	75 1c                	jne    4004b9a <KernelSpacePgsMemMgr::PgCBtb_lv3_entry_construct(unsigned long, pgflags)+0x5c>
 4004b7e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 4004b82:	48 8b 80 20 10 00 00 	mov    0x1020(%rax),%rax
 4004b89:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
 4004b8d:	48 c1 e2 04          	shl    $0x4,%rdx
 4004b91:	48 01 d0             	add    %rdx,%rax
 4004b94:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
 4004b98:	eb 0f                	jmp    4004ba9 <KernelSpacePgsMemMgr::PgCBtb_lv3_entry_construct(unsigned long, pgflags)+0x6b>
 4004b9a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 4004b9e:	48 8b 80 20 10 00 00 	mov    0x1020(%rax),%rax
 4004ba5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

int KernelSpacePgsMemMgr::PgCBtb_lv3_entry_construct(phyaddr_t addr, pgflags flags)
 4004ba9:	0f b6 45 d0          	movzbl -0x30(%rbp),%eax
 4004bad:	83 c8 02             	or     $0x2,%eax
 4004bb0:	88 45 d0             	mov    %al,-0x30(%rbp)
{
 4004bb3:	0f b6 45 d0          	movzbl -0x30(%rbp),%eax
 4004bb7:	83 e0 fb             	and    $0xfffffffb,%eax
 4004bba:	88 45 d0             	mov    %al,-0x30(%rbp)

    uint16_t lv3_index=(addr&PML4_INDEX_MASK_lv3)>>39;
 4004bbd:	0f b6 45 d0          	movzbl -0x30(%rbp),%eax
 4004bc1:	83 e0 fe             	and    $0xfffffffe,%eax
 4004bc4:	88 45 d0             	mov    %al,-0x30(%rbp)
    uint64_t lv4_index=(addr&PML5_INDEX_MASK_lv4)>>48;
 4004bc7:	0f b6 45 d0          	movzbl -0x30(%rbp),%eax
 4004bcb:	83 c8 20             	or     $0x20,%eax
 4004bce:	88 45 d0             	mov    %al,-0x30(%rbp)
    PgCBlv4header* lv4_PgCBHeader = cpu_pglv == 5 ? &rootlv4PgCBtb[lv4_index] : rootlv4PgCBtb;
    pgflags higher_uninitialized_entry_flags;
 4004bd1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4004bd5:	0f b6 00             	movzbl (%rax),%eax
 4004bd8:	83 e0 02             	and    $0x2,%eax
 4004bdb:	84 c0                	test   %al,%al
 4004bdd:	75 35                	jne    4004c14 <KernelSpacePgsMemMgr::PgCBtb_lv3_entry_construct(unsigned long, pgflags)+0xd6>
    higher_uninitialized_entry_flags.is_exist=1;
    higher_uninitialized_entry_flags.is_atom=0;
 4004bdf:	0f b6 45 d1          	movzbl -0x2f(%rbp),%eax
 4004be3:	83 e0 e3             	and    $0xffffffe3,%eax
 4004be6:	83 c8 0c             	or     $0xc,%eax
 4004be9:	88 45 d1             	mov    %al,-0x2f(%rbp)

    higher_uninitialized_entry_flags.physical_or_virtual_pg=0;
 4004bec:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
 4004bf0:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
 4004bf4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 4004bf8:	48 89 ce             	mov    %rcx,%rsi
 4004bfb:	48 89 c7             	mov    %rax,%rdi
 4004bfe:	e8 43 fe ff ff       	call   4004a46 <KernelSpacePgsMemMgr::PgCBtb_lv4_entry_construct(unsigned long, pgflags)>
 4004c03:	89 45 e4             	mov    %eax,-0x1c(%rbp)
    higher_uninitialized_entry_flags.is_kernel=1;
 4004c06:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
 4004c0a:	74 08                	je     4004c14 <KernelSpacePgsMemMgr::PgCBtb_lv3_entry_construct(unsigned long, pgflags)+0xd6>
    // 确保lv4条目存在
 4004c0c:	8b 45 e4             	mov    -0x1c(%rbp),%eax
 4004c0f:	e9 90 00 00 00       	jmp    4004ca4 <KernelSpacePgsMemMgr::PgCBtb_lv3_entry_construct(unsigned long, pgflags)+0x166>
    if (lv4_PgCBHeader->flags.is_exist != 1) {
 
        higher_uninitialized_entry_flags.pg_lv = 3;
 4004c14:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4004c18:	48 8b 40 08          	mov    0x8(%rax),%rax
 4004c1c:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
 4004c20:	48 63 d2             	movslq %edx,%rdx
 4004c23:	48 c1 e2 04          	shl    $0x4,%rdx
 4004c27:	48 01 d0             	add    %rdx,%rax
 4004c2a:	48 83 c0 08          	add    $0x8,%rax
 4004c2e:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    
        int status = PgCBtb_lv4_entry_construct(addr, higher_uninitialized_entry_flags);
        if (status != OS_SUCCESS)
 4004c32:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4004c36:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
 4004c3a:	48 89 10             	mov    %rdx,(%rax)
            return status;
 4004c3d:	0f b6 45 b8          	movzbl -0x48(%rbp),%eax
 4004c41:	83 e0 04             	and    $0x4,%eax
 4004c44:	84 c0                	test   %al,%al
 4004c46:	75 43                	jne    4004c8b <KernelSpacePgsMemMgr::PgCBtb_lv3_entry_construct(unsigned long, pgflags)+0x14d>
    }

    PgCBlv3header* lv3_PgCBHeader = &lv4_PgCBHeader->base.lowerlvPgCBtb->entries[lv3_index];
 4004c48:	bf 08 20 00 00       	mov    $0x2008,%edi
 4004c4d:	e8 4d f9 ff ff       	call   400459f <operator new(unsigned long)>
 4004c52:	48 89 c2             	mov    %rax,%rdx
 4004c55:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4004c59:	48 89 50 08          	mov    %rdx,0x8(%rax)

 4004c5d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4004c61:	48 8b 40 08          	mov    0x8(%rax),%rax
 4004c65:	48 85 c0             	test   %rax,%rax
 4004c68:	75 07                	jne    4004c71 <KernelSpacePgsMemMgr::PgCBtb_lv3_entry_construct(unsigned long, pgflags)+0x133>
    // 初始化lv3条目
    lv3_PgCBHeader->flags = flags;
 4004c6a:	b8 01 10 00 00       	mov    $0x1001,%eax
 4004c6f:	eb 33                	jmp    4004ca4 <KernelSpacePgsMemMgr::PgCBtb_lv3_entry_construct(unsigned long, pgflags)+0x166>
     if (flags.is_atom==0)
    {
 4004c71:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4004c75:	48 8b 40 08          	mov    0x8(%rax),%rax
 4004c79:	48 8d 15 00 b4 7f 00 	lea    0x7fb400(%rip),%rdx        # 4800080 <gKpoolmemmgr>
 4004c80:	48 89 c6             	mov    %rax,%rsi
 4004c83:	48 89 d7             	mov    %rdx,%rdi
 4004c86:	e8 9d f7 ff ff       	call   4004428 <kpoolmemmgr_t::clear(void*)>
       
            lv3_PgCBHeader->base.lowerlvPgCBtb= new lowerlv_PgCBtb;
            if (lv3_PgCBHeader->base.lowerlvPgCBtb==nullptr)
            {
 4004c8b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4004c8f:	48 8b 40 08          	mov    0x8(%rax),%rax
 4004c93:	48 85 c0             	test   %rax,%rax
 4004c96:	75 07                	jne    4004c9f <KernelSpacePgsMemMgr::PgCBtb_lv3_entry_construct(unsigned long, pgflags)+0x161>
                return OS_OUT_OF_MEMORY;
 4004c98:	b8 01 10 00 00       	mov    $0x1001,%eax
 4004c9d:	eb 05                	jmp    4004ca4 <KernelSpacePgsMemMgr::PgCBtb_lv3_entry_construct(unsigned long, pgflags)+0x166>
            }
            gKpoolmemmgr.clear(lv3_PgCBHeader->base.lowerlvPgCBtb);
 4004c9f:	b8 00 00 00 00       	mov    $0x0,%eax
        
 4004ca4:	c9                   	leave
 4004ca5:	c3                   	ret

0000000004004ca6 <KernelSpacePgsMemMgr::PgCBtb_lv2_entry_construct(unsigned long, pgflags)>:
        
    }
 4004ca6:	55                   	push   %rbp
 4004ca7:	48 89 e5             	mov    %rsp,%rbp
 4004caa:	48 83 ec 70          	sub    $0x70,%rsp
 4004cae:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
 4004cb2:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
 4004cb6:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
    if (lv3_PgCBHeader->base.lowerlvPgCBtb == nullptr)
        return OS_OUT_OF_MEMORY;
 4004cba:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
 4004cbe:	48 c1 e8 1e          	shr    $0x1e,%rax
 4004cc2:	66 25 ff 01          	and    $0x1ff,%ax
 4004cc6:	66 89 45 f2          	mov    %ax,-0xe(%rbp)

 4004cca:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
 4004cce:	48 c1 e8 27          	shr    $0x27,%rax
 4004cd2:	66 25 ff 01          	and    $0x1ff,%ax
 4004cd6:	66 89 45 f0          	mov    %ax,-0x10(%rbp)
    return OS_SUCCESS;
 4004cda:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
 4004cde:	48 c1 e8 30          	shr    $0x30,%rax
 4004ce2:	25 ff 01 00 00       	and    $0x1ff,%eax
 4004ce7:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
}
 4004ceb:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%rbp)
int KernelSpacePgsMemMgr::PgCBtb_lv2_entry_construct(phyaddr_t addr, pgflags flags)
 4004cf2:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
 4004cf6:	0f b6 00             	movzbl (%rax),%eax
 4004cf9:	3c 05                	cmp    $0x5,%al
 4004cfb:	75 1c                	jne    4004d19 <KernelSpacePgsMemMgr::PgCBtb_lv2_entry_construct(unsigned long, pgflags)+0x73>
 4004cfd:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
 4004d01:	48 8b 80 20 10 00 00 	mov    0x1020(%rax),%rax
 4004d08:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
 4004d0c:	48 c1 e2 04          	shl    $0x4,%rdx
 4004d10:	48 01 d0             	add    %rdx,%rax
 4004d13:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
 4004d17:	eb 0f                	jmp    4004d28 <KernelSpacePgsMemMgr::PgCBtb_lv2_entry_construct(unsigned long, pgflags)+0x82>
 4004d19:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
 4004d1d:	48 8b 80 20 10 00 00 	mov    0x1020(%rax),%rax
 4004d24:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
{

 4004d28:	0f b6 45 c0          	movzbl -0x40(%rbp),%eax
 4004d2c:	83 c8 02             	or     $0x2,%eax
 4004d2f:	88 45 c0             	mov    %al,-0x40(%rbp)
    uint16_t lv2_index=(addr&PDPT_INDEX_MASK_lv2)>>30;
 4004d32:	0f b6 45 c0          	movzbl -0x40(%rbp),%eax
 4004d36:	83 e0 fb             	and    $0xfffffffb,%eax
 4004d39:	88 45 c0             	mov    %al,-0x40(%rbp)
    uint16_t lv3_index=(addr&PML4_INDEX_MASK_lv3)>>39;
    uint64_t lv4_index=(addr&PML5_INDEX_MASK_lv4)>>48;
 4004d3c:	0f b6 45 c0          	movzbl -0x40(%rbp),%eax
 4004d40:	83 e0 fe             	and    $0xfffffffe,%eax
 4004d43:	88 45 c0             	mov    %al,-0x40(%rbp)
    int status=0;
 4004d46:	0f b6 45 c0          	movzbl -0x40(%rbp),%eax
 4004d4a:	83 c8 20             	or     $0x20,%eax
 4004d4d:	88 45 c0             	mov    %al,-0x40(%rbp)
    PgCBlv4header* lv4_PgCBHeader = cpu_pglv == 5 ? &rootlv4PgCBtb[lv4_index] : rootlv4PgCBtb;
    pgflags higher_uninitialized_entry_flags;
    higher_uninitialized_entry_flags.is_exist = 1;
 4004d50:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4004d54:	0f b6 00             	movzbl (%rax),%eax
 4004d57:	83 e0 02             	and    $0x2,%eax
 4004d5a:	84 c0                	test   %al,%al
 4004d5c:	75 35                	jne    4004d93 <KernelSpacePgsMemMgr::PgCBtb_lv2_entry_construct(unsigned long, pgflags)+0xed>
    higher_uninitialized_entry_flags.is_atom = 0;
 4004d5e:	0f b6 45 c1          	movzbl -0x3f(%rbp),%eax
 4004d62:	83 e0 e3             	and    $0xffffffe3,%eax
 4004d65:	83 c8 10             	or     $0x10,%eax
 4004d68:	88 45 c1             	mov    %al,-0x3f(%rbp)

 4004d6b:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
 4004d6f:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
 4004d73:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
 4004d77:	48 89 ce             	mov    %rcx,%rsi
 4004d7a:	48 89 c7             	mov    %rax,%rdi
 4004d7d:	e8 c4 fc ff ff       	call   4004a46 <KernelSpacePgsMemMgr::PgCBtb_lv4_entry_construct(unsigned long, pgflags)>
 4004d82:	89 45 e0             	mov    %eax,-0x20(%rbp)
    higher_uninitialized_entry_flags.physical_or_virtual_pg = 0;
 4004d85:	83 7d e0 00          	cmpl   $0x0,-0x20(%rbp)
 4004d89:	74 08                	je     4004d93 <KernelSpacePgsMemMgr::PgCBtb_lv2_entry_construct(unsigned long, pgflags)+0xed>
    higher_uninitialized_entry_flags.is_kernel = 1;
 4004d8b:	8b 45 e0             	mov    -0x20(%rbp),%eax
 4004d8e:	e9 74 01 00 00       	jmp    4004f07 <KernelSpacePgsMemMgr::PgCBtb_lv2_entry_construct(unsigned long, pgflags)+0x261>

    // 确保lv4条目存在
    if (lv4_PgCBHeader->flags.is_exist != 1) {
        higher_uninitialized_entry_flags.pg_lv = 4;
 4004d93:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4004d97:	48 8b 40 08          	mov    0x8(%rax),%rax
 4004d9b:	0f b7 55 f0          	movzwl -0x10(%rbp),%edx
 4004d9f:	48 63 d2             	movslq %edx,%rdx
 4004da2:	48 c1 e2 04          	shl    $0x4,%rdx
 4004da6:	48 01 d0             	add    %rdx,%rax
 4004da9:	48 83 c0 08          	add    $0x8,%rax
 4004dad:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
        int status = PgCBtb_lv4_entry_construct(addr, higher_uninitialized_entry_flags);
 4004db1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4004db5:	0f b6 00             	movzbl (%rax),%eax
 4004db8:	83 e0 02             	and    $0x2,%eax
 4004dbb:	84 c0                	test   %al,%al
 4004dbd:	75 39                	jne    4004df8 <KernelSpacePgsMemMgr::PgCBtb_lv2_entry_construct(unsigned long, pgflags)+0x152>
        if (status != OS_SUCCESS)
 4004dbf:	0f b6 45 c1          	movzbl -0x3f(%rbp),%eax
 4004dc3:	83 e0 e3             	and    $0xffffffe3,%eax
 4004dc6:	83 c8 0c             	or     $0xc,%eax
 4004dc9:	88 45 c1             	mov    %al,-0x3f(%rbp)
            return status;
 4004dcc:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
 4004dd0:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
 4004dd4:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
 4004dd8:	48 89 ce             	mov    %rcx,%rsi
 4004ddb:	48 89 c7             	mov    %rax,%rdi
 4004dde:	e8 5b fd ff ff       	call   4004b3e <KernelSpacePgsMemMgr::PgCBtb_lv3_entry_construct(unsigned long, pgflags)>
 4004de3:	89 45 d4             	mov    %eax,-0x2c(%rbp)
    }
 4004de6:	83 7d d4 00          	cmpl   $0x0,-0x2c(%rbp)
 4004dea:	0f 84 9b 00 00 00    	je     4004e8b <KernelSpacePgsMemMgr::PgCBtb_lv2_entry_construct(unsigned long, pgflags)+0x1e5>

 4004df0:	8b 45 d4             	mov    -0x2c(%rbp),%eax
 4004df3:	e9 0f 01 00 00       	jmp    4004f07 <KernelSpacePgsMemMgr::PgCBtb_lv2_entry_construct(unsigned long, pgflags)+0x261>
    // 确保lv3条目存在
    PgCBlv3header* lv3_PgCBHeader = &lv4_PgCBHeader->base.lowerlvPgCBtb->entries[lv3_index];
 4004df8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4004dfc:	0f b6 00             	movzbl (%rax),%eax
 4004dff:	83 e0 04             	and    $0x4,%eax
 4004e02:	84 c0                	test   %al,%al
 4004e04:	0f 84 81 00 00 00    	je     4004e8b <KernelSpacePgsMemMgr::PgCBtb_lv2_entry_construct(unsigned long, pgflags)+0x1e5>
    if (lv3_PgCBHeader->flags.is_exist != 1) {
        higher_uninitialized_entry_flags.pg_lv = 3;
 4004e0a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4004e0e:	0f b6 10             	movzbl (%rax),%edx
 4004e11:	83 e2 fb             	and    $0xfffffffb,%edx
 4004e14:	88 10                	mov    %dl,(%rax)
        int status = PgCBtb_lv3_entry_construct(addr, higher_uninitialized_entry_flags);
 4004e16:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4004e1a:	48 8b 10             	mov    (%rax),%rdx
 4004e1d:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
 4004e21:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
 4004e25:	48 89 ce             	mov    %rcx,%rsi
 4004e28:	48 89 c7             	mov    %rax,%rdi
 4004e2b:	e8 76 fe ff ff       	call   4004ca6 <KernelSpacePgsMemMgr::PgCBtb_lv2_entry_construct(unsigned long, pgflags)>
 4004e30:	89 45 e4             	mov    %eax,-0x1c(%rbp)
        if (status != OS_SUCCESS)
 4004e33:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4004e37:	48 8b 00             	mov    (%rax),%rax
 4004e3a:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
            return status;
 4004e3e:	0f b6 45 b8          	movzbl -0x48(%rbp),%eax
 4004e42:	83 c8 04             	or     $0x4,%eax
 4004e45:	88 45 b8             	mov    %al,-0x48(%rbp)
    }else{
 4004e48:	0f b6 45 b9          	movzbl -0x47(%rbp),%eax
 4004e4c:	83 e0 e3             	and    $0xffffffe3,%eax
 4004e4f:	83 c8 08             	or     $0x8,%eax
 4004e52:	88 45 b9             	mov    %al,-0x47(%rbp)
        if(lv3_PgCBHeader->flags.is_atom==1)
 4004e55:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
 4004e5c:	eb 24                	jmp    4004e82 <KernelSpacePgsMemMgr::PgCBtb_lv2_entry_construct(unsigned long, pgflags)+0x1dc>
        {
            lv3_PgCBHeader->flags.is_atom=0;
 4004e5e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4004e62:	48 8b 40 08          	mov    0x8(%rax),%rax
 4004e66:	8b 55 f4             	mov    -0xc(%rbp),%edx
 4004e69:	48 63 d2             	movslq %edx,%rdx
 4004e6c:	48 c1 e2 04          	shl    $0x4,%rdx
 4004e70:	48 01 d0             	add    %rdx,%rax
 4004e73:	48 8d 50 08          	lea    0x8(%rax),%rdx
 4004e77:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 4004e7b:	48 89 02             	mov    %rax,(%rdx)
        if(lv3_PgCBHeader->flags.is_atom==1)
 4004e7e:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
 4004e82:	81 7d f4 ff 01 00 00 	cmpl   $0x1ff,-0xc(%rbp)
 4004e89:	7e d3                	jle    4004e5e <KernelSpacePgsMemMgr::PgCBtb_lv2_entry_construct(unsigned long, pgflags)+0x1b8>
            status=PgCBtb_lv2_entry_construct(addr,lv3_PgCBHeader->flags);
            pgflags lv2_flags=lv3_PgCBHeader->flags;
            lv2_flags.is_atom=1;
            lv2_flags.pg_lv=2;
            for(int i = 0; i < 512; i++)
 4004e8b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4004e8f:	48 8b 40 08          	mov    0x8(%rax),%rax
 4004e93:	0f b7 55 f2          	movzwl -0xe(%rbp),%edx
 4004e97:	48 63 d2             	movslq %edx,%rdx
 4004e9a:	48 c1 e2 04          	shl    $0x4,%rdx
 4004e9e:	48 01 d0             	add    %rdx,%rax
 4004ea1:	48 83 c0 08          	add    $0x8,%rax
 4004ea5:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
            {
                lv3_PgCBHeader->base.lowerlvPgCBtb->entries[i].flags=lv2_flags;
            }
 4004ea9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 4004ead:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
 4004eb1:	48 89 10             	mov    %rdx,(%rax)
        }
 4004eb4:	0f b6 45 98          	movzbl -0x68(%rbp),%eax
 4004eb8:	83 e0 04             	and    $0x4,%eax
 4004ebb:	84 c0                	test   %al,%al
 4004ebd:	75 43                	jne    4004f02 <KernelSpacePgsMemMgr::PgCBtb_lv2_entry_construct(unsigned long, pgflags)+0x25c>
    }

 4004ebf:	bf 08 20 00 00       	mov    $0x2008,%edi
 4004ec4:	e8 d6 f6 ff ff       	call   400459f <operator new(unsigned long)>
 4004ec9:	48 89 c2             	mov    %rax,%rdx
 4004ecc:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 4004ed0:	48 89 50 08          	mov    %rdx,0x8(%rax)
    PgCBlv2header* lv2_PgCBHeader = &lv3_PgCBHeader->base.lowerlvPgCBtb->entries[lv2_index];
 4004ed4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 4004ed8:	48 8b 40 08          	mov    0x8(%rax),%rax
 4004edc:	48 85 c0             	test   %rax,%rax
 4004edf:	75 07                	jne    4004ee8 <KernelSpacePgsMemMgr::PgCBtb_lv2_entry_construct(unsigned long, pgflags)+0x242>
    
 4004ee1:	b8 01 10 00 00       	mov    $0x1001,%eax
 4004ee6:	eb 1f                	jmp    4004f07 <KernelSpacePgsMemMgr::PgCBtb_lv2_entry_construct(unsigned long, pgflags)+0x261>
    // 初始化lv2条目
    lv2_PgCBHeader->flags = flags;
 4004ee8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 4004eec:	48 8b 40 08          	mov    0x8(%rax),%rax
 4004ef0:	48 8d 15 89 b1 7f 00 	lea    0x7fb189(%rip),%rdx        # 4800080 <gKpoolmemmgr>
 4004ef7:	48 89 c6             	mov    %rax,%rsi
 4004efa:	48 89 d7             	mov    %rdx,%rdi
 4004efd:	e8 26 f5 ff ff       	call   4004428 <kpoolmemmgr_t::clear(void*)>
    if (flags.is_atom == 0) {
       
            lv2_PgCBHeader->base.lowerlvPgCBtb = new lowerlv_PgCBtb;
            if (lv2_PgCBHeader->base.lowerlvPgCBtb == nullptr) {
 4004f02:	b8 00 00 00 00       	mov    $0x0,%eax
                return OS_OUT_OF_MEMORY;
 4004f07:	c9                   	leave
 4004f08:	c3                   	ret
 4004f09:	90                   	nop

0000000004004f0a <KernelSpacePgsMemMgr::PgCBtb_lv1_entry_construct(unsigned long, pgflags)>:
            }
            gKpoolmemmgr.clear(lv2_PgCBHeader->base.lowerlvPgCBtb);
        
 4004f0a:	55                   	push   %rbp
 4004f0b:	48 89 e5             	mov    %rsp,%rbp
 4004f0e:	48 81 ec 90 00 00 00 	sub    $0x90,%rsp
 4004f15:	48 89 7d 88          	mov    %rdi,-0x78(%rbp)
 4004f19:	48 89 75 80          	mov    %rsi,-0x80(%rbp)
 4004f1d:	48 89 95 78 ff ff ff 	mov    %rdx,-0x88(%rbp)
    }

 4004f24:	48 8b 45 80          	mov    -0x80(%rbp),%rax
 4004f28:	48 c1 e8 15          	shr    $0x15,%rax
 4004f2c:	66 25 ff 01          	and    $0x1ff,%ax
 4004f30:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
    return OS_SUCCESS;
 4004f34:	48 8b 45 80          	mov    -0x80(%rbp),%rax
 4004f38:	48 c1 e8 1e          	shr    $0x1e,%rax
 4004f3c:	66 25 ff 01          	and    $0x1ff,%ax
 4004f40:	66 89 45 ec          	mov    %ax,-0x14(%rbp)
}
 4004f44:	48 8b 45 80          	mov    -0x80(%rbp),%rax
 4004f48:	48 c1 e8 27          	shr    $0x27,%rax
 4004f4c:	66 25 ff 01          	and    $0x1ff,%ax
 4004f50:	66 89 45 ea          	mov    %ax,-0x16(%rbp)

 4004f54:	48 8b 45 80          	mov    -0x80(%rbp),%rax
 4004f58:	48 c1 e8 30          	shr    $0x30,%rax
 4004f5c:	25 ff 01 00 00       	and    $0x1ff,%eax
 4004f61:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
int KernelSpacePgsMemMgr::PgCBtb_lv1_entry_construct(phyaddr_t addr, pgflags flags)
 4004f65:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%rbp)
{
 4004f6c:	48 8b 45 88          	mov    -0x78(%rbp),%rax
 4004f70:	0f b6 00             	movzbl (%rax),%eax
 4004f73:	3c 05                	cmp    $0x5,%al
 4004f75:	75 1c                	jne    4004f93 <KernelSpacePgsMemMgr::PgCBtb_lv1_entry_construct(unsigned long, pgflags)+0x89>
 4004f77:	48 8b 45 88          	mov    -0x78(%rbp),%rax
 4004f7b:	48 8b 80 20 10 00 00 	mov    0x1020(%rax),%rax
 4004f82:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
 4004f86:	48 c1 e2 04          	shl    $0x4,%rdx
 4004f8a:	48 01 d0             	add    %rdx,%rax
 4004f8d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
 4004f91:	eb 0f                	jmp    4004fa2 <KernelSpacePgsMemMgr::PgCBtb_lv1_entry_construct(unsigned long, pgflags)+0x98>
 4004f93:	48 8b 45 88          	mov    -0x78(%rbp),%rax
 4004f97:	48 8b 80 20 10 00 00 	mov    0x1020(%rax),%rax
 4004f9e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

    uint16_t lv1_index=(addr&PD_INDEX_MASK_lv1)>>21;
 4004fa2:	0f b6 45 a8          	movzbl -0x58(%rbp),%eax
 4004fa6:	83 c8 02             	or     $0x2,%eax
 4004fa9:	88 45 a8             	mov    %al,-0x58(%rbp)
    uint16_t lv2_index=(addr&PDPT_INDEX_MASK_lv2)>>30;
 4004fac:	0f b6 45 a8          	movzbl -0x58(%rbp),%eax
 4004fb0:	83 e0 fb             	and    $0xfffffffb,%eax
 4004fb3:	88 45 a8             	mov    %al,-0x58(%rbp)
    uint16_t lv3_index=(addr&PML4_INDEX_MASK_lv3)>>39;
 4004fb6:	0f b6 45 a8          	movzbl -0x58(%rbp),%eax
 4004fba:	83 e0 fe             	and    $0xfffffffe,%eax
 4004fbd:	88 45 a8             	mov    %al,-0x58(%rbp)
    uint64_t lv4_index=(addr&PML5_INDEX_MASK_lv4)>>48;
 4004fc0:	0f b6 45 a8          	movzbl -0x58(%rbp),%eax
 4004fc4:	83 c8 20             	or     $0x20,%eax
 4004fc7:	88 45 a8             	mov    %al,-0x58(%rbp)
    int status=0;
    PgCBlv4header* lv4_PgCBHeader = cpu_pglv == 5 ? &rootlv4PgCBtb[lv4_index] : rootlv4PgCBtb;
    pgflags higher_uninitialized_entry_flags;
 4004fca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4004fce:	0f b6 00             	movzbl (%rax),%eax
 4004fd1:	83 e0 02             	and    $0x2,%eax
 4004fd4:	84 c0                	test   %al,%al
 4004fd6:	75 35                	jne    400500d <KernelSpacePgsMemMgr::PgCBtb_lv1_entry_construct(unsigned long, pgflags)+0x103>
    higher_uninitialized_entry_flags.is_exist = 1;
 4004fd8:	0f b6 45 a9          	movzbl -0x57(%rbp),%eax
 4004fdc:	83 e0 e3             	and    $0xffffffe3,%eax
 4004fdf:	83 c8 10             	or     $0x10,%eax
 4004fe2:	88 45 a9             	mov    %al,-0x57(%rbp)
    higher_uninitialized_entry_flags.is_atom = 0;
 4004fe5:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
 4004fe9:	48 8b 4d 80          	mov    -0x80(%rbp),%rcx
 4004fed:	48 8b 45 88          	mov    -0x78(%rbp),%rax
 4004ff1:	48 89 ce             	mov    %rcx,%rsi
 4004ff4:	48 89 c7             	mov    %rax,%rdi
 4004ff7:	e8 4a fa ff ff       	call   4004a46 <KernelSpacePgsMemMgr::PgCBtb_lv4_entry_construct(unsigned long, pgflags)>
 4004ffc:	89 45 d8             	mov    %eax,-0x28(%rbp)
    higher_uninitialized_entry_flags.physical_or_virtual_pg = 0;
 4004fff:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
 4005003:	74 08                	je     400500d <KernelSpacePgsMemMgr::PgCBtb_lv1_entry_construct(unsigned long, pgflags)+0x103>
    higher_uninitialized_entry_flags.is_kernel = 1;
 4005005:	8b 45 d8             	mov    -0x28(%rbp),%eax
 4005008:	e9 72 02 00 00       	jmp    400527f <KernelSpacePgsMemMgr::PgCBtb_lv1_entry_construct(unsigned long, pgflags)+0x375>

    // 确保lv4条目存在
    if (lv4_PgCBHeader->flags.is_exist != 1) {
        higher_uninitialized_entry_flags.pg_lv = 4;
 400500d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4005011:	48 8b 40 08          	mov    0x8(%rax),%rax
 4005015:	0f b7 55 ea          	movzwl -0x16(%rbp),%edx
 4005019:	48 63 d2             	movslq %edx,%rdx
 400501c:	48 c1 e2 04          	shl    $0x4,%rdx
 4005020:	48 01 d0             	add    %rdx,%rax
 4005023:	48 83 c0 08          	add    $0x8,%rax
 4005027:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
        int status = PgCBtb_lv4_entry_construct(addr, higher_uninitialized_entry_flags);
 400502b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
 400502f:	0f b6 00             	movzbl (%rax),%eax
 4005032:	83 e0 02             	and    $0x2,%eax
 4005035:	84 c0                	test   %al,%al
 4005037:	75 39                	jne    4005072 <KernelSpacePgsMemMgr::PgCBtb_lv1_entry_construct(unsigned long, pgflags)+0x168>
        if (status != OS_SUCCESS)
 4005039:	0f b6 45 a9          	movzbl -0x57(%rbp),%eax
 400503d:	83 e0 e3             	and    $0xffffffe3,%eax
 4005040:	83 c8 0c             	or     $0xc,%eax
 4005043:	88 45 a9             	mov    %al,-0x57(%rbp)
            return status;
 4005046:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
 400504a:	48 8b 4d 80          	mov    -0x80(%rbp),%rcx
 400504e:	48 8b 45 88          	mov    -0x78(%rbp),%rax
 4005052:	48 89 ce             	mov    %rcx,%rsi
 4005055:	48 89 c7             	mov    %rax,%rdi
 4005058:	e8 e1 fa ff ff       	call   4004b3e <KernelSpacePgsMemMgr::PgCBtb_lv3_entry_construct(unsigned long, pgflags)>
 400505d:	89 45 cc             	mov    %eax,-0x34(%rbp)
    }
 4005060:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
 4005064:	0f 84 9b 00 00 00    	je     4005105 <KernelSpacePgsMemMgr::PgCBtb_lv1_entry_construct(unsigned long, pgflags)+0x1fb>

 400506a:	8b 45 cc             	mov    -0x34(%rbp),%eax
 400506d:	e9 0d 02 00 00       	jmp    400527f <KernelSpacePgsMemMgr::PgCBtb_lv1_entry_construct(unsigned long, pgflags)+0x375>
    // 确保lv3条目存在
    PgCBlv3header* lv3_PgCBHeader = &lv4_PgCBHeader->base.lowerlvPgCBtb->entries[lv3_index];
 4005072:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
 4005076:	0f b6 00             	movzbl (%rax),%eax
 4005079:	83 e0 04             	and    $0x4,%eax
 400507c:	84 c0                	test   %al,%al
 400507e:	0f 84 81 00 00 00    	je     4005105 <KernelSpacePgsMemMgr::PgCBtb_lv1_entry_construct(unsigned long, pgflags)+0x1fb>
    if (lv3_PgCBHeader->flags.is_exist != 1) {
        higher_uninitialized_entry_flags.pg_lv = 3;
 4005084:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
 4005088:	0f b6 10             	movzbl (%rax),%edx
 400508b:	83 e2 fb             	and    $0xfffffffb,%edx
 400508e:	88 10                	mov    %dl,(%rax)
        int status = PgCBtb_lv3_entry_construct(addr, higher_uninitialized_entry_flags);
 4005090:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
 4005094:	48 8b 10             	mov    (%rax),%rdx
 4005097:	48 8b 4d 80          	mov    -0x80(%rbp),%rcx
 400509b:	48 8b 45 88          	mov    -0x78(%rbp),%rax
 400509f:	48 89 ce             	mov    %rcx,%rsi
 40050a2:	48 89 c7             	mov    %rax,%rdi
 40050a5:	e8 fc fb ff ff       	call   4004ca6 <KernelSpacePgsMemMgr::PgCBtb_lv2_entry_construct(unsigned long, pgflags)>
 40050aa:	89 45 dc             	mov    %eax,-0x24(%rbp)
        if (status != OS_SUCCESS)
 40050ad:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
 40050b1:	48 8b 00             	mov    (%rax),%rax
 40050b4:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
            return status;
 40050b8:	0f b6 45 a0          	movzbl -0x60(%rbp),%eax
 40050bc:	83 c8 04             	or     $0x4,%eax
 40050bf:	88 45 a0             	mov    %al,-0x60(%rbp)
    }else{
 40050c2:	0f b6 45 a1          	movzbl -0x5f(%rbp),%eax
 40050c6:	83 e0 e3             	and    $0xffffffe3,%eax
 40050c9:	83 c8 08             	or     $0x8,%eax
 40050cc:	88 45 a1             	mov    %al,-0x5f(%rbp)
        if(lv3_PgCBHeader->flags.is_atom==1)
 40050cf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
 40050d6:	eb 24                	jmp    40050fc <KernelSpacePgsMemMgr::PgCBtb_lv1_entry_construct(unsigned long, pgflags)+0x1f2>
        {
            lv3_PgCBHeader->flags.is_atom=0;
 40050d8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
 40050dc:	48 8b 40 08          	mov    0x8(%rax),%rax
 40050e0:	8b 55 f4             	mov    -0xc(%rbp),%edx
 40050e3:	48 63 d2             	movslq %edx,%rdx
 40050e6:	48 c1 e2 04          	shl    $0x4,%rdx
 40050ea:	48 01 d0             	add    %rdx,%rax
 40050ed:	48 8d 50 08          	lea    0x8(%rax),%rdx
 40050f1:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
 40050f5:	48 89 02             	mov    %rax,(%rdx)
        if(lv3_PgCBHeader->flags.is_atom==1)
 40050f8:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
 40050fc:	81 7d f4 ff 01 00 00 	cmpl   $0x1ff,-0xc(%rbp)
 4005103:	7e d3                	jle    40050d8 <KernelSpacePgsMemMgr::PgCBtb_lv1_entry_construct(unsigned long, pgflags)+0x1ce>
            status=PgCBtb_lv2_entry_construct(addr,lv3_PgCBHeader->flags);
            pgflags lv2_flags=lv3_PgCBHeader->flags;
            lv2_flags.is_atom=1;
            lv2_flags.pg_lv=2;
            for(int i = 0; i < 512; i++)
            {
 4005105:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
 4005109:	48 8b 40 08          	mov    0x8(%rax),%rax
 400510d:	0f b7 55 ec          	movzwl -0x14(%rbp),%edx
 4005111:	48 63 d2             	movslq %edx,%rdx
 4005114:	48 c1 e2 04          	shl    $0x4,%rdx
 4005118:	48 01 d0             	add    %rdx,%rax
 400511b:	48 83 c0 08          	add    $0x8,%rax
 400511f:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
                lv3_PgCBHeader->base.lowerlvPgCBtb->entries[i].flags=lv2_flags;
 4005123:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
 4005127:	0f b6 00             	movzbl (%rax),%eax
 400512a:	83 e0 02             	and    $0x2,%eax
 400512d:	84 c0                	test   %al,%al
 400512f:	75 39                	jne    400516a <KernelSpacePgsMemMgr::PgCBtb_lv1_entry_construct(unsigned long, pgflags)+0x260>
            }
 4005131:	0f b6 45 a9          	movzbl -0x57(%rbp),%eax
 4005135:	83 e0 e3             	and    $0xffffffe3,%eax
 4005138:	83 c8 08             	or     $0x8,%eax
 400513b:	88 45 a9             	mov    %al,-0x57(%rbp)
        }
 400513e:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
 4005142:	48 8b 4d 80          	mov    -0x80(%rbp),%rcx
 4005146:	48 8b 45 88          	mov    -0x78(%rbp),%rax
 400514a:	48 89 ce             	mov    %rcx,%rsi
 400514d:	48 89 c7             	mov    %rax,%rdi
 4005150:	e8 51 fb ff ff       	call   4004ca6 <KernelSpacePgsMemMgr::PgCBtb_lv2_entry_construct(unsigned long, pgflags)>
 4005155:	89 45 bc             	mov    %eax,-0x44(%rbp)
    }
 4005158:	83 7d bc 00          	cmpl   $0x0,-0x44(%rbp)
 400515c:	0f 84 9b 00 00 00    	je     40051fd <KernelSpacePgsMemMgr::PgCBtb_lv1_entry_construct(unsigned long, pgflags)+0x2f3>

 4005162:	8b 45 bc             	mov    -0x44(%rbp),%eax
 4005165:	e9 15 01 00 00       	jmp    400527f <KernelSpacePgsMemMgr::PgCBtb_lv1_entry_construct(unsigned long, pgflags)+0x375>
    // 确保lv2条目存在
    PgCBlv2header* lv2_PgCBHeader = &lv3_PgCBHeader->base.lowerlvPgCBtb->entries[lv2_index];
 400516a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
 400516e:	0f b6 00             	movzbl (%rax),%eax
 4005171:	83 e0 04             	and    $0x4,%eax
 4005174:	84 c0                	test   %al,%al
 4005176:	0f 84 81 00 00 00    	je     40051fd <KernelSpacePgsMemMgr::PgCBtb_lv1_entry_construct(unsigned long, pgflags)+0x2f3>
    if (lv2_PgCBHeader->flags.is_exist != 1) {
        higher_uninitialized_entry_flags.pg_lv = 2;
 400517c:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
 4005180:	0f b6 10             	movzbl (%rax),%edx
 4005183:	83 e2 fb             	and    $0xfffffffb,%edx
 4005186:	88 10                	mov    %dl,(%rax)
        int status = PgCBtb_lv2_entry_construct(addr, higher_uninitialized_entry_flags);
 4005188:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
 400518c:	48 8b 10             	mov    (%rax),%rdx
 400518f:	48 8b 4d 80          	mov    -0x80(%rbp),%rcx
 4005193:	48 8b 45 88          	mov    -0x78(%rbp),%rax
 4005197:	48 89 ce             	mov    %rcx,%rsi
 400519a:	48 89 c7             	mov    %rax,%rdi
 400519d:	e8 68 fd ff ff       	call   4004f0a <KernelSpacePgsMemMgr::PgCBtb_lv1_entry_construct(unsigned long, pgflags)>
 40051a2:	89 45 dc             	mov    %eax,-0x24(%rbp)
        if (status != OS_SUCCESS)
 40051a5:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
 40051a9:	48 8b 00             	mov    (%rax),%rax
 40051ac:	48 89 45 98          	mov    %rax,-0x68(%rbp)
            return status;
 40051b0:	0f b6 45 98          	movzbl -0x68(%rbp),%eax
 40051b4:	83 c8 04             	or     $0x4,%eax
 40051b7:	88 45 98             	mov    %al,-0x68(%rbp)
    }else{
 40051ba:	0f b6 45 99          	movzbl -0x67(%rbp),%eax
 40051be:	83 e0 e3             	and    $0xffffffe3,%eax
 40051c1:	83 c8 04             	or     $0x4,%eax
 40051c4:	88 45 99             	mov    %al,-0x67(%rbp)
        if(lv2_PgCBHeader->flags.is_atom==1)
 40051c7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
 40051ce:	eb 24                	jmp    40051f4 <KernelSpacePgsMemMgr::PgCBtb_lv1_entry_construct(unsigned long, pgflags)+0x2ea>
        {
            lv2_PgCBHeader->flags.is_atom=0;
 40051d0:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
 40051d4:	48 8b 40 08          	mov    0x8(%rax),%rax
 40051d8:	8b 55 f0             	mov    -0x10(%rbp),%edx
 40051db:	48 63 d2             	movslq %edx,%rdx
 40051de:	48 c1 e2 04          	shl    $0x4,%rdx
 40051e2:	48 01 d0             	add    %rdx,%rax
 40051e5:	48 8d 50 08          	lea    0x8(%rax),%rdx
 40051e9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
 40051ed:	48 89 02             	mov    %rax,(%rdx)
        if(lv2_PgCBHeader->flags.is_atom==1)
 40051f0:	83 45 f0 01          	addl   $0x1,-0x10(%rbp)
 40051f4:	81 7d f0 ff 01 00 00 	cmpl   $0x1ff,-0x10(%rbp)
 40051fb:	7e d3                	jle    40051d0 <KernelSpacePgsMemMgr::PgCBtb_lv1_entry_construct(unsigned long, pgflags)+0x2c6>
            status=PgCBtb_lv1_entry_construct(addr,lv2_PgCBHeader->flags);
            pgflags lv1_flags=lv2_PgCBHeader->flags;
            lv1_flags.is_atom=1;
            lv1_flags.pg_lv=1;
            for (int i = 0; i < 512; i++)
 40051fd:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
 4005201:	48 8b 40 08          	mov    0x8(%rax),%rax
 4005205:	0f b7 55 ee          	movzwl -0x12(%rbp),%edx
 4005209:	48 63 d2             	movslq %edx,%rdx
 400520c:	48 c1 e2 04          	shl    $0x4,%rdx
 4005210:	48 01 d0             	add    %rdx,%rax
 4005213:	48 83 c0 08          	add    $0x8,%rax
 4005217:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
            {
                lv2_PgCBHeader->base.lowerlvPgCBtb->entries[i].flags=lv1_flags;
            }        
 400521b:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
 400521f:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
 4005226:	48 89 10             	mov    %rdx,(%rax)
        }
 4005229:	0f b6 85 78 ff ff ff 	movzbl -0x88(%rbp),%eax
 4005230:	83 e0 04             	and    $0x4,%eax
 4005233:	84 c0                	test   %al,%al
 4005235:	75 43                	jne    400527a <KernelSpacePgsMemMgr::PgCBtb_lv1_entry_construct(unsigned long, pgflags)+0x370>
    }

 4005237:	bf 08 20 00 00       	mov    $0x2008,%edi
 400523c:	e8 5e f3 ff ff       	call   400459f <operator new(unsigned long)>
 4005241:	48 89 c2             	mov    %rax,%rdx
 4005244:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
 4005248:	48 89 50 08          	mov    %rdx,0x8(%rax)
    PgCBlv1header* lv1_PgCBHeader = &lv2_PgCBHeader->base.lowerlvPgCBtb->entries[lv1_index];
 400524c:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
 4005250:	48 8b 40 08          	mov    0x8(%rax),%rax
 4005254:	48 85 c0             	test   %rax,%rax
 4005257:	75 07                	jne    4005260 <KernelSpacePgsMemMgr::PgCBtb_lv1_entry_construct(unsigned long, pgflags)+0x356>
    
 4005259:	b8 01 10 00 00       	mov    $0x1001,%eax
 400525e:	eb 1f                	jmp    400527f <KernelSpacePgsMemMgr::PgCBtb_lv1_entry_construct(unsigned long, pgflags)+0x375>
    // 初始化lv1条目
    lv1_PgCBHeader->flags = flags;
 4005260:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
 4005264:	48 8b 40 08          	mov    0x8(%rax),%rax
 4005268:	48 8d 15 11 ae 7f 00 	lea    0x7fae11(%rip),%rdx        # 4800080 <gKpoolmemmgr>
 400526f:	48 89 c6             	mov    %rax,%rsi
 4005272:	48 89 d7             	mov    %rdx,%rdi
 4005275:	e8 ae f1 ff ff       	call   4004428 <kpoolmemmgr_t::clear(void*)>
    if (flags.is_atom == 0) {

            lv1_PgCBHeader->base.lowerlvPgCBtb = new lowerlv_PgCBtb;
            if (lv1_PgCBHeader->base.lowerlvPgCBtb == nullptr) {
 400527a:	b8 00 00 00 00       	mov    $0x0,%eax
                return OS_OUT_OF_MEMORY;
 400527f:	c9                   	leave
 4005280:	c3                   	ret
 4005281:	90                   	nop

0000000004005282 <KernelSpacePgsMemMgr::PgCBtb_lv0_entry_construct(unsigned long, pgflags)>:
            }
            gKpoolmemmgr.clear(lv1_PgCBHeader->base.lowerlvPgCBtb);
        }
    
 4005282:	55                   	push   %rbp
 4005283:	48 89 e5             	mov    %rsp,%rbp
 4005286:	48 81 ec 90 00 00 00 	sub    $0x90,%rsp
 400528d:	48 89 7d 88          	mov    %rdi,-0x78(%rbp)
 4005291:	48 89 75 80          	mov    %rsi,-0x80(%rbp)
 4005295:	48 89 95 78 ff ff ff 	mov    %rdx,-0x88(%rbp)

 400529c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%rbp)
    return OS_SUCCESS;
 40052a3:	48 8b 45 80          	mov    -0x80(%rbp),%rax
 40052a7:	48 c1 e8 0c          	shr    $0xc,%rax
 40052ab:	66 25 ff 01          	and    $0x1ff,%ax
 40052af:	66 89 45 e6          	mov    %ax,-0x1a(%rbp)
}
 40052b3:	48 8b 45 80          	mov    -0x80(%rbp),%rax
 40052b7:	48 c1 e8 15          	shr    $0x15,%rax
 40052bb:	66 25 ff 01          	and    $0x1ff,%ax
 40052bf:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)

 40052c3:	48 8b 45 80          	mov    -0x80(%rbp),%rax
 40052c7:	48 c1 e8 1e          	shr    $0x1e,%rax
 40052cb:	66 25 ff 01          	and    $0x1ff,%ax
 40052cf:	66 89 45 e2          	mov    %ax,-0x1e(%rbp)

 40052d3:	48 8b 45 80          	mov    -0x80(%rbp),%rax
 40052d7:	48 c1 e8 27          	shr    $0x27,%rax
 40052db:	66 25 ff 01          	and    $0x1ff,%ax
 40052df:	66 89 45 e0          	mov    %ax,-0x20(%rbp)
int KernelSpacePgsMemMgr::PgCBtb_lv0_entry_construct(phyaddr_t addr, pgflags flags)
 40052e3:	48 8b 45 80          	mov    -0x80(%rbp),%rax
 40052e7:	48 c1 e8 30          	shr    $0x30,%rax
 40052eb:	25 ff 01 00 00       	and    $0x1ff,%eax
 40052f0:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
{
    int status=0;
 40052f4:	0f b6 45 b0          	movzbl -0x50(%rbp),%eax
 40052f8:	83 c8 02             	or     $0x2,%eax
 40052fb:	88 45 b0             	mov    %al,-0x50(%rbp)
    uint16_t lv0_index=(addr&PT_INDEX_MASK_lv0)>>12;
 40052fe:	0f b6 45 b0          	movzbl -0x50(%rbp),%eax
 4005302:	83 e0 fb             	and    $0xfffffffb,%eax
 4005305:	88 45 b0             	mov    %al,-0x50(%rbp)
    uint16_t lv1_index=(addr&PD_INDEX_MASK_lv1)>>21;
    uint16_t lv2_index=(addr&PDPT_INDEX_MASK_lv2)>>30;
 4005308:	0f b6 45 b0          	movzbl -0x50(%rbp),%eax
 400530c:	83 e0 fe             	and    $0xfffffffe,%eax
 400530f:	88 45 b0             	mov    %al,-0x50(%rbp)
    uint16_t lv3_index=(addr&PML4_INDEX_MASK_lv3)>>39;
 4005312:	0f b6 45 b0          	movzbl -0x50(%rbp),%eax
 4005316:	83 c8 20             	or     $0x20,%eax
 4005319:	88 45 b0             	mov    %al,-0x50(%rbp)
    uint64_t lv4_index=(addr&PML5_INDEX_MASK_lv4)>>48;
 400531c:	48 8b 45 88          	mov    -0x78(%rbp),%rax
 4005320:	0f b6 00             	movzbl (%rax),%eax
 4005323:	3c 05                	cmp    $0x5,%al
 4005325:	75 1c                	jne    4005343 <KernelSpacePgsMemMgr::PgCBtb_lv0_entry_construct(unsigned long, pgflags)+0xc1>
 4005327:	48 8b 45 88          	mov    -0x78(%rbp),%rax
 400532b:	48 8b 80 20 10 00 00 	mov    0x1020(%rax),%rax
 4005332:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
 4005336:	48 c1 e2 04          	shl    $0x4,%rdx
 400533a:	48 01 d0             	add    %rdx,%rax
 400533d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
 4005341:	eb 0f                	jmp    4005352 <KernelSpacePgsMemMgr::PgCBtb_lv0_entry_construct(unsigned long, pgflags)+0xd0>
 4005343:	48 8b 45 88          	mov    -0x78(%rbp),%rax
 4005347:	48 8b 80 20 10 00 00 	mov    0x1020(%rax),%rax
 400534e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    pgflags higher_uninitialized_entry_flags;
 4005352:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4005356:	0f b6 00             	movzbl (%rax),%eax
 4005359:	83 e0 02             	and    $0x2,%eax
 400535c:	84 c0                	test   %al,%al
 400535e:	75 35                	jne    4005395 <KernelSpacePgsMemMgr::PgCBtb_lv0_entry_construct(unsigned long, pgflags)+0x113>
    higher_uninitialized_entry_flags.is_exist=1;
    higher_uninitialized_entry_flags.is_atom=0;
 4005360:	0f b6 45 b1          	movzbl -0x4f(%rbp),%eax
 4005364:	83 e0 e3             	and    $0xffffffe3,%eax
 4005367:	83 c8 10             	or     $0x10,%eax
 400536a:	88 45 b1             	mov    %al,-0x4f(%rbp)

 400536d:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
 4005371:	48 8b 4d 80          	mov    -0x80(%rbp),%rcx
 4005375:	48 8b 45 88          	mov    -0x78(%rbp),%rax
 4005379:	48 89 ce             	mov    %rcx,%rsi
 400537c:	48 89 c7             	mov    %rax,%rdi
 400537f:	e8 c2 f6 ff ff       	call   4004a46 <KernelSpacePgsMemMgr::PgCBtb_lv4_entry_construct(unsigned long, pgflags)>
 4005384:	89 45 e8             	mov    %eax,-0x18(%rbp)
    higher_uninitialized_entry_flags.physical_or_virtual_pg=0;
 4005387:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
 400538b:	74 08                	je     4005395 <KernelSpacePgsMemMgr::PgCBtb_lv0_entry_construct(unsigned long, pgflags)+0x113>
    higher_uninitialized_entry_flags.is_kernel=1;
    PgCBlv4header*lv4_PgCBHeader=cpu_pglv==5?&rootlv4PgCBtb[lv4_index]:rootlv4PgCBtb;
 400538d:	8b 45 e8             	mov    -0x18(%rbp),%eax
 4005390:	e9 12 03 00 00       	jmp    40056a7 <KernelSpacePgsMemMgr::PgCBtb_lv0_entry_construct(unsigned long, pgflags)+0x425>
    if(lv4_PgCBHeader->flags.is_exist!=1){
        
        higher_uninitialized_entry_flags.pg_lv=4;
        status=PgCBtb_lv4_entry_construct(addr,higher_uninitialized_entry_flags);
 4005395:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4005399:	48 8b 40 08          	mov    0x8(%rax),%rax
 400539d:	0f b7 55 e0          	movzwl -0x20(%rbp),%edx
 40053a1:	48 63 d2             	movslq %edx,%rdx
 40053a4:	48 c1 e2 04          	shl    $0x4,%rdx
 40053a8:	48 01 d0             	add    %rdx,%rax
 40053ab:	48 83 c0 08          	add    $0x8,%rax
 40053af:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
        if (status!=OS_SUCCESS)
 40053b3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
 40053b7:	0f b6 00             	movzbl (%rax),%eax
 40053ba:	83 e0 02             	and    $0x2,%eax
 40053bd:	84 c0                	test   %al,%al
 40053bf:	75 39                	jne    40053fa <KernelSpacePgsMemMgr::PgCBtb_lv0_entry_construct(unsigned long, pgflags)+0x178>
        {
 40053c1:	0f b6 45 b1          	movzbl -0x4f(%rbp),%eax
 40053c5:	83 e0 e3             	and    $0xffffffe3,%eax
 40053c8:	83 c8 0c             	or     $0xc,%eax
 40053cb:	88 45 b1             	mov    %al,-0x4f(%rbp)
            return status;
 40053ce:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
 40053d2:	48 8b 4d 80          	mov    -0x80(%rbp),%rcx
 40053d6:	48 8b 45 88          	mov    -0x78(%rbp),%rax
 40053da:	48 89 ce             	mov    %rcx,%rsi
 40053dd:	48 89 c7             	mov    %rax,%rdi
 40053e0:	e8 59 f7 ff ff       	call   4004b3e <KernelSpacePgsMemMgr::PgCBtb_lv3_entry_construct(unsigned long, pgflags)>
 40053e5:	89 45 e8             	mov    %eax,-0x18(%rbp)
        }
 40053e8:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
 40053ec:	0f 84 9b 00 00 00    	je     400548d <KernelSpacePgsMemMgr::PgCBtb_lv0_entry_construct(unsigned long, pgflags)+0x20b>
        
    }
 40053f2:	8b 45 e8             	mov    -0x18(%rbp),%eax
 40053f5:	e9 ad 02 00 00       	jmp    40056a7 <KernelSpacePgsMemMgr::PgCBtb_lv0_entry_construct(unsigned long, pgflags)+0x425>
    PgCBlv3header*lv3_PgCBHeader=&lv4_PgCBHeader->base.lowerlvPgCBtb->entries[lv3_index];
    if(lv3_PgCBHeader->flags.is_exist!=1){
        higher_uninitialized_entry_flags.pg_lv=3;
 40053fa:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
 40053fe:	0f b6 00             	movzbl (%rax),%eax
 4005401:	83 e0 04             	and    $0x4,%eax
 4005404:	84 c0                	test   %al,%al
 4005406:	0f 84 81 00 00 00    	je     400548d <KernelSpacePgsMemMgr::PgCBtb_lv0_entry_construct(unsigned long, pgflags)+0x20b>
        status=PgCBtb_lv3_entry_construct(addr,higher_uninitialized_entry_flags);
        if (status!=OS_SUCCESS)
 400540c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
 4005410:	0f b6 10             	movzbl (%rax),%edx
 4005413:	83 e2 fb             	and    $0xfffffffb,%edx
 4005416:	88 10                	mov    %dl,(%rax)
        {
 4005418:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
 400541c:	48 8b 10             	mov    (%rax),%rdx
 400541f:	48 8b 4d 80          	mov    -0x80(%rbp),%rcx
 4005423:	48 8b 45 88          	mov    -0x78(%rbp),%rax
 4005427:	48 89 ce             	mov    %rcx,%rsi
 400542a:	48 89 c7             	mov    %rax,%rdi
 400542d:	e8 74 f8 ff ff       	call   4004ca6 <KernelSpacePgsMemMgr::PgCBtb_lv2_entry_construct(unsigned long, pgflags)>
 4005432:	89 45 e8             	mov    %eax,-0x18(%rbp)
            return status;
 4005435:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
 4005439:	48 8b 00             	mov    (%rax),%rax
 400543c:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
        }
 4005440:	0f b6 45 a8          	movzbl -0x58(%rbp),%eax
 4005444:	83 c8 04             	or     $0x4,%eax
 4005447:	88 45 a8             	mov    %al,-0x58(%rbp)
    }else{
 400544a:	0f b6 45 a9          	movzbl -0x57(%rbp),%eax
 400544e:	83 e0 e3             	and    $0xffffffe3,%eax
 4005451:	83 c8 08             	or     $0x8,%eax
 4005454:	88 45 a9             	mov    %al,-0x57(%rbp)
        if(lv3_PgCBHeader->flags.is_atom==1)
 4005457:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
 400545e:	eb 24                	jmp    4005484 <KernelSpacePgsMemMgr::PgCBtb_lv0_entry_construct(unsigned long, pgflags)+0x202>
        {
            lv3_PgCBHeader->flags.is_atom=0;
 4005460:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
 4005464:	48 8b 40 08          	mov    0x8(%rax),%rax
 4005468:	8b 55 f4             	mov    -0xc(%rbp),%edx
 400546b:	48 63 d2             	movslq %edx,%rdx
 400546e:	48 c1 e2 04          	shl    $0x4,%rdx
 4005472:	48 01 d0             	add    %rdx,%rax
 4005475:	48 8d 50 08          	lea    0x8(%rax),%rdx
 4005479:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
 400547d:	48 89 02             	mov    %rax,(%rdx)
        if(lv3_PgCBHeader->flags.is_atom==1)
 4005480:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
 4005484:	81 7d f4 ff 01 00 00 	cmpl   $0x1ff,-0xc(%rbp)
 400548b:	7e d3                	jle    4005460 <KernelSpacePgsMemMgr::PgCBtb_lv0_entry_construct(unsigned long, pgflags)+0x1de>
            status=PgCBtb_lv2_entry_construct(addr,lv3_PgCBHeader->flags);
            pgflags lv2_flags=lv3_PgCBHeader->flags;
            lv2_flags.is_atom=1;
            lv2_flags.pg_lv=2;
 400548d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
 4005491:	48 8b 40 08          	mov    0x8(%rax),%rax
 4005495:	0f b7 55 e2          	movzwl -0x1e(%rbp),%edx
 4005499:	48 63 d2             	movslq %edx,%rdx
 400549c:	48 c1 e2 04          	shl    $0x4,%rdx
 40054a0:	48 01 d0             	add    %rdx,%rax
 40054a3:	48 83 c0 08          	add    $0x8,%rax
 40054a7:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
            for(int i = 0; i < 512; i++)
 40054ab:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 40054af:	0f b6 00             	movzbl (%rax),%eax
 40054b2:	83 e0 02             	and    $0x2,%eax
 40054b5:	84 c0                	test   %al,%al
 40054b7:	75 39                	jne    40054f2 <KernelSpacePgsMemMgr::PgCBtb_lv0_entry_construct(unsigned long, pgflags)+0x270>
            {
 40054b9:	0f b6 45 b1          	movzbl -0x4f(%rbp),%eax
 40054bd:	83 e0 e3             	and    $0xffffffe3,%eax
 40054c0:	83 c8 08             	or     $0x8,%eax
 40054c3:	88 45 b1             	mov    %al,-0x4f(%rbp)
                lv3_PgCBHeader->base.lowerlvPgCBtb->entries[i].flags=lv2_flags;
 40054c6:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
 40054ca:	48 8b 4d 80          	mov    -0x80(%rbp),%rcx
 40054ce:	48 8b 45 88          	mov    -0x78(%rbp),%rax
 40054d2:	48 89 ce             	mov    %rcx,%rsi
 40054d5:	48 89 c7             	mov    %rax,%rdi
 40054d8:	e8 c9 f7 ff ff       	call   4004ca6 <KernelSpacePgsMemMgr::PgCBtb_lv2_entry_construct(unsigned long, pgflags)>
 40054dd:	89 45 e8             	mov    %eax,-0x18(%rbp)
            }
 40054e0:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
 40054e4:	0f 84 9b 00 00 00    	je     4005585 <KernelSpacePgsMemMgr::PgCBtb_lv0_entry_construct(unsigned long, pgflags)+0x303>
        }
    }
 40054ea:	8b 45 e8             	mov    -0x18(%rbp),%eax
 40054ed:	e9 b5 01 00 00       	jmp    40056a7 <KernelSpacePgsMemMgr::PgCBtb_lv0_entry_construct(unsigned long, pgflags)+0x425>
    PgCBlv2header*lv2_PgCBHeader=&lv3_PgCBHeader->base.lowerlvPgCBtb->entries[lv2_index];
    if(lv2_PgCBHeader->flags.is_exist!=1){
        higher_uninitialized_entry_flags.pg_lv=2;
 40054f2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 40054f6:	0f b6 00             	movzbl (%rax),%eax
 40054f9:	83 e0 04             	and    $0x4,%eax
 40054fc:	84 c0                	test   %al,%al
 40054fe:	0f 84 81 00 00 00    	je     4005585 <KernelSpacePgsMemMgr::PgCBtb_lv0_entry_construct(unsigned long, pgflags)+0x303>
        status=PgCBtb_lv2_entry_construct(addr,higher_uninitialized_entry_flags);
        if (status!=OS_SUCCESS)
 4005504:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 4005508:	0f b6 10             	movzbl (%rax),%edx
 400550b:	83 e2 fb             	and    $0xfffffffb,%edx
 400550e:	88 10                	mov    %dl,(%rax)
        {
 4005510:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 4005514:	48 8b 10             	mov    (%rax),%rdx
 4005517:	48 8b 4d 80          	mov    -0x80(%rbp),%rcx
 400551b:	48 8b 45 88          	mov    -0x78(%rbp),%rax
 400551f:	48 89 ce             	mov    %rcx,%rsi
 4005522:	48 89 c7             	mov    %rax,%rdi
 4005525:	e8 e0 f9 ff ff       	call   4004f0a <KernelSpacePgsMemMgr::PgCBtb_lv1_entry_construct(unsigned long, pgflags)>
 400552a:	89 45 e8             	mov    %eax,-0x18(%rbp)
            return status;
 400552d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 4005531:	48 8b 00             	mov    (%rax),%rax
 4005534:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
        }
 4005538:	0f b6 45 a0          	movzbl -0x60(%rbp),%eax
 400553c:	83 c8 04             	or     $0x4,%eax
 400553f:	88 45 a0             	mov    %al,-0x60(%rbp)
    }else{
 4005542:	0f b6 45 a1          	movzbl -0x5f(%rbp),%eax
 4005546:	83 e0 e3             	and    $0xffffffe3,%eax
 4005549:	83 c8 04             	or     $0x4,%eax
 400554c:	88 45 a1             	mov    %al,-0x5f(%rbp)
        if(lv2_PgCBHeader->flags.is_atom==1)
 400554f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
 4005556:	eb 24                	jmp    400557c <KernelSpacePgsMemMgr::PgCBtb_lv0_entry_construct(unsigned long, pgflags)+0x2fa>
        {
            lv2_PgCBHeader->flags.is_atom=0;
 4005558:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 400555c:	48 8b 40 08          	mov    0x8(%rax),%rax
 4005560:	8b 55 f0             	mov    -0x10(%rbp),%edx
 4005563:	48 63 d2             	movslq %edx,%rdx
 4005566:	48 c1 e2 04          	shl    $0x4,%rdx
 400556a:	48 01 d0             	add    %rdx,%rax
 400556d:	48 8d 50 08          	lea    0x8(%rax),%rdx
 4005571:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
 4005575:	48 89 02             	mov    %rax,(%rdx)
        if(lv2_PgCBHeader->flags.is_atom==1)
 4005578:	83 45 f0 01          	addl   $0x1,-0x10(%rbp)
 400557c:	81 7d f0 ff 01 00 00 	cmpl   $0x1ff,-0x10(%rbp)
 4005583:	7e d3                	jle    4005558 <KernelSpacePgsMemMgr::PgCBtb_lv0_entry_construct(unsigned long, pgflags)+0x2d6>
            status=PgCBtb_lv1_entry_construct(addr,lv2_PgCBHeader->flags);
            pgflags lv1_flags=lv2_PgCBHeader->flags;
            lv1_flags.is_atom=1;
            lv1_flags.pg_lv=1;
 4005585:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 4005589:	48 8b 40 08          	mov    0x8(%rax),%rax
 400558d:	0f b7 55 e4          	movzwl -0x1c(%rbp),%edx
 4005591:	48 63 d2             	movslq %edx,%rdx
 4005594:	48 c1 e2 04          	shl    $0x4,%rdx
 4005598:	48 01 d0             	add    %rdx,%rax
 400559b:	48 83 c0 08          	add    $0x8,%rax
 400559f:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
            for (int i = 0; i < 512; i++)
 40055a3:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
 40055a7:	0f b6 00             	movzbl (%rax),%eax
 40055aa:	83 e0 02             	and    $0x2,%eax
 40055ad:	84 c0                	test   %al,%al
 40055af:	75 39                	jne    40055ea <KernelSpacePgsMemMgr::PgCBtb_lv0_entry_construct(unsigned long, pgflags)+0x368>
            {
 40055b1:	0f b6 45 b1          	movzbl -0x4f(%rbp),%eax
 40055b5:	83 e0 e3             	and    $0xffffffe3,%eax
 40055b8:	83 c8 04             	or     $0x4,%eax
 40055bb:	88 45 b1             	mov    %al,-0x4f(%rbp)
                lv2_PgCBHeader->base.lowerlvPgCBtb->entries[i].flags=lv1_flags;
 40055be:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
 40055c2:	48 8b 4d 80          	mov    -0x80(%rbp),%rcx
 40055c6:	48 8b 45 88          	mov    -0x78(%rbp),%rax
 40055ca:	48 89 ce             	mov    %rcx,%rsi
 40055cd:	48 89 c7             	mov    %rax,%rdi
 40055d0:	e8 35 f9 ff ff       	call   4004f0a <KernelSpacePgsMemMgr::PgCBtb_lv1_entry_construct(unsigned long, pgflags)>
 40055d5:	89 45 e8             	mov    %eax,-0x18(%rbp)
            }        
 40055d8:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
 40055dc:	0f 84 94 00 00 00    	je     4005676 <KernelSpacePgsMemMgr::PgCBtb_lv0_entry_construct(unsigned long, pgflags)+0x3f4>
        }
    }
 40055e2:	8b 45 e8             	mov    -0x18(%rbp),%eax
 40055e5:	e9 bd 00 00 00       	jmp    40056a7 <KernelSpacePgsMemMgr::PgCBtb_lv0_entry_construct(unsigned long, pgflags)+0x425>
    PgCBlv1header*lv1_PgCBHeader=&lv2_PgCBHeader->base.lowerlvPgCBtb->entries[lv1_index];
    if(lv1_PgCBHeader->flags.is_exist!=1){
        higher_uninitialized_entry_flags.pg_lv=1;
 40055ea:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
 40055ee:	0f b6 00             	movzbl (%rax),%eax
 40055f1:	83 e0 04             	and    $0x4,%eax
 40055f4:	84 c0                	test   %al,%al
 40055f6:	74 7e                	je     4005676 <KernelSpacePgsMemMgr::PgCBtb_lv0_entry_construct(unsigned long, pgflags)+0x3f4>
        status=PgCBtb_lv1_entry_construct(addr,higher_uninitialized_entry_flags);
        if (status!=OS_SUCCESS)
 40055f8:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
 40055fc:	0f b6 10             	movzbl (%rax),%edx
 40055ff:	83 e2 fb             	and    $0xfffffffb,%edx
 4005602:	88 10                	mov    %dl,(%rax)
        {
 4005604:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
 4005608:	48 8b 10             	mov    (%rax),%rdx
 400560b:	48 8b 4d 80          	mov    -0x80(%rbp),%rcx
 400560f:	48 8b 45 88          	mov    -0x78(%rbp),%rax
 4005613:	48 89 ce             	mov    %rcx,%rsi
 4005616:	48 89 c7             	mov    %rax,%rdi
 4005619:	e8 ec f8 ff ff       	call   4004f0a <KernelSpacePgsMemMgr::PgCBtb_lv1_entry_construct(unsigned long, pgflags)>
 400561e:	89 45 e8             	mov    %eax,-0x18(%rbp)
            return status;
 4005621:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
 4005625:	48 8b 00             	mov    (%rax),%rax
 4005628:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        }
 400562c:	0f b6 45 98          	movzbl -0x68(%rbp),%eax
 4005630:	83 c8 04             	or     $0x4,%eax
 4005633:	88 45 98             	mov    %al,-0x68(%rbp)
    }else{
 4005636:	0f b6 45 99          	movzbl -0x67(%rbp),%eax
 400563a:	83 e0 e3             	and    $0xffffffe3,%eax
 400563d:	88 45 99             	mov    %al,-0x67(%rbp)
        if(lv1_PgCBHeader->flags.is_atom==1)
 4005640:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
 4005647:	eb 24                	jmp    400566d <KernelSpacePgsMemMgr::PgCBtb_lv0_entry_construct(unsigned long, pgflags)+0x3eb>
        {
            lv1_PgCBHeader->flags.is_atom=0;
 4005649:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
 400564d:	48 8b 40 08          	mov    0x8(%rax),%rax
 4005651:	8b 55 ec             	mov    -0x14(%rbp),%edx
 4005654:	48 63 d2             	movslq %edx,%rdx
 4005657:	48 c1 e2 04          	shl    $0x4,%rdx
 400565b:	48 01 d0             	add    %rdx,%rax
 400565e:	48 8d 50 08          	lea    0x8(%rax),%rdx
 4005662:	48 8b 45 98          	mov    -0x68(%rbp),%rax
 4005666:	48 89 02             	mov    %rax,(%rdx)
        if(lv1_PgCBHeader->flags.is_atom==1)
 4005669:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
 400566d:	81 7d ec ff 01 00 00 	cmpl   $0x1ff,-0x14(%rbp)
 4005674:	7e d3                	jle    4005649 <KernelSpacePgsMemMgr::PgCBtb_lv0_entry_construct(unsigned long, pgflags)+0x3c7>
            status=PgCBtb_lv1_entry_construct(addr,lv1_PgCBHeader->flags);
            pgflags lv0_flags=lv1_PgCBHeader->flags;
            lv0_flags.is_atom=1;
            lv0_flags.pg_lv=0;
 4005676:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
 400567a:	48 8b 40 08          	mov    0x8(%rax),%rax
 400567e:	0f b7 55 e6          	movzwl -0x1a(%rbp),%edx
 4005682:	48 63 d2             	movslq %edx,%rdx
 4005685:	48 c1 e2 04          	shl    $0x4,%rdx
 4005689:	48 01 d0             	add    %rdx,%rax
 400568c:	48 83 c0 08          	add    $0x8,%rax
 4005690:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
            for (int i = 0; i < 512; i++)
 4005694:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 4005698:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
 400569f:	48 89 10             	mov    %rdx,(%rax)
            {
 40056a2:	b8 00 00 00 00       	mov    $0x0,%eax
                lv1_PgCBHeader->base.lowerlvPgCBtb->entries[i].flags=lv0_flags;
 40056a7:	c9                   	leave
 40056a8:	c3                   	ret
 40056a9:	90                   	nop

00000000040056aa <KernelSpacePgsMemMgr::construct_pgsbasedon_phy_memDescriptor(phy_memDesriptor)>:
            }        
        }
 40056aa:	55                   	push   %rbp
 40056ab:	48 89 e5             	mov    %rsp,%rbp
 40056ae:	48 83 ec 60          	sub    $0x60,%rsp
 40056b2:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
    }
    PgCBlv0header*lv0_PgCBHeader=&lv1_PgCBHeader->base.lowerlvPgCBtb->entries[lv0_index];
 40056b6:	8b 45 10             	mov    0x10(%rbp),%eax
 40056b9:	89 45 e4             	mov    %eax,-0x1c(%rbp)
    lv0_PgCBHeader->flags=flags;
 40056bc:	48 8b 45 18          	mov    0x18(%rbp),%rax
 40056c0:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    return OS_SUCCESS;
 40056c4:	48 8b 45 28          	mov    0x28(%rbp),%rax
 40056c8:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
}
 40056cc:	48 8b 45 30          	mov    0x30(%rbp),%rax
 40056d0:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
int KernelSpacePgsMemMgr::construct_pgsbasedon_phy_memDescriptor(phy_memDesriptor memDescriptor)
 40056d4:	b8 00 10 00 00       	mov    $0x1000,%eax
 40056d9:	48 0f af 45 d0       	imul   -0x30(%rbp),%rax
 40056de:	48 89 c2             	mov    %rax,%rdx
 40056e1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 40056e5:	48 01 d0             	add    %rdx,%rax
 40056e8:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
{
    int status;
 40056ec:	b8 00 10 00 00       	mov    $0x1000,%eax
 40056f1:	48 0f af 45 d0       	imul   -0x30(%rbp),%rax
 40056f6:	48 89 c2             	mov    %rax,%rdx
 40056f9:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
 40056fd:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
 4005701:	48 89 ce             	mov    %rcx,%rsi
 4005704:	48 89 c7             	mov    %rax,%rdi
 4005707:	e8 82 1c 00 00       	call   400738e <KernelSpacePgsMemMgr::seg_to_queue(unsigned long, unsigned long)>
 400570c:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    PHY_MEM_TYPE type = (PHY_MEM_TYPE)memDescriptor.Type;
    phyaddr_t base = memDescriptor.PhysicalStart;
    uint64_t numof_4kbgs = memDescriptor.NumberOfPages;
    uint64_t seg_flags = memDescriptor.Attribute;
 4005710:	0f b6 45 b0          	movzbl -0x50(%rbp),%eax
 4005714:	83 e0 fe             	and    $0xfffffffe,%eax
 4005717:	88 45 b0             	mov    %al,-0x50(%rbp)
    phyaddr_t end_addr = base + numof_4kbgs * PAGE_SIZE_IN_LV[0] ; // 结束地址是最后一个字节的地址
 400571a:	0f b6 45 b0          	movzbl -0x50(%rbp),%eax
 400571e:	83 c8 02             	or     $0x2,%eax
 4005721:	88 45 b0             	mov    %al,-0x50(%rbp)
    phyaddr_t scan_addr;
 4005724:	0f b6 45 b0          	movzbl -0x50(%rbp),%eax
 4005728:	83 c8 04             	or     $0x4,%eax
 400572b:	88 45 b0             	mov    %al,-0x50(%rbp)
    phymem_pgs_queue* queue =KernelSpacePgsMemMgr:: seg_to_queue(base,numof_4kbgs * PAGE_SIZE_IN_LV[0]);
 400572e:	0f b6 45 b2          	movzbl -0x4e(%rbp),%eax
 4005732:	83 e0 fe             	and    $0xfffffffe,%eax
 4005735:	88 45 b2             	mov    %al,-0x4e(%rbp)

 4005738:	0f b6 45 b1          	movzbl -0x4f(%rbp),%eax
 400573c:	83 e0 1f             	and    $0x1f,%eax
 400573f:	83 c8 20             	or     $0x20,%eax
 4005742:	88 45 b1             	mov    %al,-0x4f(%rbp)
    flags.cache_strateggy=cache_strategy_t::WB;
// 设置保留标志 - 不可分配的内存
flags.is_reserved = (type == EFI_RESERVED_MEMORY_TYPE || 
                    type == EFI_UNUSABLE_MEMORY || 
                    type == EFI_ACPI_MEMORY_NVS ||
                    type == EFI_MEMORY_MAPPED_IO ||
 4005745:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
 4005749:	74 47                	je     4005792 <KernelSpacePgsMemMgr::construct_pgsbasedon_phy_memDescriptor(phy_memDesriptor)+0xe8>
    pgflags flags;
 400574b:	83 7d e4 08          	cmpl   $0x8,-0x1c(%rbp)
 400574f:	74 41                	je     4005792 <KernelSpacePgsMemMgr::construct_pgsbasedon_phy_memDescriptor(phy_memDesriptor)+0xe8>
    flags.physical_or_virtual_pg = 0; // 物理页
 4005751:	83 7d e4 0a          	cmpl   $0xa,-0x1c(%rbp)
 4005755:	74 3b                	je     4005792 <KernelSpacePgsMemMgr::construct_pgsbasedon_phy_memDescriptor(phy_memDesriptor)+0xe8>
    flags.is_exist = 1; // 存在
 4005757:	83 7d e4 0b          	cmpl   $0xb,-0x1c(%rbp)
 400575b:	74 35                	je     4005792 <KernelSpacePgsMemMgr::construct_pgsbasedon_phy_memDescriptor(phy_memDesriptor)+0xe8>
    flags.is_atom = 1; // 原子节点
 400575d:	83 7d e4 0c          	cmpl   $0xc,-0x1c(%rbp)
 4005761:	74 2f                	je     4005792 <KernelSpacePgsMemMgr::construct_pgsbasedon_phy_memDescriptor(phy_memDesriptor)+0xe8>
    flags.is_global=0;
 4005763:	83 7d e4 0d          	cmpl   $0xd,-0x1c(%rbp)
 4005767:	74 29                	je     4005792 <KernelSpacePgsMemMgr::construct_pgsbasedon_phy_memDescriptor(phy_memDesriptor)+0xe8>
    flags.cache_strateggy=cache_strategy_t::WB;
 4005769:	81 7d e4 00 00 00 70 	cmpl   $0x70000000,-0x1c(%rbp)
 4005770:	74 20                	je     4005792 <KernelSpacePgsMemMgr::construct_pgsbasedon_phy_memDescriptor(phy_memDesriptor)+0xe8>
// 设置保留标志 - 不可分配的内存
 4005772:	81 7d e4 00 00 00 80 	cmpl   $0x80000000,-0x1c(%rbp)
 4005779:	74 17                	je     4005792 <KernelSpacePgsMemMgr::construct_pgsbasedon_phy_memDescriptor(phy_memDesriptor)+0xe8>
flags.is_reserved = (type == EFI_RESERVED_MEMORY_TYPE || 
 400577b:	81 7d e4 ff ff ff 6f 	cmpl   $0x6fffffff,-0x1c(%rbp)
 4005782:	76 07                	jbe    400578b <KernelSpacePgsMemMgr::construct_pgsbasedon_phy_memDescriptor(phy_memDesriptor)+0xe1>
                    type == EFI_UNUSABLE_MEMORY || 
 4005784:	8b 45 e4             	mov    -0x1c(%rbp),%eax
 4005787:	85 c0                	test   %eax,%eax
 4005789:	79 07                	jns    4005792 <KernelSpacePgsMemMgr::construct_pgsbasedon_phy_memDescriptor(phy_memDesriptor)+0xe8>
                    type == EFI_ACPI_MEMORY_NVS ||
 400578b:	8b 45 e4             	mov    -0x1c(%rbp),%eax
                    type == EFI_UNUSABLE_MEMORY || 
 400578e:	85 c0                	test   %eax,%eax
 4005790:	79 07                	jns    4005799 <KernelSpacePgsMemMgr::construct_pgsbasedon_phy_memDescriptor(phy_memDesriptor)+0xef>
                    type == EFI_MEMORY_MAPPED_IO ||
 4005792:	b8 01 00 00 00       	mov    $0x1,%eax
 4005797:	eb 05                	jmp    400579e <KernelSpacePgsMemMgr::construct_pgsbasedon_phy_memDescriptor(phy_memDesriptor)+0xf4>
 4005799:	b8 00 00 00 00       	mov    $0x0,%eax
    pgflags flags;
 400579e:	83 e0 01             	and    $0x1,%eax
 40057a1:	8d 14 c5 00 00 00 00 	lea    0x0(,%rax,8),%edx
 40057a8:	0f b6 45 b0          	movzbl -0x50(%rbp),%eax
 40057ac:	83 e0 f7             	and    $0xfffffff7,%eax
 40057af:	09 d0                	or     %edx,%eax
 40057b1:	88 45 b0             	mov    %al,-0x50(%rbp)
                    type == EFI_MEMORY_MAPPED_IO_PORT_SPACE ||
                    type == EFI_PAL_CODE ||
                    type == MEMORY_TYPE_OEM_RESERVED_MIN || // OEM保留范围
                    type == MEMORY_TYPE_OS_RESERVED_MIN ||  // OS保留范围
                    (type >= MEMORY_TYPE_OEM_RESERVED_MIN && type <= MEMORY_TYPE_OEM_RESERVED_MAX) ||
 40057b4:	83 7d e4 07          	cmpl   $0x7,-0x1c(%rbp)
 40057b8:	74 0d                	je     40057c7 <KernelSpacePgsMemMgr::construct_pgsbasedon_phy_memDescriptor(phy_memDesriptor)+0x11d>
 40057ba:	83 7d e4 0f          	cmpl   $0xf,-0x1c(%rbp)
 40057be:	74 07                	je     40057c7 <KernelSpacePgsMemMgr::construct_pgsbasedon_phy_memDescriptor(phy_memDesriptor)+0x11d>
 40057c0:	b8 01 00 00 00       	mov    $0x1,%eax
 40057c5:	eb 05                	jmp    40057cc <KernelSpacePgsMemMgr::construct_pgsbasedon_phy_memDescriptor(phy_memDesriptor)+0x122>
 40057c7:	b8 00 00 00 00       	mov    $0x0,%eax
                    type == MEMORY_TYPE_OEM_RESERVED_MIN || // OEM保留范围
 40057cc:	83 e0 01             	and    $0x1,%eax
 40057cf:	c1 e0 04             	shl    $0x4,%eax
 40057d2:	89 c2                	mov    %eax,%edx
 40057d4:	0f b6 45 b0          	movzbl -0x50(%rbp),%eax
 40057d8:	83 e0 ef             	and    $0xffffffef,%eax
 40057db:	09 d0                	or     %edx,%eax
 40057dd:	88 45 b0             	mov    %al,-0x50(%rbp)
                    (type >= MEMORY_TYPE_OS_RESERVED_MIN && type <= MEMORY_TYPE_OS_RESERVED_MAX)) 
                    ? 1 : 0;
 40057e0:	0f b6 45 b0          	movzbl -0x50(%rbp),%eax
 40057e4:	83 c8 20             	or     $0x20,%eax
 40057e7:	88 45 b0             	mov    %al,-0x50(%rbp)

 40057ea:	0f b6 45 b0          	movzbl -0x50(%rbp),%eax
 40057ee:	83 c8 40             	or     $0x40,%eax
 40057f1:	88 45 b0             	mov    %al,-0x50(%rbp)
flags.is_kernel = 1; // 物理内存默认为内核内存
flags.is_readable = 1; // 默认可读

// 设置可写标志
flags.is_writable = (type == EFI_LOADER_DATA || 
                    type == EFI_BOOT_SERVICES_DATA || 
 40057f4:	83 7d e4 02          	cmpl   $0x2,-0x1c(%rbp)
 40057f8:	74 2a                	je     4005824 <KernelSpacePgsMemMgr::construct_pgsbasedon_phy_memDescriptor(phy_memDesriptor)+0x17a>
                    type == EFI_UNACCEPTED_MEMORY_TYPE) 
 40057fa:	83 7d e4 04          	cmpl   $0x4,-0x1c(%rbp)
 40057fe:	74 24                	je     4005824 <KernelSpacePgsMemMgr::construct_pgsbasedon_phy_memDescriptor(phy_memDesriptor)+0x17a>
                    ? 0 : 1; // 只有空闲内存和未接受内存是可用的
 4005800:	83 7d e4 06          	cmpl   $0x6,-0x1c(%rbp)
 4005804:	74 1e                	je     4005824 <KernelSpacePgsMemMgr::construct_pgsbasedon_phy_memDescriptor(phy_memDesriptor)+0x17a>

 4005806:	83 7d e4 07          	cmpl   $0x7,-0x1c(%rbp)
 400580a:	74 18                	je     4005824 <KernelSpacePgsMemMgr::construct_pgsbasedon_phy_memDescriptor(phy_memDesriptor)+0x17a>
flags.is_kernel = 1; // 物理内存默认为内核内存
 400580c:	83 7d e4 11          	cmpl   $0x11,-0x1c(%rbp)
 4005810:	74 12                	je     4005824 <KernelSpacePgsMemMgr::construct_pgsbasedon_phy_memDescriptor(phy_memDesriptor)+0x17a>
flags.is_readable = 1; // 默认可读
 4005812:	83 7d e4 13          	cmpl   $0x13,-0x1c(%rbp)
 4005816:	74 0c                	je     4005824 <KernelSpacePgsMemMgr::construct_pgsbasedon_phy_memDescriptor(phy_memDesriptor)+0x17a>

 4005818:	83 7d e4 0f          	cmpl   $0xf,-0x1c(%rbp)
 400581c:	74 06                	je     4005824 <KernelSpacePgsMemMgr::construct_pgsbasedon_phy_memDescriptor(phy_memDesriptor)+0x17a>
// 设置可写标志
 400581e:	83 7d e4 09          	cmpl   $0x9,-0x1c(%rbp)
 4005822:	75 07                	jne    400582b <KernelSpacePgsMemMgr::construct_pgsbasedon_phy_memDescriptor(phy_memDesriptor)+0x181>
                    type == EFI_BOOT_SERVICES_DATA || 
 4005824:	b8 01 00 00 00       	mov    $0x1,%eax
 4005829:	eb 05                	jmp    4005830 <KernelSpacePgsMemMgr::construct_pgsbasedon_phy_memDescriptor(phy_memDesriptor)+0x186>
 400582b:	b8 00 00 00 00       	mov    $0x0,%eax
                    type == EFI_UNACCEPTED_MEMORY_TYPE) 
 4005830:	c1 e0 07             	shl    $0x7,%eax
 4005833:	89 c2                	mov    %eax,%edx
 4005835:	0f b6 45 b0          	movzbl -0x50(%rbp),%eax
 4005839:	83 e0 7f             	and    $0x7f,%eax
 400583c:	09 d0                	or     %edx,%eax
 400583e:	88 45 b0             	mov    %al,-0x50(%rbp)
                    type == freeSystemRam || 
                    type == OS_KERNEL_DATA || 
                    type == OS_KERNEL_STACK ||
                    type == EFI_UNACCEPTED_MEMORY_TYPE ||
                    type == EFI_ACPI_RECLAIM_MEMORY) 
                    ? 1 : 0;
 4005841:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
 4005845:	74 18                	je     400585f <KernelSpacePgsMemMgr::construct_pgsbasedon_phy_memDescriptor(phy_memDesriptor)+0x1b5>
                    type == freeSystemRam || 
 4005847:	83 7d e4 03          	cmpl   $0x3,-0x1c(%rbp)
 400584b:	74 12                	je     400585f <KernelSpacePgsMemMgr::construct_pgsbasedon_phy_memDescriptor(phy_memDesriptor)+0x1b5>
                    type == OS_KERNEL_DATA || 
 400584d:	83 7d e4 05          	cmpl   $0x5,-0x1c(%rbp)
 4005851:	74 0c                	je     400585f <KernelSpacePgsMemMgr::construct_pgsbasedon_phy_memDescriptor(phy_memDesriptor)+0x1b5>
                    type == OS_KERNEL_STACK ||
 4005853:	83 7d e4 12          	cmpl   $0x12,-0x1c(%rbp)
 4005857:	74 06                	je     400585f <KernelSpacePgsMemMgr::construct_pgsbasedon_phy_memDescriptor(phy_memDesriptor)+0x1b5>
                    type == EFI_UNACCEPTED_MEMORY_TYPE ||
 4005859:	83 7d e4 0d          	cmpl   $0xd,-0x1c(%rbp)
 400585d:	75 07                	jne    4005866 <KernelSpacePgsMemMgr::construct_pgsbasedon_phy_memDescriptor(phy_memDesriptor)+0x1bc>
                    ? 1 : 0;
 400585f:	b8 01 00 00 00       	mov    $0x1,%eax
 4005864:	eb 05                	jmp    400586b <KernelSpacePgsMemMgr::construct_pgsbasedon_phy_memDescriptor(phy_memDesriptor)+0x1c1>
 4005866:	b8 00 00 00 00       	mov    $0x0,%eax
                    type == freeSystemRam || 
 400586b:	83 e0 01             	and    $0x1,%eax
 400586e:	89 c2                	mov    %eax,%edx
 4005870:	0f b6 45 b1          	movzbl -0x4f(%rbp),%eax
 4005874:	83 e0 fe             	and    $0xfffffffe,%eax
 4005877:	09 d0                	or     %edx,%eax
 4005879:	88 45 b1             	mov    %al,-0x4f(%rbp)
// 设置可执行标志 - 严格控制执行权限
 400587c:	83 7d e4 05          	cmpl   $0x5,-0x1c(%rbp)
 4005880:	74 06                	je     4005888 <KernelSpacePgsMemMgr::construct_pgsbasedon_phy_memDescriptor(phy_memDesriptor)+0x1de>
 4005882:	83 7d e4 06          	cmpl   $0x6,-0x1c(%rbp)
 4005886:	75 0d                	jne    4005895 <KernelSpacePgsMemMgr::construct_pgsbasedon_phy_memDescriptor(phy_memDesriptor)+0x1eb>
flags.is_executable = (type == EFI_LOADER_CODE || 
 4005888:	0f b6 45 b1          	movzbl -0x4f(%rbp),%eax
 400588c:	83 e0 1f             	and    $0x1f,%eax
 400588f:	83 c8 40             	or     $0x40,%eax
 4005892:	88 45 b1             	mov    %al,-0x4f(%rbp)
                      type == EFI_BOOT_SERVICES_CODE || 
                      type == EFI_RUNTIME_SERVICES_CODE || 
 4005895:	83 7d e4 09          	cmpl   $0x9,-0x1c(%rbp)
 4005899:	75 21                	jne    40058bc <KernelSpacePgsMemMgr::construct_pgsbasedon_phy_memDescriptor(phy_memDesriptor)+0x212>
                      type == OS_KERNEL_CODE ||
                      type == EFI_PAL_CODE) 
 400589b:	0f b6 45 b0          	movzbl -0x50(%rbp),%eax
 400589f:	83 c8 80             	or     $0xffffff80,%eax
 40058a2:	88 45 b0             	mov    %al,-0x50(%rbp)
                      ? 1 : 0;
 40058a5:	0f b6 45 b1          	movzbl -0x4f(%rbp),%eax
 40058a9:	83 e0 fe             	and    $0xfffffffe,%eax
 40058ac:	88 45 b1             	mov    %al,-0x4f(%rbp)
if(type==EFI_RUNTIME_SERVICES_CODE||type==EFI_RUNTIME_SERVICES_DATA)
 40058af:	0f b6 45 b1          	movzbl -0x4f(%rbp),%eax
 40058b3:	83 e0 1f             	and    $0x1f,%eax
 40058b6:	83 c8 40             	or     $0x40,%eax
 40058b9:	88 45 b1             	mov    %al,-0x4f(%rbp)
flags.cache_strateggy=cache_strategy_t::WT;
// 特殊处理ACPI内存
if (type == EFI_ACPI_RECLAIM_MEMORY) {
 40058bc:	83 7d e4 0a          	cmpl   $0xa,-0x1c(%rbp)
 40058c0:	75 21                	jne    40058e3 <KernelSpacePgsMemMgr::construct_pgsbasedon_phy_memDescriptor(phy_memDesriptor)+0x239>
    // ACPI回收内存：可读写但不可执行
    flags.is_writable = 1;
 40058c2:	0f b6 45 b0          	movzbl -0x50(%rbp),%eax
 40058c6:	83 e0 7f             	and    $0x7f,%eax
 40058c9:	88 45 b0             	mov    %al,-0x50(%rbp)
    flags.is_executable = 0;
 40058cc:	0f b6 45 b1          	movzbl -0x4f(%rbp),%eax
 40058d0:	83 e0 fe             	and    $0xfffffffe,%eax
 40058d3:	88 45 b1             	mov    %al,-0x4f(%rbp)
    flags.cache_strateggy=cache_strategy_t::WT;
 40058d6:	0f b6 45 b1          	movzbl -0x4f(%rbp),%eax
 40058da:	83 e0 1f             	and    $0x1f,%eax
 40058dd:	83 c8 60             	or     $0x60,%eax
 40058e0:	88 45 b1             	mov    %al,-0x4f(%rbp)
}

if (type == EFI_ACPI_MEMORY_NVS) {
 40058e3:	83 7d e4 0b          	cmpl   $0xb,-0x1c(%rbp)
 40058e7:	74 06                	je     40058ef <KernelSpacePgsMemMgr::construct_pgsbasedon_phy_memDescriptor(phy_memDesriptor)+0x245>
 40058e9:	83 7d e4 0c          	cmpl   $0xc,-0x1c(%rbp)
 40058ed:	75 2b                	jne    400591a <KernelSpacePgsMemMgr::construct_pgsbasedon_phy_memDescriptor(phy_memDesriptor)+0x270>
    // ACPI NVS内存：只读，不可写不可执行
    flags.is_writable = 0;
    flags.is_executable = 0;
 40058ef:	0f b6 45 b0          	movzbl -0x50(%rbp),%eax
 40058f3:	83 c8 80             	or     $0xffffff80,%eax
 40058f6:	88 45 b0             	mov    %al,-0x50(%rbp)
    flags.cache_strateggy=cache_strategy_t::UC;
 40058f9:	0f b6 45 b1          	movzbl -0x4f(%rbp),%eax
 40058fd:	83 e0 fe             	and    $0xfffffffe,%eax
 4005900:	88 45 b1             	mov    %al,-0x4f(%rbp)
}
 4005903:	0f b6 45 b0          	movzbl -0x50(%rbp),%eax
 4005907:	83 c8 08             	or     $0x8,%eax
 400590a:	88 45 b0             	mov    %al,-0x50(%rbp)

 400590d:	0f b6 45 b1          	movzbl -0x4f(%rbp),%eax
 4005911:	83 e0 1f             	and    $0x1f,%eax
 4005914:	83 c8 60             	or     $0x60,%eax
 4005917:	88 45 b1             	mov    %al,-0x4f(%rbp)
if (type == EFI_MEMORY_MAPPED_IO || type == EFI_MEMORY_MAPPED_IO_PORT_SPACE) {
    // MMIO区域：根据架构可能需要特殊处理
    // 通常可读写但不可执行
 400591a:	83 7d e4 0e          	cmpl   $0xe,-0x1c(%rbp)
 400591e:	75 14                	jne    4005934 <KernelSpacePgsMemMgr::construct_pgsbasedon_phy_memDescriptor(phy_memDesriptor)+0x28a>
    flags.is_writable = 1;
    flags.is_executable = 0;
 4005920:	0f b6 45 b0          	movzbl -0x50(%rbp),%eax
 4005924:	83 c8 80             	or     $0xffffff80,%eax
 4005927:	88 45 b0             	mov    %al,-0x50(%rbp)
    flags.is_reserved = 1; // MMIO必须保留
 400592a:	0f b6 45 b1          	movzbl -0x4f(%rbp),%eax
 400592e:	83 e0 fe             	and    $0xfffffffe,%eax
 4005931:	88 45 b1             	mov    %al,-0x4f(%rbp)
    flags.cache_strateggy=cache_strategy_t::UC;
}

if (type == EFI_PERSISTENT_MEMORY) {
 4005934:	83 7d e4 13          	cmpl   $0x13,-0x1c(%rbp)
 4005938:	75 14                	jne    400594e <KernelSpacePgsMemMgr::construct_pgsbasedon_phy_memDescriptor(phy_memDesriptor)+0x2a4>
    // 持久内存：可读写，是否可执行取决于用途
    flags.is_writable = 1;
 400593a:	0f b6 45 b0          	movzbl -0x50(%rbp),%eax
 400593e:	83 c8 80             	or     $0xffffff80,%eax
 4005941:	88 45 b0             	mov    %al,-0x50(%rbp)
    flags.is_executable = 0; // 默认不可执行，需要时再设置
 4005944:	0f b6 45 b1          	movzbl -0x4f(%rbp),%eax
 4005948:	83 e0 fe             	and    $0xfffffffe,%eax
 400594b:	88 45 b1             	mov    %al,-0x4f(%rbp)
}

// 内核特定类型
 400594e:	83 7d e4 11          	cmpl   $0x11,-0x1c(%rbp)
 4005952:	75 1e                	jne    4005972 <KernelSpacePgsMemMgr::construct_pgsbasedon_phy_memDescriptor(phy_memDesriptor)+0x2c8>
if (type == OS_KERNEL_STACK) {
    // 内核栈：可读写但不可执行（防止栈执行攻击）
 4005954:	0f b6 45 b0          	movzbl -0x50(%rbp),%eax
 4005958:	83 c8 80             	or     $0xffffff80,%eax
 400595b:	88 45 b0             	mov    %al,-0x50(%rbp)
    flags.is_writable = 1;
 400595e:	0f b6 45 b1          	movzbl -0x4f(%rbp),%eax
 4005962:	83 e0 fe             	and    $0xfffffffe,%eax
 4005965:	88 45 b1             	mov    %al,-0x4f(%rbp)
    flags.is_executable = 0;
 4005968:	0f b6 45 b2          	movzbl -0x4e(%rbp),%eax
 400596c:	83 c8 01             	or     $0x1,%eax
 400596f:	88 45 b2             	mov    %al,-0x4e(%rbp)
}

if (type == OS_KERNEL_DATA) {
 4005972:	83 7d e4 12          	cmpl   $0x12,-0x1c(%rbp)
 4005976:	75 1e                	jne    4005996 <KernelSpacePgsMemMgr::construct_pgsbasedon_phy_memDescriptor(phy_memDesriptor)+0x2ec>
    // 内核数据：可读写不可执行
    flags.is_writable = 1;
 4005978:	0f b6 45 b0          	movzbl -0x50(%rbp),%eax
 400597c:	83 e0 7f             	and    $0x7f,%eax
 400597f:	88 45 b0             	mov    %al,-0x50(%rbp)
    flags.is_executable = 0;
 4005982:	0f b6 45 b1          	movzbl -0x4f(%rbp),%eax
 4005986:	83 c8 01             	or     $0x1,%eax
 4005989:	88 45 b1             	mov    %al,-0x4f(%rbp)
    flags.is_global = 1;
 400598c:	0f b6 45 b2          	movzbl -0x4e(%rbp),%eax
 4005990:	83 c8 01             	or     $0x1,%eax
 4005993:	88 45 b2             	mov    %al,-0x4e(%rbp)
}

if (type == OS_KERNEL_CODE) {
    // 内核代码：可读可执行但不可写（代码保护）
 4005996:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 400599a:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    flags.is_writable = 0;
 400599e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
 40059a5:	e9 89 01 00 00       	jmp    4005b33 <KernelSpacePgsMemMgr::construct_pgsbasedon_phy_memDescriptor(phy_memDesriptor)+0x489>
    flags.is_executable = 1;
    flags.is_global = 1;
 40059aa:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%rbp)
 40059b1:	e9 52 01 00 00       	jmp    4005b08 <KernelSpacePgsMemMgr::construct_pgsbasedon_phy_memDescriptor(phy_memDesriptor)+0x45e>
}
    
 40059b6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 40059ba:	8b 55 ec             	mov    -0x14(%rbp),%edx
 40059bd:	48 63 d2             	movslq %edx,%rdx
 40059c0:	48 c1 e2 04          	shl    $0x4,%rdx
 40059c4:	48 01 d0             	add    %rdx,%rax
 40059c7:	48 83 c0 10          	add    $0x10,%rax
 40059cb:	0f b6 00             	movzbl (%rax),%eax
 40059ce:	83 e0 07             	and    $0x7,%eax
 40059d1:	83 e0 07             	and    $0x7,%eax
 40059d4:	8d 14 85 00 00 00 00 	lea    0x0(,%rax,4),%edx
 40059db:	0f b6 45 b1          	movzbl -0x4f(%rbp),%eax
 40059df:	83 e0 e3             	and    $0xffffffe3,%eax
 40059e2:	09 d0                	or     %edx,%eax
 40059e4:	88 45 b1             	mov    %al,-0x4f(%rbp)
    // 根据队列创建页表项
    scan_addr = base;
    for (int i = 0; i < queue->entry_count; i++)
 40059e7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 40059eb:	8b 55 ec             	mov    -0x14(%rbp),%edx
 40059ee:	48 63 d2             	movslq %edx,%rdx
 40059f1:	48 c1 e2 04          	shl    $0x4,%rdx
 40059f5:	48 01 d0             	add    %rdx,%rax
 40059f8:	48 83 c0 10          	add    $0x10,%rax
 40059fc:	0f b6 00             	movzbl (%rax),%eax
 40059ff:	3c 04                	cmp    $0x4,%al
 4005a01:	77 7e                	ja     4005a81 <KernelSpacePgsMemMgr::construct_pgsbasedon_phy_memDescriptor(phy_memDesriptor)+0x3d7>
    {
        for (int j = 0; j < queue->entry[i].pgs_count; j++)
 4005a03:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
 4005a07:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 4005a0b:	8b 55 ec             	mov    -0x14(%rbp),%edx
 4005a0e:	48 63 d2             	movslq %edx,%rdx
 4005a11:	48 c1 e2 04          	shl    $0x4,%rdx
 4005a15:	48 01 d0             	add    %rdx,%rax
 4005a18:	48 83 c0 10          	add    $0x10,%rax
 4005a1c:	0f b6 00             	movzbl (%rax),%eax
 4005a1f:	0f b6 d0             	movzbl %al,%edx
 4005a22:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
 4005a26:	48 63 d2             	movslq %edx,%rdx
 4005a29:	48 81 c2 02 01 00 00 	add    $0x102,%rdx
 4005a30:	48 c1 e2 04          	shl    $0x4,%rdx
 4005a34:	48 01 d0             	add    %rdx,%rax
 4005a37:	48 8b 50 10          	mov    0x10(%rax),%rdx
 4005a3b:	48 8b 40 08          	mov    0x8(%rax),%rax
 4005a3f:	48 89 c6             	mov    %rax,%rsi
 4005a42:	83 e6 01             	and    $0x1,%esi
 4005a45:	48 85 f6             	test   %rsi,%rsi
 4005a48:	74 18                	je     4005a62 <KernelSpacePgsMemMgr::construct_pgsbasedon_phy_memDescriptor(phy_memDesriptor)+0x3b8>
 4005a4a:	48 89 d6             	mov    %rdx,%rsi
 4005a4d:	48 01 ce             	add    %rcx,%rsi
 4005a50:	48 8b 36             	mov    (%rsi),%rsi
 4005a53:	48 89 c7             	mov    %rax,%rdi
 4005a56:	48 83 ef 01          	sub    $0x1,%rdi
 4005a5a:	48 01 fe             	add    %rdi,%rsi
 4005a5d:	4c 8b 06             	mov    (%rsi),%r8
 4005a60:	eb 03                	jmp    4005a65 <KernelSpacePgsMemMgr::construct_pgsbasedon_phy_memDescriptor(phy_memDesriptor)+0x3bb>
 4005a62:	49 89 c0             	mov    %rax,%r8
 4005a65:	48 89 d0             	mov    %rdx,%rax
 4005a68:	48 01 c1             	add    %rax,%rcx
 4005a6b:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
 4005a6f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 4005a73:	48 89 c6             	mov    %rax,%rsi
 4005a76:	48 89 cf             	mov    %rcx,%rdi
 4005a79:	41 ff d0             	call   *%r8
 4005a7c:	89 45 fc             	mov    %eax,-0x4(%rbp)
 4005a7f:	eb 07                	jmp    4005a88 <KernelSpacePgsMemMgr::construct_pgsbasedon_phy_memDescriptor(phy_memDesriptor)+0x3de>
        {
            flags.pg_lv = queue->entry[i].pgs_lv;
            
  // 使用函数指针数组调用对应的构造函数
 4005a81:	c7 45 fc 03 10 00 00 	movl   $0x1003,-0x4(%rbp)
            if (queue->entry[i].pgs_lv >= 0 && queue->entry[i].pgs_lv <= 4)
            {
                status = (this->*PgCBtb_construct_func[queue->entry[i].pgs_lv])(scan_addr, flags);
 4005a88:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
 4005a8c:	74 42                	je     4005ad0 <KernelSpacePgsMemMgr::construct_pgsbasedon_phy_memDescriptor(phy_memDesriptor)+0x426>
            }
            else
 4005a8e:	48 8d 05 eb a5 7f 00 	lea    0x7fa5eb(%rip),%rax        # 4800080 <gKpoolmemmgr>
 4005a95:	48 89 c7             	mov    %rax,%rdi
 4005a98:	e8 75 dc ff ff       	call   4003712 <kpoolmemmgr_t::getFirst_static_heap()>
 4005a9d:	48 89 c2             	mov    %rax,%rdx
 4005aa0:	48 8d 05 d9 a5 7f 00 	lea    0x7fa5d9(%rip),%rax        # 4800080 <gKpoolmemmgr>
 4005aa7:	48 89 d6             	mov    %rdx,%rsi
 4005aaa:	48 89 c7             	mov    %rax,%rdi
 4005aad:	e8 f6 e5 ff ff       	call   40040a8 <kpoolmemmgr_t::print_meta_table(HCB_chainlist_node*)>
            {
 4005ab2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 4005ab6:	48 85 c0             	test   %rax,%rax
 4005ab9:	74 0d                	je     4005ac8 <KernelSpacePgsMemMgr::construct_pgsbasedon_phy_memDescriptor(phy_memDesriptor)+0x41e>
 4005abb:	be a8 00 00 00       	mov    $0xa8,%esi
 4005ac0:	48 89 c7             	mov    %rax,%rdi
 4005ac3:	e8 e6 eb ff ff       	call   40046ae <operator delete(void*, unsigned long)>
                status = OS_INVALID_PARAMETER;
 4005ac8:	8b 45 fc             	mov    -0x4(%rbp),%eax
 4005acb:	e9 91 00 00 00       	jmp    4005b61 <KernelSpacePgsMemMgr::construct_pgsbasedon_phy_memDescriptor(phy_memDesriptor)+0x4b7>
            }
            
            if (status != OS_SUCCESS)
 4005ad0:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 4005ad4:	8b 55 ec             	mov    -0x14(%rbp),%edx
 4005ad7:	48 63 d2             	movslq %edx,%rdx
 4005ada:	48 c1 e2 04          	shl    $0x4,%rdx
 4005ade:	48 01 d0             	add    %rdx,%rax
 4005ae1:	48 83 c0 10          	add    $0x10,%rax
 4005ae5:	0f b6 00             	movzbl (%rax),%eax
 4005ae8:	0f b6 c0             	movzbl %al,%eax
 4005aeb:	48 98                	cltq
 4005aed:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
 4005af4:	00 
 4005af5:	48 8d 05 84 a3 00 00 	lea    0xa384(%rip),%rax        # 400fe80 <PAGE_SIZE_IN_LV>
 4005afc:	48 8b 04 02          	mov    (%rdx,%rax,1),%rax
 4005b00:	48 01 45 f0          	add    %rax,-0x10(%rbp)
    flags.is_global = 1;
 4005b04:	83 45 e8 01          	addl   $0x1,-0x18(%rbp)
 4005b08:	8b 45 e8             	mov    -0x18(%rbp),%eax
 4005b0b:	48 63 d0             	movslq %eax,%rdx
 4005b0e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 4005b12:	8b 4d ec             	mov    -0x14(%rbp),%ecx
 4005b15:	48 63 c9             	movslq %ecx,%rcx
 4005b18:	48 c1 e1 04          	shl    $0x4,%rcx
 4005b1c:	48 01 c8             	add    %rcx,%rax
 4005b1f:	48 83 c0 08          	add    $0x8,%rax
 4005b23:	48 8b 00             	mov    (%rax),%rax
 4005b26:	48 39 c2             	cmp    %rax,%rdx
 4005b29:	0f 82 87 fe ff ff    	jb     40059b6 <KernelSpacePgsMemMgr::construct_pgsbasedon_phy_memDescriptor(phy_memDesriptor)+0x30c>
    flags.is_writable = 0;
 4005b2f:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
 4005b33:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 4005b37:	0f b6 00             	movzbl (%rax),%eax
 4005b3a:	0f b6 c0             	movzbl %al,%eax
 4005b3d:	39 45 ec             	cmp    %eax,-0x14(%rbp)
 4005b40:	0f 8c 64 fe ff ff    	jl     40059aa <KernelSpacePgsMemMgr::construct_pgsbasedon_phy_memDescriptor(phy_memDesriptor)+0x300>
            {
                gKpoolmemmgr.print_meta_table(gKpoolmemmgr.getFirst_static_heap());
                delete queue;
                return status;
 4005b46:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 4005b4a:	48 85 c0             	test   %rax,%rax
 4005b4d:	74 0d                	je     4005b5c <KernelSpacePgsMemMgr::construct_pgsbasedon_phy_memDescriptor(phy_memDesriptor)+0x4b2>
 4005b4f:	be a8 00 00 00       	mov    $0xa8,%esi
 4005b54:	48 89 c7             	mov    %rax,%rdi
 4005b57:	e8 52 eb ff ff       	call   40046ae <operator delete(void*, unsigned long)>
            }
 4005b5c:	b8 00 00 00 00       	mov    $0x0,%eax
            
 4005b61:	c9                   	leave
 4005b62:	c3                   	ret

0000000004005b63 <__static_initialization_and_destruction_0()>:
 4005b63:	55                   	push   %rbp
 4005b64:	48 89 e5             	mov    %rsp,%rbp
KernelSpacePgsMemMgr gKspacePgsMemMgr;
 4005b67:	48 8d 05 92 65 80 00 	lea    0x806592(%rip),%rax        # 480c100 <gKspacePgsMemMgr>
 4005b6e:	48 89 c7             	mov    %rax,%rdi
 4005b71:	e8 0e 00 00 00       	call   4005b84 <KernelSpacePgsMemMgr::KernelSpacePgsMemMgr()>
            
 4005b76:	90                   	nop
 4005b77:	5d                   	pop    %rbp
 4005b78:	c3                   	ret

0000000004005b79 <_GLOBAL__sub_I_gKspacePgsMemMgr>:
 4005b79:	55                   	push   %rbp
 4005b7a:	48 89 e5             	mov    %rsp,%rbp
 4005b7d:	e8 e1 ff ff ff       	call   4005b63 <__static_initialization_and_destruction_0()>
 4005b82:	5d                   	pop    %rbp
 4005b83:	c3                   	ret

0000000004005b84 <KernelSpacePgsMemMgr::KernelSpacePgsMemMgr()>:
struct pgs_queue_entry_t
{
    uint64_t pgs_count;
    uint8_t pgs_lv;
    uint8_t reserved;
};
 4005b84:	55                   	push   %rbp
 4005b85:	48 89 e5             	mov    %rsp,%rbp
 4005b88:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
 4005b8c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4005b90:	48 c7 80 20 10 00 00 	movq   $0x0,0x1020(%rax)
 4005b97:	00 00 00 00 
 4005b9b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4005b9f:	48 8d 15 dc f6 ff ff 	lea    -0x924(%rip),%rdx        # 4005282 <KernelSpacePgsMemMgr::PgCBtb_lv0_entry_construct(unsigned long, pgflags)>
 4005ba6:	48 89 90 28 10 00 00 	mov    %rdx,0x1028(%rax)
 4005bad:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4005bb1:	48 c7 80 30 10 00 00 	movq   $0x0,0x1030(%rax)
 4005bb8:	00 00 00 00 
 4005bbc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4005bc0:	48 8d 15 43 f3 ff ff 	lea    -0xcbd(%rip),%rdx        # 4004f0a <KernelSpacePgsMemMgr::PgCBtb_lv1_entry_construct(unsigned long, pgflags)>
 4005bc7:	48 89 90 38 10 00 00 	mov    %rdx,0x1038(%rax)
 4005bce:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4005bd2:	48 c7 80 40 10 00 00 	movq   $0x0,0x1040(%rax)
 4005bd9:	00 00 00 00 
 4005bdd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4005be1:	48 8d 15 be f0 ff ff 	lea    -0xf42(%rip),%rdx        # 4004ca6 <KernelSpacePgsMemMgr::PgCBtb_lv2_entry_construct(unsigned long, pgflags)>
 4005be8:	48 89 90 48 10 00 00 	mov    %rdx,0x1048(%rax)
 4005bef:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4005bf3:	48 c7 80 50 10 00 00 	movq   $0x0,0x1050(%rax)
 4005bfa:	00 00 00 00 
 4005bfe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4005c02:	48 8d 15 35 ef ff ff 	lea    -0x10cb(%rip),%rdx        # 4004b3e <KernelSpacePgsMemMgr::PgCBtb_lv3_entry_construct(unsigned long, pgflags)>
 4005c09:	48 89 90 58 10 00 00 	mov    %rdx,0x1058(%rax)
 4005c10:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4005c14:	48 c7 80 60 10 00 00 	movq   $0x0,0x1060(%rax)
 4005c1b:	00 00 00 00 
 4005c1f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4005c23:	48 8d 15 1c ee ff ff 	lea    -0x11e4(%rip),%rdx        # 4004a46 <KernelSpacePgsMemMgr::PgCBtb_lv4_entry_construct(unsigned long, pgflags)>
 4005c2a:	48 89 90 68 10 00 00 	mov    %rdx,0x1068(%rax)
 4005c31:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4005c35:	48 c7 80 70 10 00 00 	movq   $0x0,0x1070(%rax)
 4005c3c:	00 00 00 00 
 4005c40:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4005c44:	48 c7 c2 e8 78 00 04 	mov    $0x40078e8,%rdx
 4005c4b:	48 89 90 78 10 00 00 	mov    %rdx,0x1078(%rax)
 4005c52:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4005c56:	48 c7 80 80 10 00 00 	movq   $0x0,0x1080(%rax)
 4005c5d:	00 00 00 00 
 4005c61:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4005c65:	48 c7 c2 a6 77 00 04 	mov    $0x40077a6,%rdx
 4005c6c:	48 89 90 88 10 00 00 	mov    %rdx,0x1088(%rax)
 4005c73:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4005c77:	48 c7 80 90 10 00 00 	movq   $0x0,0x1090(%rax)
 4005c7e:	00 00 00 00 
 4005c82:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4005c86:	48 c7 c2 b8 76 00 04 	mov    $0x40076b8,%rdx
 4005c8d:	48 89 90 98 10 00 00 	mov    %rdx,0x1098(%rax)
 4005c94:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4005c98:	48 c7 80 a0 10 00 00 	movq   $0x0,0x10a0(%rax)
 4005c9f:	00 00 00 00 
 4005ca3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4005ca7:	48 c7 c2 1c 76 00 04 	mov    $0x400761c,%rdx
 4005cae:	48 89 90 a8 10 00 00 	mov    %rdx,0x10a8(%rax)
 4005cb5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4005cb9:	48 c7 80 b0 10 00 00 	movq   $0x0,0x10b0(%rax)
 4005cc0:	00 00 00 00 
 4005cc4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4005cc8:	48 c7 c2 ea 75 00 04 	mov    $0x40075ea,%rdx
 4005ccf:	48 89 90 b8 10 00 00 	mov    %rdx,0x10b8(%rax)
 4005cd6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4005cda:	48 c7 80 c0 10 00 00 	movq   $0x0,0x10c0(%rax)
 4005ce1:	00 00 00 00 
 4005ce5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4005ce9:	0f b6 15 b4 a4 00 00 	movzbl 0xa4b4(%rip),%edx        # 40101a4 <INDEX_NOT_EXIST+0x4>
 4005cf0:	88 90 c8 10 00 00    	mov    %dl,0x10c8(%rax)
 4005cf6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4005cfa:	0f b6 15 a4 a4 00 00 	movzbl 0xa4a4(%rip),%edx        # 40101a5 <INDEX_NOT_EXIST+0x5>
 4005d01:	88 90 c9 10 00 00    	mov    %dl,0x10c9(%rax)
 4005d07:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4005d0b:	0f b6 15 94 a4 00 00 	movzbl 0xa494(%rip),%edx        # 40101a6 <INDEX_NOT_EXIST+0x6>
 4005d12:	88 90 ca 10 00 00    	mov    %dl,0x10ca(%rax)
 4005d18:	90                   	nop
 4005d19:	5d                   	pop    %rbp
 4005d1a:	c3                   	ret
 4005d1b:	90                   	nop

0000000004005d1c <KernelSpacePgsMemMgr::PrintPgsMemMgrStructure()>:
#include "phygpsmemmgr.h"
#include "VideoDriver.h"

void KernelSpacePgsMemMgr::PrintPgsMemMgrStructure()
{
 4005d1c:	55                   	push   %rbp
 4005d1d:	48 89 e5             	mov    %rsp,%rbp
 4005d20:	48 83 ec 20          	sub    $0x20,%rsp
 4005d24:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    kputsSecure("=== Page Table Structure ===\n");
 4005d28:	48 8d 05 d1 a7 00 00 	lea    0xa7d1(%rip),%rax        # 4010500 <NullPgControlBlockHeader+0x10>
 4005d2f:	48 89 c7             	mov    %rax,%rdi
 4005d32:	e8 8e 44 00 00       	call   400a1c5 <kputsSecure>
    
    // 打印基本信息
    kputsSecure("CPU Page Level: ");
 4005d37:	48 8d 05 e0 a7 00 00 	lea    0xa7e0(%rip),%rax        # 401051e <NullPgControlBlockHeader+0x2e>
 4005d3e:	48 89 c7             	mov    %rax,%rdi
 4005d41:	e8 7f 44 00 00       	call   400a1c5 <kputsSecure>
    kputsSecure(" (");
 4005d46:	48 8d 05 e2 a7 00 00 	lea    0xa7e2(%rip),%rax        # 401052f <NullPgControlBlockHeader+0x3f>
 4005d4d:	48 89 c7             	mov    %rax,%rdi
 4005d50:	e8 70 44 00 00       	call   400a1c5 <kputsSecure>
    kpnumSecure(&cpu_pglv, UNHEX, 1);
 4005d55:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4005d59:	ba 01 00 00 00       	mov    $0x1,%edx
 4005d5e:	be 05 00 00 00       	mov    $0x5,%esi
 4005d63:	48 89 c7             	mov    %rax,%rdi
 4005d66:	e8 9b 45 00 00       	call   400a306 <kpnumSecure>
    kputsSecure(")\n");
 4005d6b:	48 8d 05 c0 a7 00 00 	lea    0xa7c0(%rip),%rax        # 4010532 <NullPgControlBlockHeader+0x42>
 4005d72:	48 89 c7             	mov    %rax,%rdi
 4005d75:	e8 4b 44 00 00       	call   400a1c5 <kputsSecure>

    

    
    // 打印各级页表结构
    if (cpu_pglv == 5)
 4005d7a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4005d7e:	0f b6 00             	movzbl (%rax),%eax
 4005d81:	3c 05                	cmp    $0x5,%al
 4005d83:	0f 85 2f 01 00 00    	jne    4005eb8 <KernelSpacePgsMemMgr::PrintPgsMemMgrStructure()+0x19c>
    {
        // 五级页表模式
        for (int i = 0; i < 512; i++)
 4005d89:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
 4005d90:	e9 10 01 00 00       	jmp    4005ea5 <KernelSpacePgsMemMgr::PrintPgsMemMgrStructure()+0x189>
        {
            if (rootlv4PgCBtb[i].flags.is_exist)
 4005d95:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4005d99:	48 8b 80 20 10 00 00 	mov    0x1020(%rax),%rax
 4005da0:	8b 55 fc             	mov    -0x4(%rbp),%edx
 4005da3:	48 63 d2             	movslq %edx,%rdx
 4005da6:	48 c1 e2 04          	shl    $0x4,%rdx
 4005daa:	48 01 d0             	add    %rdx,%rax
 4005dad:	0f b6 00             	movzbl (%rax),%eax
 4005db0:	83 e0 02             	and    $0x2,%eax
 4005db3:	84 c0                	test   %al,%al
 4005db5:	0f 84 e1 00 00 00    	je     4005e9c <KernelSpacePgsMemMgr::PrintPgsMemMgrStructure()+0x180>
            {
                kputsSecure("PML5[");
 4005dbb:	48 8d 05 73 a7 00 00 	lea    0xa773(%rip),%rax        # 4010535 <NullPgControlBlockHeader+0x45>
 4005dc2:	48 89 c7             	mov    %rax,%rdi
 4005dc5:	e8 fb 43 00 00       	call   400a1c5 <kputsSecure>
                kpnumSecure(&i, UNDEC, 3);
 4005dca:	48 8d 45 fc          	lea    -0x4(%rbp),%rax
 4005dce:	ba 03 00 00 00       	mov    $0x3,%edx
 4005dd3:	be 03 00 00 00       	mov    $0x3,%esi
 4005dd8:	48 89 c7             	mov    %rax,%rdi
 4005ddb:	e8 26 45 00 00       	call   400a306 <kpnumSecure>
                kputsSecure("]: ");
 4005de0:	48 8d 05 54 a7 00 00 	lea    0xa754(%rip),%rax        # 401053b <NullPgControlBlockHeader+0x4b>
 4005de7:	48 89 c7             	mov    %rax,%rdi
 4005dea:	e8 d6 43 00 00       	call   400a1c5 <kputsSecure>
                PrintPageTableEntry(&rootlv4PgCBtb[i], 4);
 4005def:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4005df3:	48 8b 80 20 10 00 00 	mov    0x1020(%rax),%rax
 4005dfa:	8b 55 fc             	mov    -0x4(%rbp),%edx
 4005dfd:	48 63 d2             	movslq %edx,%rdx
 4005e00:	48 c1 e2 04          	shl    $0x4,%rdx
 4005e04:	48 8d 0c 10          	lea    (%rax,%rdx,1),%rcx
 4005e08:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4005e0c:	ba 04 00 00 00       	mov    $0x4,%edx
 4005e11:	48 89 ce             	mov    %rcx,%rsi
 4005e14:	48 89 c7             	mov    %rax,%rdi
 4005e17:	e8 12 07 00 00       	call   400652e <KernelSpacePgsMemMgr::PrintPageTableEntry(PgControlBlockHeader*, int)>
                
                // 打印下一级
                if (!rootlv4PgCBtb[i].flags.is_atom && rootlv4PgCBtb[i].base.lowerlvPgCBtb)
 4005e1c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4005e20:	48 8b 80 20 10 00 00 	mov    0x1020(%rax),%rax
 4005e27:	8b 55 fc             	mov    -0x4(%rbp),%edx
 4005e2a:	48 63 d2             	movslq %edx,%rdx
 4005e2d:	48 c1 e2 04          	shl    $0x4,%rdx
 4005e31:	48 01 d0             	add    %rdx,%rax
 4005e34:	0f b6 00             	movzbl (%rax),%eax
 4005e37:	83 e0 04             	and    $0x4,%eax
 4005e3a:	84 c0                	test   %al,%al
 4005e3c:	75 4f                	jne    4005e8d <KernelSpacePgsMemMgr::PrintPgsMemMgrStructure()+0x171>
 4005e3e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4005e42:	48 8b 80 20 10 00 00 	mov    0x1020(%rax),%rax
 4005e49:	8b 55 fc             	mov    -0x4(%rbp),%edx
 4005e4c:	48 63 d2             	movslq %edx,%rdx
 4005e4f:	48 c1 e2 04          	shl    $0x4,%rdx
 4005e53:	48 01 d0             	add    %rdx,%rax
 4005e56:	48 8b 40 08          	mov    0x8(%rax),%rax
 4005e5a:	48 85 c0             	test   %rax,%rax
 4005e5d:	74 2e                	je     4005e8d <KernelSpacePgsMemMgr::PrintPgsMemMgrStructure()+0x171>
                {
                    PrintLevel4Table(rootlv4PgCBtb[i].base.lowerlvPgCBtb, i);
 4005e5f:	8b 55 fc             	mov    -0x4(%rbp),%edx
 4005e62:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4005e66:	48 8b 80 20 10 00 00 	mov    0x1020(%rax),%rax
 4005e6d:	8b 4d fc             	mov    -0x4(%rbp),%ecx
 4005e70:	48 63 c9             	movslq %ecx,%rcx
 4005e73:	48 c1 e1 04          	shl    $0x4,%rcx
 4005e77:	48 01 c8             	add    %rcx,%rax
 4005e7a:	48 8b 48 08          	mov    0x8(%rax),%rcx
 4005e7e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4005e82:	48 89 ce             	mov    %rcx,%rsi
 4005e85:	48 89 c7             	mov    %rax,%rdi
 4005e88:	e8 b7 00 00 00       	call   4005f44 <KernelSpacePgsMemMgr::PrintLevel4Table(lowerlv_PgCBtb*, int)>
                }
                kputsSecure("\n");
 4005e8d:	48 8d 05 ab a6 00 00 	lea    0xa6ab(%rip),%rax        # 401053f <NullPgControlBlockHeader+0x4f>
 4005e94:	48 89 c7             	mov    %rax,%rdi
 4005e97:	e8 29 43 00 00       	call   400a1c5 <kputsSecure>
        for (int i = 0; i < 512; i++)
 4005e9c:	8b 45 fc             	mov    -0x4(%rbp),%eax
 4005e9f:	83 c0 01             	add    $0x1,%eax
 4005ea2:	89 45 fc             	mov    %eax,-0x4(%rbp)
 4005ea5:	8b 45 fc             	mov    -0x4(%rbp),%eax
 4005ea8:	3d ff 01 00 00       	cmp    $0x1ff,%eax
 4005ead:	0f 8e e2 fe ff ff    	jle    4005d95 <KernelSpacePgsMemMgr::PrintPgsMemMgrStructure()+0x79>
        {
            PrintLevel4Table(rootlv4PgCBtb->base.lowerlvPgCBtb, 0);
        }
        kputsSecure("\n");
    }
}
 4005eb3:	e9 89 00 00 00       	jmp    4005f41 <KernelSpacePgsMemMgr::PrintPgsMemMgrStructure()+0x225>
        kputsSecure("PML4[0]: ");
 4005eb8:	48 8d 05 82 a6 00 00 	lea    0xa682(%rip),%rax        # 4010541 <NullPgControlBlockHeader+0x51>
 4005ebf:	48 89 c7             	mov    %rax,%rdi
 4005ec2:	e8 fe 42 00 00       	call   400a1c5 <kputsSecure>
        PrintPageTableEntry(rootlv4PgCBtb, 4);
 4005ec7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4005ecb:	48 8b 88 20 10 00 00 	mov    0x1020(%rax),%rcx
 4005ed2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4005ed6:	ba 04 00 00 00       	mov    $0x4,%edx
 4005edb:	48 89 ce             	mov    %rcx,%rsi
 4005ede:	48 89 c7             	mov    %rax,%rdi
 4005ee1:	e8 48 06 00 00       	call   400652e <KernelSpacePgsMemMgr::PrintPageTableEntry(PgControlBlockHeader*, int)>
        if (!rootlv4PgCBtb->flags.is_atom && rootlv4PgCBtb->base.lowerlvPgCBtb)
 4005ee6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4005eea:	48 8b 80 20 10 00 00 	mov    0x1020(%rax),%rax
 4005ef1:	0f b6 00             	movzbl (%rax),%eax
 4005ef4:	83 e0 04             	and    $0x4,%eax
 4005ef7:	84 c0                	test   %al,%al
 4005ef9:	75 37                	jne    4005f32 <KernelSpacePgsMemMgr::PrintPgsMemMgrStructure()+0x216>
 4005efb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4005eff:	48 8b 80 20 10 00 00 	mov    0x1020(%rax),%rax
 4005f06:	48 8b 40 08          	mov    0x8(%rax),%rax
 4005f0a:	48 85 c0             	test   %rax,%rax
 4005f0d:	74 23                	je     4005f32 <KernelSpacePgsMemMgr::PrintPgsMemMgrStructure()+0x216>
            PrintLevel4Table(rootlv4PgCBtb->base.lowerlvPgCBtb, 0);
 4005f0f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4005f13:	48 8b 80 20 10 00 00 	mov    0x1020(%rax),%rax
 4005f1a:	48 8b 48 08          	mov    0x8(%rax),%rcx
 4005f1e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4005f22:	ba 00 00 00 00       	mov    $0x0,%edx
 4005f27:	48 89 ce             	mov    %rcx,%rsi
 4005f2a:	48 89 c7             	mov    %rax,%rdi
 4005f2d:	e8 12 00 00 00       	call   4005f44 <KernelSpacePgsMemMgr::PrintLevel4Table(lowerlv_PgCBtb*, int)>
        kputsSecure("\n");
 4005f32:	48 8d 05 06 a6 00 00 	lea    0xa606(%rip),%rax        # 401053f <NullPgControlBlockHeader+0x4f>
 4005f39:	48 89 c7             	mov    %rax,%rdi
 4005f3c:	e8 84 42 00 00       	call   400a1c5 <kputsSecure>
}
 4005f41:	90                   	nop
 4005f42:	c9                   	leave
 4005f43:	c3                   	ret

0000000004005f44 <KernelSpacePgsMemMgr::PrintLevel4Table(lowerlv_PgCBtb*, int)>:

// 辅助函数：打印四级表
void KernelSpacePgsMemMgr::PrintLevel4Table(lowerlv_PgCBtb* table, int parentIndex)
{
 4005f44:	55                   	push   %rbp
 4005f45:	48 89 e5             	mov    %rsp,%rbp
 4005f48:	48 83 ec 30          	sub    $0x30,%rsp
 4005f4c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
 4005f50:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
 4005f54:	89 55 dc             	mov    %edx,-0x24(%rbp)
    for (int i = 0; i < 512; i++)
 4005f57:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
 4005f5e:	e9 24 01 00 00       	jmp    4006087 <KernelSpacePgsMemMgr::PrintLevel4Table(lowerlv_PgCBtb*, int)+0x143>
    {
        if ((table->entries[i]).flags.is_exist)
 4005f63:	8b 55 fc             	mov    -0x4(%rbp),%edx
 4005f66:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4005f6a:	48 63 d2             	movslq %edx,%rdx
 4005f6d:	48 c1 e2 04          	shl    $0x4,%rdx
 4005f71:	48 01 d0             	add    %rdx,%rax
 4005f74:	0f b6 40 08          	movzbl 0x8(%rax),%eax
 4005f78:	d0 e8                	shr    $1,%al
 4005f7a:	83 e0 01             	and    $0x1,%eax
 4005f7d:	84 c0                	test   %al,%al
 4005f7f:	0f 84 f9 00 00 00    	je     400607e <KernelSpacePgsMemMgr::PrintLevel4Table(lowerlv_PgCBtb*, int)+0x13a>
        {
            kputsSecure("  PML4[");
 4005f85:	48 8d 05 bf a5 00 00 	lea    0xa5bf(%rip),%rax        # 401054b <NullPgControlBlockHeader+0x5b>
 4005f8c:	48 89 c7             	mov    %rax,%rdi
 4005f8f:	e8 31 42 00 00       	call   400a1c5 <kputsSecure>
            kpnumSecure(&parentIndex, UNDEC, 3);
 4005f94:	48 8d 45 dc          	lea    -0x24(%rbp),%rax
 4005f98:	ba 03 00 00 00       	mov    $0x3,%edx
 4005f9d:	be 03 00 00 00       	mov    $0x3,%esi
 4005fa2:	48 89 c7             	mov    %rax,%rdi
 4005fa5:	e8 5c 43 00 00       	call   400a306 <kpnumSecure>
            kputsSecure("]->PDPT[");
 4005faa:	48 8d 05 a2 a5 00 00 	lea    0xa5a2(%rip),%rax        # 4010553 <NullPgControlBlockHeader+0x63>
 4005fb1:	48 89 c7             	mov    %rax,%rdi
 4005fb4:	e8 0c 42 00 00       	call   400a1c5 <kputsSecure>
            kpnumSecure(&i, UNDEC, 3);
 4005fb9:	48 8d 45 fc          	lea    -0x4(%rbp),%rax
 4005fbd:	ba 03 00 00 00       	mov    $0x3,%edx
 4005fc2:	be 03 00 00 00       	mov    $0x3,%esi
 4005fc7:	48 89 c7             	mov    %rax,%rdi
 4005fca:	e8 37 43 00 00       	call   400a306 <kpnumSecure>
            kputsSecure("]: ");
 4005fcf:	48 8d 05 65 a5 00 00 	lea    0xa565(%rip),%rax        # 401053b <NullPgControlBlockHeader+0x4b>
 4005fd6:	48 89 c7             	mov    %rax,%rdi
 4005fd9:	e8 e7 41 00 00       	call   400a1c5 <kputsSecure>
            PrintPageTableEntry(&table->entries[i], 3);
 4005fde:	8b 45 fc             	mov    -0x4(%rbp),%eax
 4005fe1:	48 98                	cltq
 4005fe3:	48 c1 e0 04          	shl    $0x4,%rax
 4005fe7:	48 89 c2             	mov    %rax,%rdx
 4005fea:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4005fee:	48 01 d0             	add    %rdx,%rax
 4005ff1:	48 8d 48 08          	lea    0x8(%rax),%rcx
 4005ff5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4005ff9:	ba 03 00 00 00       	mov    $0x3,%edx
 4005ffe:	48 89 ce             	mov    %rcx,%rsi
 4006001:	48 89 c7             	mov    %rax,%rdi
 4006004:	e8 25 05 00 00       	call   400652e <KernelSpacePgsMemMgr::PrintPageTableEntry(PgControlBlockHeader*, int)>
            
            // 打印下一级
             if (!table->entries[i].flags.is_atom && table->entries[i].base.lowerlvPgCBtb)
 4006009:	8b 55 fc             	mov    -0x4(%rbp),%edx
 400600c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4006010:	48 63 d2             	movslq %edx,%rdx
 4006013:	48 c1 e2 04          	shl    $0x4,%rdx
 4006017:	48 01 d0             	add    %rdx,%rax
 400601a:	0f b6 40 08          	movzbl 0x8(%rax),%eax
 400601e:	c0 e8 02             	shr    $0x2,%al
 4006021:	83 e0 01             	and    $0x1,%eax
 4006024:	84 c0                	test   %al,%al
 4006026:	75 47                	jne    400606f <KernelSpacePgsMemMgr::PrintLevel4Table(lowerlv_PgCBtb*, int)+0x12b>
 4006028:	8b 55 fc             	mov    -0x4(%rbp),%edx
 400602b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 400602f:	48 63 d2             	movslq %edx,%rdx
 4006032:	48 c1 e2 04          	shl    $0x4,%rdx
 4006036:	48 01 d0             	add    %rdx,%rax
 4006039:	48 83 c0 10          	add    $0x10,%rax
 400603d:	48 8b 00             	mov    (%rax),%rax
 4006040:	48 85 c0             	test   %rax,%rax
 4006043:	74 2a                	je     400606f <KernelSpacePgsMemMgr::PrintLevel4Table(lowerlv_PgCBtb*, int)+0x12b>
            {
                PrintLevel3Table(table->entries[i].base.lowerlvPgCBtb, parentIndex, i);
 4006045:	8b 4d fc             	mov    -0x4(%rbp),%ecx
 4006048:	8b 55 dc             	mov    -0x24(%rbp),%edx
 400604b:	8b 75 fc             	mov    -0x4(%rbp),%esi
 400604e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4006052:	48 63 f6             	movslq %esi,%rsi
 4006055:	48 c1 e6 04          	shl    $0x4,%rsi
 4006059:	48 01 f0             	add    %rsi,%rax
 400605c:	48 83 c0 10          	add    $0x10,%rax
 4006060:	48 8b 30             	mov    (%rax),%rsi
 4006063:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4006067:	48 89 c7             	mov    %rax,%rdi
 400606a:	e8 2b 00 00 00       	call   400609a <KernelSpacePgsMemMgr::PrintLevel3Table(lowerlv_PgCBtb*, int, int)>
            }
            kputsSecure("\n");
 400606f:	48 8d 05 c9 a4 00 00 	lea    0xa4c9(%rip),%rax        # 401053f <NullPgControlBlockHeader+0x4f>
 4006076:	48 89 c7             	mov    %rax,%rdi
 4006079:	e8 47 41 00 00       	call   400a1c5 <kputsSecure>
    for (int i = 0; i < 512; i++)
 400607e:	8b 45 fc             	mov    -0x4(%rbp),%eax
 4006081:	83 c0 01             	add    $0x1,%eax
 4006084:	89 45 fc             	mov    %eax,-0x4(%rbp)
 4006087:	8b 45 fc             	mov    -0x4(%rbp),%eax
 400608a:	3d ff 01 00 00       	cmp    $0x1ff,%eax
 400608f:	0f 8e ce fe ff ff    	jle    4005f63 <KernelSpacePgsMemMgr::PrintLevel4Table(lowerlv_PgCBtb*, int)+0x1f>
        }
    }
}
 4006095:	90                   	nop
 4006096:	90                   	nop
 4006097:	c9                   	leave
 4006098:	c3                   	ret
 4006099:	90                   	nop

000000000400609a <KernelSpacePgsMemMgr::PrintLevel3Table(lowerlv_PgCBtb*, int, int)>:

// 辅助函数：打印三级表
void KernelSpacePgsMemMgr::PrintLevel3Table(lowerlv_PgCBtb* table, int grandParentIndex, int parentIndex)
{
 400609a:	55                   	push   %rbp
 400609b:	48 89 e5             	mov    %rsp,%rbp
 400609e:	48 83 ec 30          	sub    $0x30,%rsp
 40060a2:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
 40060a6:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
 40060aa:	89 55 dc             	mov    %edx,-0x24(%rbp)
 40060ad:	89 4d d8             	mov    %ecx,-0x28(%rbp)
    for (int i = 0; i < 512; i++)
 40060b0:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
 40060b7:	e9 2a 01 00 00       	jmp    40061e6 <KernelSpacePgsMemMgr::PrintLevel3Table(lowerlv_PgCBtb*, int, int)+0x14c>
    {
        if (table->entries[i].flags.is_exist)
 40060bc:	8b 55 fc             	mov    -0x4(%rbp),%edx
 40060bf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 40060c3:	48 63 d2             	movslq %edx,%rdx
 40060c6:	48 c1 e2 04          	shl    $0x4,%rdx
 40060ca:	48 01 d0             	add    %rdx,%rax
 40060cd:	0f b6 40 08          	movzbl 0x8(%rax),%eax
 40060d1:	d0 e8                	shr    $1,%al
 40060d3:	83 e0 01             	and    $0x1,%eax
 40060d6:	84 c0                	test   %al,%al
 40060d8:	0f 84 ff 00 00 00    	je     40061dd <KernelSpacePgsMemMgr::PrintLevel3Table(lowerlv_PgCBtb*, int, int)+0x143>
        {
            kputsSecure("    PDPT[");
 40060de:	48 8d 05 77 a4 00 00 	lea    0xa477(%rip),%rax        # 401055c <NullPgControlBlockHeader+0x6c>
 40060e5:	48 89 c7             	mov    %rax,%rdi
 40060e8:	e8 d8 40 00 00       	call   400a1c5 <kputsSecure>
            kpnumSecure(&parentIndex, UNDEC, 3);
 40060ed:	48 8d 45 d8          	lea    -0x28(%rbp),%rax
 40060f1:	ba 03 00 00 00       	mov    $0x3,%edx
 40060f6:	be 03 00 00 00       	mov    $0x3,%esi
 40060fb:	48 89 c7             	mov    %rax,%rdi
 40060fe:	e8 03 42 00 00       	call   400a306 <kpnumSecure>
            kputsSecure("]->PD[");
 4006103:	48 8d 05 5c a4 00 00 	lea    0xa45c(%rip),%rax        # 4010566 <NullPgControlBlockHeader+0x76>
 400610a:	48 89 c7             	mov    %rax,%rdi
 400610d:	e8 b3 40 00 00       	call   400a1c5 <kputsSecure>
            kpnumSecure(&i, UNDEC, 3);
 4006112:	48 8d 45 fc          	lea    -0x4(%rbp),%rax
 4006116:	ba 03 00 00 00       	mov    $0x3,%edx
 400611b:	be 03 00 00 00       	mov    $0x3,%esi
 4006120:	48 89 c7             	mov    %rax,%rdi
 4006123:	e8 de 41 00 00       	call   400a306 <kpnumSecure>
            kputsSecure("]: ");
 4006128:	48 8d 05 0c a4 00 00 	lea    0xa40c(%rip),%rax        # 401053b <NullPgControlBlockHeader+0x4b>
 400612f:	48 89 c7             	mov    %rax,%rdi
 4006132:	e8 8e 40 00 00       	call   400a1c5 <kputsSecure>
            PrintPageTableEntry(&table->entries[i], 2);
 4006137:	8b 45 fc             	mov    -0x4(%rbp),%eax
 400613a:	48 98                	cltq
 400613c:	48 c1 e0 04          	shl    $0x4,%rax
 4006140:	48 89 c2             	mov    %rax,%rdx
 4006143:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4006147:	48 01 d0             	add    %rdx,%rax
 400614a:	48 8d 48 08          	lea    0x8(%rax),%rcx
 400614e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4006152:	ba 02 00 00 00       	mov    $0x2,%edx
 4006157:	48 89 ce             	mov    %rcx,%rsi
 400615a:	48 89 c7             	mov    %rax,%rdi
 400615d:	e8 cc 03 00 00       	call   400652e <KernelSpacePgsMemMgr::PrintPageTableEntry(PgControlBlockHeader*, int)>
            
 if (!table->entries[i].flags.is_atom && table->entries[i].base.lowerlvPgCBtb)
 4006162:	8b 55 fc             	mov    -0x4(%rbp),%edx
 4006165:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4006169:	48 63 d2             	movslq %edx,%rdx
 400616c:	48 c1 e2 04          	shl    $0x4,%rdx
 4006170:	48 01 d0             	add    %rdx,%rax
 4006173:	0f b6 40 08          	movzbl 0x8(%rax),%eax
 4006177:	c0 e8 02             	shr    $0x2,%al
 400617a:	83 e0 01             	and    $0x1,%eax
 400617d:	84 c0                	test   %al,%al
 400617f:	75 4d                	jne    40061ce <KernelSpacePgsMemMgr::PrintLevel3Table(lowerlv_PgCBtb*, int, int)+0x134>
 4006181:	8b 55 fc             	mov    -0x4(%rbp),%edx
 4006184:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4006188:	48 63 d2             	movslq %edx,%rdx
 400618b:	48 c1 e2 04          	shl    $0x4,%rdx
 400618f:	48 01 d0             	add    %rdx,%rax
 4006192:	48 83 c0 10          	add    $0x10,%rax
 4006196:	48 8b 00             	mov    (%rax),%rax
 4006199:	48 85 c0             	test   %rax,%rax
 400619c:	74 30                	je     40061ce <KernelSpacePgsMemMgr::PrintLevel3Table(lowerlv_PgCBtb*, int, int)+0x134>
            {
                PrintLevel2Table(table->entries[i].base.lowerlvPgCBtb, grandParentIndex, parentIndex, i);
 400619e:	8b 7d fc             	mov    -0x4(%rbp),%edi
 40061a1:	8b 4d d8             	mov    -0x28(%rbp),%ecx
 40061a4:	8b 55 fc             	mov    -0x4(%rbp),%edx
 40061a7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 40061ab:	48 63 d2             	movslq %edx,%rdx
 40061ae:	48 c1 e2 04          	shl    $0x4,%rdx
 40061b2:	48 01 d0             	add    %rdx,%rax
 40061b5:	48 83 c0 10          	add    $0x10,%rax
 40061b9:	48 8b 30             	mov    (%rax),%rsi
 40061bc:	8b 55 dc             	mov    -0x24(%rbp),%edx
 40061bf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 40061c3:	41 89 f8             	mov    %edi,%r8d
 40061c6:	48 89 c7             	mov    %rax,%rdi
 40061c9:	e8 2a 00 00 00       	call   40061f8 <KernelSpacePgsMemMgr::PrintLevel2Table(lowerlv_PgCBtb*, int, int, int)>
            }
            kputsSecure("\n");
 40061ce:	48 8d 05 6a a3 00 00 	lea    0xa36a(%rip),%rax        # 401053f <NullPgControlBlockHeader+0x4f>
 40061d5:	48 89 c7             	mov    %rax,%rdi
 40061d8:	e8 e8 3f 00 00       	call   400a1c5 <kputsSecure>
    for (int i = 0; i < 512; i++)
 40061dd:	8b 45 fc             	mov    -0x4(%rbp),%eax
 40061e0:	83 c0 01             	add    $0x1,%eax
 40061e3:	89 45 fc             	mov    %eax,-0x4(%rbp)
 40061e6:	8b 45 fc             	mov    -0x4(%rbp),%eax
 40061e9:	3d ff 01 00 00       	cmp    $0x1ff,%eax
 40061ee:	0f 8e c8 fe ff ff    	jle    40060bc <KernelSpacePgsMemMgr::PrintLevel3Table(lowerlv_PgCBtb*, int, int)+0x22>
        }
    }
}
 40061f4:	90                   	nop
 40061f5:	90                   	nop
 40061f6:	c9                   	leave
 40061f7:	c3                   	ret

00000000040061f8 <KernelSpacePgsMemMgr::PrintLevel2Table(lowerlv_PgCBtb*, int, int, int)>:

// 辅助函数：打印二级表
void KernelSpacePgsMemMgr::PrintLevel2Table(lowerlv_PgCBtb* table, int greatGrandParentIndex, int grandParentIndex, int parentIndex)
{
 40061f8:	55                   	push   %rbp
 40061f9:	48 89 e5             	mov    %rsp,%rbp
 40061fc:	48 83 ec 30          	sub    $0x30,%rsp
 4006200:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
 4006204:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
 4006208:	89 55 dc             	mov    %edx,-0x24(%rbp)
 400620b:	89 4d d8             	mov    %ecx,-0x28(%rbp)
 400620e:	44 89 45 d4          	mov    %r8d,-0x2c(%rbp)
    for (int i = 0; i < 512; i++)
 4006212:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
 4006219:	e9 31 01 00 00       	jmp    400634f <KernelSpacePgsMemMgr::PrintLevel2Table(lowerlv_PgCBtb*, int, int, int)+0x157>
    {
        if (table->entries[i].flags.is_exist)
 400621e:	8b 55 fc             	mov    -0x4(%rbp),%edx
 4006221:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4006225:	48 63 d2             	movslq %edx,%rdx
 4006228:	48 c1 e2 04          	shl    $0x4,%rdx
 400622c:	48 01 d0             	add    %rdx,%rax
 400622f:	0f b6 40 08          	movzbl 0x8(%rax),%eax
 4006233:	d0 e8                	shr    $1,%al
 4006235:	83 e0 01             	and    $0x1,%eax
 4006238:	84 c0                	test   %al,%al
 400623a:	0f 84 06 01 00 00    	je     4006346 <KernelSpacePgsMemMgr::PrintLevel2Table(lowerlv_PgCBtb*, int, int, int)+0x14e>
        {
            kputsSecure("      PD[");
 4006240:	48 8d 05 26 a3 00 00 	lea    0xa326(%rip),%rax        # 401056d <NullPgControlBlockHeader+0x7d>
 4006247:	48 89 c7             	mov    %rax,%rdi
 400624a:	e8 76 3f 00 00       	call   400a1c5 <kputsSecure>
            kpnumSecure(&parentIndex, UNDEC, 3);
 400624f:	48 8d 45 d4          	lea    -0x2c(%rbp),%rax
 4006253:	ba 03 00 00 00       	mov    $0x3,%edx
 4006258:	be 03 00 00 00       	mov    $0x3,%esi
 400625d:	48 89 c7             	mov    %rax,%rdi
 4006260:	e8 a1 40 00 00       	call   400a306 <kpnumSecure>
            kputsSecure("]->PT[");
 4006265:	48 8d 05 0b a3 00 00 	lea    0xa30b(%rip),%rax        # 4010577 <NullPgControlBlockHeader+0x87>
 400626c:	48 89 c7             	mov    %rax,%rdi
 400626f:	e8 51 3f 00 00       	call   400a1c5 <kputsSecure>
            kpnumSecure(&i, UNDEC, 3);
 4006274:	48 8d 45 fc          	lea    -0x4(%rbp),%rax
 4006278:	ba 03 00 00 00       	mov    $0x3,%edx
 400627d:	be 03 00 00 00       	mov    $0x3,%esi
 4006282:	48 89 c7             	mov    %rax,%rdi
 4006285:	e8 7c 40 00 00       	call   400a306 <kpnumSecure>
            kputsSecure("]: ");
 400628a:	48 8d 05 aa a2 00 00 	lea    0xa2aa(%rip),%rax        # 401053b <NullPgControlBlockHeader+0x4b>
 4006291:	48 89 c7             	mov    %rax,%rdi
 4006294:	e8 2c 3f 00 00       	call   400a1c5 <kputsSecure>
            PrintPageTableEntry(&table->entries[i], 1);
 4006299:	8b 45 fc             	mov    -0x4(%rbp),%eax
 400629c:	48 98                	cltq
 400629e:	48 c1 e0 04          	shl    $0x4,%rax
 40062a2:	48 89 c2             	mov    %rax,%rdx
 40062a5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 40062a9:	48 01 d0             	add    %rdx,%rax
 40062ac:	48 8d 48 08          	lea    0x8(%rax),%rcx
 40062b0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 40062b4:	ba 01 00 00 00       	mov    $0x1,%edx
 40062b9:	48 89 ce             	mov    %rcx,%rsi
 40062bc:	48 89 c7             	mov    %rax,%rdi
 40062bf:	e8 6a 02 00 00       	call   400652e <KernelSpacePgsMemMgr::PrintPageTableEntry(PgControlBlockHeader*, int)>
            
 if (!table->entries[i].flags.is_atom && table->entries[i].base.lowerlvPgCBtb)
 40062c4:	8b 55 fc             	mov    -0x4(%rbp),%edx
 40062c7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 40062cb:	48 63 d2             	movslq %edx,%rdx
 40062ce:	48 c1 e2 04          	shl    $0x4,%rdx
 40062d2:	48 01 d0             	add    %rdx,%rax
 40062d5:	0f b6 40 08          	movzbl 0x8(%rax),%eax
 40062d9:	c0 e8 02             	shr    $0x2,%al
 40062dc:	83 e0 01             	and    $0x1,%eax
 40062df:	84 c0                	test   %al,%al
 40062e1:	75 54                	jne    4006337 <KernelSpacePgsMemMgr::PrintLevel2Table(lowerlv_PgCBtb*, int, int, int)+0x13f>
 40062e3:	8b 55 fc             	mov    -0x4(%rbp),%edx
 40062e6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 40062ea:	48 63 d2             	movslq %edx,%rdx
 40062ed:	48 c1 e2 04          	shl    $0x4,%rdx
 40062f1:	48 01 d0             	add    %rdx,%rax
 40062f4:	48 83 c0 10          	add    $0x10,%rax
 40062f8:	48 8b 00             	mov    (%rax),%rax
 40062fb:	48 85 c0             	test   %rax,%rax
 40062fe:	74 37                	je     4006337 <KernelSpacePgsMemMgr::PrintLevel2Table(lowerlv_PgCBtb*, int, int, int)+0x13f>
            {
                PrintLevel1Table(table->entries[i].base.lowerlvPgCBtb, greatGrandParentIndex, grandParentIndex, parentIndex, i);
 4006300:	44 8b 45 fc          	mov    -0x4(%rbp),%r8d
 4006304:	8b 7d d4             	mov    -0x2c(%rbp),%edi
 4006307:	8b 55 fc             	mov    -0x4(%rbp),%edx
 400630a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 400630e:	48 63 d2             	movslq %edx,%rdx
 4006311:	48 c1 e2 04          	shl    $0x4,%rdx
 4006315:	48 01 d0             	add    %rdx,%rax
 4006318:	48 83 c0 10          	add    $0x10,%rax
 400631c:	48 8b 30             	mov    (%rax),%rsi
 400631f:	8b 4d d8             	mov    -0x28(%rbp),%ecx
 4006322:	8b 55 dc             	mov    -0x24(%rbp),%edx
 4006325:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4006329:	45 89 c1             	mov    %r8d,%r9d
 400632c:	41 89 f8             	mov    %edi,%r8d
 400632f:	48 89 c7             	mov    %rax,%rdi
 4006332:	e8 2b 00 00 00       	call   4006362 <KernelSpacePgsMemMgr::PrintLevel1Table(lowerlv_PgCBtb*, int, int, int, int)>
            }
            kputsSecure("\n");
 4006337:	48 8d 05 01 a2 00 00 	lea    0xa201(%rip),%rax        # 401053f <NullPgControlBlockHeader+0x4f>
 400633e:	48 89 c7             	mov    %rax,%rdi
 4006341:	e8 7f 3e 00 00       	call   400a1c5 <kputsSecure>
    for (int i = 0; i < 512; i++)
 4006346:	8b 45 fc             	mov    -0x4(%rbp),%eax
 4006349:	83 c0 01             	add    $0x1,%eax
 400634c:	89 45 fc             	mov    %eax,-0x4(%rbp)
 400634f:	8b 45 fc             	mov    -0x4(%rbp),%eax
 4006352:	3d ff 01 00 00       	cmp    $0x1ff,%eax
 4006357:	0f 8e c1 fe ff ff    	jle    400621e <KernelSpacePgsMemMgr::PrintLevel2Table(lowerlv_PgCBtb*, int, int, int)+0x26>
        }
    }
}
 400635d:	90                   	nop
 400635e:	90                   	nop
 400635f:	c9                   	leave
 4006360:	c3                   	ret
 4006361:	90                   	nop

0000000004006362 <KernelSpacePgsMemMgr::PrintLevel1Table(lowerlv_PgCBtb*, int, int, int, int)>:

// 辅助函数：打印一级表
void KernelSpacePgsMemMgr::PrintLevel1Table(lowerlv_PgCBtb* table, int greatGreatGrandParentIndex, int greatGrandParentIndex, int grandParentIndex, int parentIndex)
{
 4006362:	55                   	push   %rbp
 4006363:	48 89 e5             	mov    %rsp,%rbp
 4006366:	48 83 ec 30          	sub    $0x30,%rsp
 400636a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
 400636e:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
 4006372:	89 55 dc             	mov    %edx,-0x24(%rbp)
 4006375:	89 4d d8             	mov    %ecx,-0x28(%rbp)
 4006378:	44 89 45 d4          	mov    %r8d,-0x2c(%rbp)
 400637c:	44 89 4d d0          	mov    %r9d,-0x30(%rbp)
    for (int i = 0; i < 512; i++)
 4006380:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
 4006387:	e9 13 01 00 00       	jmp    400649f <KernelSpacePgsMemMgr::PrintLevel1Table(lowerlv_PgCBtb*, int, int, int, int)+0x13d>
    {
        if (table->entries[i].flags.is_exist)
 400638c:	8b 55 fc             	mov    -0x4(%rbp),%edx
 400638f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4006393:	48 63 d2             	movslq %edx,%rdx
 4006396:	48 c1 e2 04          	shl    $0x4,%rdx
 400639a:	48 01 d0             	add    %rdx,%rax
 400639d:	0f b6 40 08          	movzbl 0x8(%rax),%eax
 40063a1:	d0 e8                	shr    $1,%al
 40063a3:	83 e0 01             	and    $0x1,%eax
 40063a6:	84 c0                	test   %al,%al
 40063a8:	0f 84 e8 00 00 00    	je     4006496 <KernelSpacePgsMemMgr::PrintLevel1Table(lowerlv_PgCBtb*, int, int, int, int)+0x134>
        {
            kputsSecure("        PT[");
 40063ae:	48 8d 05 c9 a1 00 00 	lea    0xa1c9(%rip),%rax        # 401057e <NullPgControlBlockHeader+0x8e>
 40063b5:	48 89 c7             	mov    %rax,%rdi
 40063b8:	e8 08 3e 00 00       	call   400a1c5 <kputsSecure>
            kpnumSecure(&parentIndex, UNDEC, 3);
 40063bd:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
 40063c1:	ba 03 00 00 00       	mov    $0x3,%edx
 40063c6:	be 03 00 00 00       	mov    $0x3,%esi
 40063cb:	48 89 c7             	mov    %rax,%rdi
 40063ce:	e8 33 3f 00 00       	call   400a306 <kpnumSecure>
            kputsSecure("]->Page[");
 40063d3:	48 8d 05 b0 a1 00 00 	lea    0xa1b0(%rip),%rax        # 401058a <NullPgControlBlockHeader+0x9a>
 40063da:	48 89 c7             	mov    %rax,%rdi
 40063dd:	e8 e3 3d 00 00       	call   400a1c5 <kputsSecure>
            kpnumSecure(&i, UNDEC, 3);
 40063e2:	48 8d 45 fc          	lea    -0x4(%rbp),%rax
 40063e6:	ba 03 00 00 00       	mov    $0x3,%edx
 40063eb:	be 03 00 00 00       	mov    $0x3,%esi
 40063f0:	48 89 c7             	mov    %rax,%rdi
 40063f3:	e8 0e 3f 00 00       	call   400a306 <kpnumSecure>
            kputsSecure("]: ");
 40063f8:	48 8d 05 3c a1 00 00 	lea    0xa13c(%rip),%rax        # 401053b <NullPgControlBlockHeader+0x4b>
 40063ff:	48 89 c7             	mov    %rax,%rdi
 4006402:	e8 be 3d 00 00       	call   400a1c5 <kputsSecure>
            PrintPageTableEntry(&table->entries[i], 0);
 4006407:	8b 45 fc             	mov    -0x4(%rbp),%eax
 400640a:	48 98                	cltq
 400640c:	48 c1 e0 04          	shl    $0x4,%rax
 4006410:	48 89 c2             	mov    %rax,%rdx
 4006413:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4006417:	48 01 d0             	add    %rdx,%rax
 400641a:	48 8d 48 08          	lea    0x8(%rax),%rcx
 400641e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4006422:	ba 00 00 00 00       	mov    $0x0,%edx
 4006427:	48 89 ce             	mov    %rcx,%rsi
 400642a:	48 89 c7             	mov    %rax,%rdi
 400642d:	e8 fc 00 00 00       	call   400652e <KernelSpacePgsMemMgr::PrintPageTableEntry(PgControlBlockHeader*, int)>
            
            // 计算并打印物理地址
            uint64_t physicalAddr = CalculatePhysicalAddress(
 4006432:	44 8b 45 fc          	mov    -0x4(%rbp),%r8d
 4006436:	8b 7d d0             	mov    -0x30(%rbp),%edi
 4006439:	8b 4d d4             	mov    -0x2c(%rbp),%ecx
 400643c:	8b 55 d8             	mov    -0x28(%rbp),%edx
 400643f:	8b 75 dc             	mov    -0x24(%rbp),%esi
 4006442:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4006446:	48 83 ec 08          	sub    $0x8,%rsp
 400644a:	6a 00                	push   $0x0
 400644c:	45 89 c1             	mov    %r8d,%r9d
 400644f:	41 89 f8             	mov    %edi,%r8d
 4006452:	48 89 c7             	mov    %rax,%rdi
 4006455:	e8 58 00 00 00       	call   40064b2 <KernelSpacePgsMemMgr::CalculatePhysicalAddress(int, int, int, int, int, int)>
 400645a:	48 83 c4 10          	add    $0x10,%rsp
                greatGreatGrandParentIndex, greatGrandParentIndex, 
                grandParentIndex, parentIndex, i, 0);
 400645e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
            
            kputsSecure(" PhysAddr: ");
 4006462:	48 8d 05 2a a1 00 00 	lea    0xa12a(%rip),%rax        # 4010593 <NullPgControlBlockHeader+0xa3>
 4006469:	48 89 c7             	mov    %rax,%rdi
 400646c:	e8 54 3d 00 00       	call   400a1c5 <kputsSecure>
            kpnumSecure(&physicalAddr, UNHEX, 8);
 4006471:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
 4006475:	ba 08 00 00 00       	mov    $0x8,%edx
 400647a:	be 05 00 00 00       	mov    $0x5,%esi
 400647f:	48 89 c7             	mov    %rax,%rdi
 4006482:	e8 7f 3e 00 00       	call   400a306 <kpnumSecure>
            kputsSecure("\n");
 4006487:	48 8d 05 b1 a0 00 00 	lea    0xa0b1(%rip),%rax        # 401053f <NullPgControlBlockHeader+0x4f>
 400648e:	48 89 c7             	mov    %rax,%rdi
 4006491:	e8 2f 3d 00 00       	call   400a1c5 <kputsSecure>
    for (int i = 0; i < 512; i++)
 4006496:	8b 45 fc             	mov    -0x4(%rbp),%eax
 4006499:	83 c0 01             	add    $0x1,%eax
 400649c:	89 45 fc             	mov    %eax,-0x4(%rbp)
 400649f:	8b 45 fc             	mov    -0x4(%rbp),%eax
 40064a2:	3d ff 01 00 00       	cmp    $0x1ff,%eax
 40064a7:	0f 8e df fe ff ff    	jle    400638c <KernelSpacePgsMemMgr::PrintLevel1Table(lowerlv_PgCBtb*, int, int, int, int)+0x2a>
        }
    }
}
 40064ad:	90                   	nop
 40064ae:	90                   	nop
 40064af:	c9                   	leave
 40064b0:	c3                   	ret
 40064b1:	90                   	nop

00000000040064b2 <KernelSpacePgsMemMgr::CalculatePhysicalAddress(int, int, int, int, int, int)>:

// 辅助函数：计算物理地址
uint64_t KernelSpacePgsMemMgr::CalculatePhysicalAddress(int index5, int index4, int index3, int index2, int index1, int index0)
{
 40064b2:	55                   	push   %rbp
 40064b3:	48 89 e5             	mov    %rsp,%rbp
 40064b6:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
 40064ba:	89 75 e4             	mov    %esi,-0x1c(%rbp)
 40064bd:	89 55 e0             	mov    %edx,-0x20(%rbp)
 40064c0:	89 4d dc             	mov    %ecx,-0x24(%rbp)
 40064c3:	44 89 45 d8          	mov    %r8d,-0x28(%rbp)
 40064c7:	44 89 4d d4          	mov    %r9d,-0x2c(%rbp)
    uint64_t addr = 0;
 40064cb:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
 40064d2:	00 
    
    if (cpu_pglv == 5)
 40064d3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 40064d7:	0f b6 00             	movzbl (%rax),%eax
 40064da:	3c 05                	cmp    $0x5,%al
 40064dc:	75 0d                	jne    40064eb <KernelSpacePgsMemMgr::CalculatePhysicalAddress(int, int, int, int, int, int)+0x39>
    {
        addr |= (static_cast<uint64_t>(index5) << 48);
 40064de:	8b 45 e4             	mov    -0x1c(%rbp),%eax
 40064e1:	48 98                	cltq
 40064e3:	48 c1 e0 30          	shl    $0x30,%rax
 40064e7:	48 09 45 f8          	or     %rax,-0x8(%rbp)
    }
    
    addr |= (static_cast<uint64_t>(index4) << 39);
 40064eb:	8b 45 e0             	mov    -0x20(%rbp),%eax
 40064ee:	48 98                	cltq
 40064f0:	48 c1 e0 27          	shl    $0x27,%rax
 40064f4:	48 09 45 f8          	or     %rax,-0x8(%rbp)
    addr |= (static_cast<uint64_t>(index3) << 30);
 40064f8:	8b 45 dc             	mov    -0x24(%rbp),%eax
 40064fb:	48 98                	cltq
 40064fd:	48 c1 e0 1e          	shl    $0x1e,%rax
 4006501:	48 09 45 f8          	or     %rax,-0x8(%rbp)
    addr |= (static_cast<uint64_t>(index2) << 21);
 4006505:	8b 45 d8             	mov    -0x28(%rbp),%eax
 4006508:	48 98                	cltq
 400650a:	48 c1 e0 15          	shl    $0x15,%rax
 400650e:	48 09 45 f8          	or     %rax,-0x8(%rbp)
    addr |= (static_cast<uint64_t>(index1) << 12);
 4006512:	8b 45 d4             	mov    -0x2c(%rbp),%eax
 4006515:	48 98                	cltq
 4006517:	48 c1 e0 0c          	shl    $0xc,%rax
 400651b:	48 09 45 f8          	or     %rax,-0x8(%rbp)
    addr |= (static_cast<uint64_t>(index0));
 400651f:	8b 45 10             	mov    0x10(%rbp),%eax
 4006522:	48 98                	cltq
 4006524:	48 09 45 f8          	or     %rax,-0x8(%rbp)
    
    return addr;
 4006528:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
 400652c:	5d                   	pop    %rbp
 400652d:	c3                   	ret

000000000400652e <KernelSpacePgsMemMgr::PrintPageTableEntry(PgControlBlockHeader*, int)>:

// 辅助函数：打印页表项信息
void KernelSpacePgsMemMgr::PrintPageTableEntry(PgControlBlockHeader* entry, int level)
{
 400652e:	55                   	push   %rbp
 400652f:	48 89 e5             	mov    %rsp,%rbp
 4006532:	48 83 ec 20          	sub    $0x20,%rsp
 4006536:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
 400653a:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
 400653e:	89 55 ec             	mov    %edx,-0x14(%rbp)
    // 打印级别
    kputsSecure((char*)"L");
 4006541:	48 8d 05 57 a0 00 00 	lea    0xa057(%rip),%rax        # 401059f <NullPgControlBlockHeader+0xaf>
 4006548:	48 89 c7             	mov    %rax,%rdi
 400654b:	e8 75 3c 00 00       	call   400a1c5 <kputsSecure>
    kpnumSecure(&level, UNDEC, 1);
 4006550:	48 8d 45 ec          	lea    -0x14(%rbp),%rax
 4006554:	ba 01 00 00 00       	mov    $0x1,%edx
 4006559:	be 03 00 00 00       	mov    $0x3,%esi
 400655e:	48 89 c7             	mov    %rax,%rdi
 4006561:	e8 a0 3d 00 00       	call   400a306 <kpnumSecure>
    kputsSecure((char*)": ");
 4006566:	48 8d 05 34 a0 00 00 	lea    0xa034(%rip),%rax        # 40105a1 <NullPgControlBlockHeader+0xb1>
 400656d:	48 89 c7             	mov    %rax,%rdi
 4006570:	e8 50 3c 00 00       	call   400a1c5 <kputsSecure>
    
    // 打印基本标志
    kputsSecure(entry->flags.physical_or_virtual_pg ? (char*)"Virtual " : (char*)"Physical ");
 4006575:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 4006579:	0f b6 00             	movzbl (%rax),%eax
 400657c:	83 e0 01             	and    $0x1,%eax
 400657f:	84 c0                	test   %al,%al
 4006581:	74 09                	je     400658c <KernelSpacePgsMemMgr::PrintPageTableEntry(PgControlBlockHeader*, int)+0x5e>
 4006583:	48 8d 05 1a a0 00 00 	lea    0xa01a(%rip),%rax        # 40105a4 <NullPgControlBlockHeader+0xb4>
 400658a:	eb 07                	jmp    4006593 <KernelSpacePgsMemMgr::PrintPageTableEntry(PgControlBlockHeader*, int)+0x65>
 400658c:	48 8d 05 1a a0 00 00 	lea    0xa01a(%rip),%rax        # 40105ad <NullPgControlBlockHeader+0xbd>
 4006593:	48 89 c7             	mov    %rax,%rdi
 4006596:	e8 2a 3c 00 00       	call   400a1c5 <kputsSecure>
    kputsSecure(entry->flags.is_exist ? (char*)"Exist " : (char*)"NotExist ");
 400659b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 400659f:	0f b6 00             	movzbl (%rax),%eax
 40065a2:	83 e0 02             	and    $0x2,%eax
 40065a5:	84 c0                	test   %al,%al
 40065a7:	74 09                	je     40065b2 <KernelSpacePgsMemMgr::PrintPageTableEntry(PgControlBlockHeader*, int)+0x84>
 40065a9:	48 8d 05 07 a0 00 00 	lea    0xa007(%rip),%rax        # 40105b7 <NullPgControlBlockHeader+0xc7>
 40065b0:	eb 07                	jmp    40065b9 <KernelSpacePgsMemMgr::PrintPageTableEntry(PgControlBlockHeader*, int)+0x8b>
 40065b2:	48 8d 05 05 a0 00 00 	lea    0xa005(%rip),%rax        # 40105be <NullPgControlBlockHeader+0xce>
 40065b9:	48 89 c7             	mov    %rax,%rdi
 40065bc:	e8 04 3c 00 00       	call   400a1c5 <kputsSecure>
    kputsSecure(entry->flags.is_atom ? (char*)"Atom " : (char*)"NonAtom ");
 40065c1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 40065c5:	0f b6 00             	movzbl (%rax),%eax
 40065c8:	83 e0 04             	and    $0x4,%eax
 40065cb:	84 c0                	test   %al,%al
 40065cd:	74 09                	je     40065d8 <KernelSpacePgsMemMgr::PrintPageTableEntry(PgControlBlockHeader*, int)+0xaa>
 40065cf:	48 8d 05 f2 9f 00 00 	lea    0x9ff2(%rip),%rax        # 40105c8 <NullPgControlBlockHeader+0xd8>
 40065d6:	eb 07                	jmp    40065df <KernelSpacePgsMemMgr::PrintPageTableEntry(PgControlBlockHeader*, int)+0xb1>
 40065d8:	48 8d 05 ef 9f 00 00 	lea    0x9fef(%rip),%rax        # 40105ce <NullPgControlBlockHeader+0xde>
 40065df:	48 89 c7             	mov    %rax,%rdi
 40065e2:	e8 de 3b 00 00       	call   400a1c5 <kputsSecure>

    
    
    kputsSecure(entry->flags.is_reserved ? (char*)"Reserved " : (char*)"NonReserved ");
 40065e7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 40065eb:	0f b6 00             	movzbl (%rax),%eax
 40065ee:	83 e0 08             	and    $0x8,%eax
 40065f1:	84 c0                	test   %al,%al
 40065f3:	74 09                	je     40065fe <KernelSpacePgsMemMgr::PrintPageTableEntry(PgControlBlockHeader*, int)+0xd0>
 40065f5:	48 8d 05 db 9f 00 00 	lea    0x9fdb(%rip),%rax        # 40105d7 <NullPgControlBlockHeader+0xe7>
 40065fc:	eb 07                	jmp    4006605 <KernelSpacePgsMemMgr::PrintPageTableEntry(PgControlBlockHeader*, int)+0xd7>
 40065fe:	48 8d 05 dc 9f 00 00 	lea    0x9fdc(%rip),%rax        # 40105e1 <NullPgControlBlockHeader+0xf1>
 4006605:	48 89 c7             	mov    %rax,%rdi
 4006608:	e8 b8 3b 00 00       	call   400a1c5 <kputsSecure>
    
    // 打印权限标志
    kputsSecure(entry->flags.is_readable ? (char*)"R" : (char*)"-");
 400660d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 4006611:	0f b6 00             	movzbl (%rax),%eax
 4006614:	83 e0 40             	and    $0x40,%eax
 4006617:	84 c0                	test   %al,%al
 4006619:	74 09                	je     4006624 <KernelSpacePgsMemMgr::PrintPageTableEntry(PgControlBlockHeader*, int)+0xf6>
 400661b:	48 8d 05 cc 9f 00 00 	lea    0x9fcc(%rip),%rax        # 40105ee <NullPgControlBlockHeader+0xfe>
 4006622:	eb 07                	jmp    400662b <KernelSpacePgsMemMgr::PrintPageTableEntry(PgControlBlockHeader*, int)+0xfd>
 4006624:	48 8d 05 c5 9f 00 00 	lea    0x9fc5(%rip),%rax        # 40105f0 <NullPgControlBlockHeader+0x100>
 400662b:	48 89 c7             	mov    %rax,%rdi
 400662e:	e8 92 3b 00 00       	call   400a1c5 <kputsSecure>
    kputsSecure(entry->flags.is_writable ? (char*)"W" : (char*)"-");
 4006633:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 4006637:	0f b6 00             	movzbl (%rax),%eax
 400663a:	83 e0 80             	and    $0xffffff80,%eax
 400663d:	84 c0                	test   %al,%al
 400663f:	74 09                	je     400664a <KernelSpacePgsMemMgr::PrintPageTableEntry(PgControlBlockHeader*, int)+0x11c>
 4006641:	48 8d 05 aa 9f 00 00 	lea    0x9faa(%rip),%rax        # 40105f2 <NullPgControlBlockHeader+0x102>
 4006648:	eb 07                	jmp    4006651 <KernelSpacePgsMemMgr::PrintPageTableEntry(PgControlBlockHeader*, int)+0x123>
 400664a:	48 8d 05 9f 9f 00 00 	lea    0x9f9f(%rip),%rax        # 40105f0 <NullPgControlBlockHeader+0x100>
 4006651:	48 89 c7             	mov    %rax,%rdi
 4006654:	e8 6c 3b 00 00       	call   400a1c5 <kputsSecure>
    kputsSecure(entry->flags.is_executable ? (char*)"X" : (char*)"-");
 4006659:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 400665d:	0f b6 40 01          	movzbl 0x1(%rax),%eax
 4006661:	83 e0 01             	and    $0x1,%eax
 4006664:	84 c0                	test   %al,%al
 4006666:	74 09                	je     4006671 <KernelSpacePgsMemMgr::PrintPageTableEntry(PgControlBlockHeader*, int)+0x143>
 4006668:	48 8d 05 85 9f 00 00 	lea    0x9f85(%rip),%rax        # 40105f4 <NullPgControlBlockHeader+0x104>
 400666f:	eb 07                	jmp    4006678 <KernelSpacePgsMemMgr::PrintPageTableEntry(PgControlBlockHeader*, int)+0x14a>
 4006671:	48 8d 05 78 9f 00 00 	lea    0x9f78(%rip),%rax        # 40105f0 <NullPgControlBlockHeader+0x100>
 4006678:	48 89 c7             	mov    %rax,%rdi
 400667b:	e8 45 3b 00 00       	call   400a1c5 <kputsSecure>
    kputsSecure((char*)" ");
 4006680:	48 8d 05 6f 9f 00 00 	lea    0x9f6f(%rip),%rax        # 40105f6 <NullPgControlBlockHeader+0x106>
 4006687:	48 89 c7             	mov    %rax,%rdi
 400668a:	e8 36 3b 00 00       	call   400a1c5 <kputsSecure>
    
    // 打印其他标志
    kputsSecure(entry->flags.is_kernel ? (char*)"Kernel " : (char*)"User ");
 400668f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 4006693:	0f b6 00             	movzbl (%rax),%eax
 4006696:	83 e0 20             	and    $0x20,%eax
 4006699:	84 c0                	test   %al,%al
 400669b:	74 09                	je     40066a6 <KernelSpacePgsMemMgr::PrintPageTableEntry(PgControlBlockHeader*, int)+0x178>
 400669d:	48 8d 05 54 9f 00 00 	lea    0x9f54(%rip),%rax        # 40105f8 <NullPgControlBlockHeader+0x108>
 40066a4:	eb 07                	jmp    40066ad <KernelSpacePgsMemMgr::PrintPageTableEntry(PgControlBlockHeader*, int)+0x17f>
 40066a6:	48 8d 05 53 9f 00 00 	lea    0x9f53(%rip),%rax        # 4010600 <NullPgControlBlockHeader+0x110>
 40066ad:	48 89 c7             	mov    %rax,%rdi
 40066b0:	e8 10 3b 00 00       	call   400a1c5 <kputsSecure>
    kputsSecure(entry->flags.is_occupied ? (char*)"Occupied " : (char*)"Free ");
 40066b5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 40066b9:	0f b6 00             	movzbl (%rax),%eax
 40066bc:	83 e0 10             	and    $0x10,%eax
 40066bf:	84 c0                	test   %al,%al
 40066c1:	74 09                	je     40066cc <KernelSpacePgsMemMgr::PrintPageTableEntry(PgControlBlockHeader*, int)+0x19e>
 40066c3:	48 8d 05 3c 9f 00 00 	lea    0x9f3c(%rip),%rax        # 4010606 <NullPgControlBlockHeader+0x116>
 40066ca:	eb 07                	jmp    40066d3 <KernelSpacePgsMemMgr::PrintPageTableEntry(PgControlBlockHeader*, int)+0x1a5>
 40066cc:	48 8d 05 3d 9f 00 00 	lea    0x9f3d(%rip),%rax        # 4010610 <NullPgControlBlockHeader+0x120>
 40066d3:	48 89 c7             	mov    %rax,%rdi
 40066d6:	e8 ea 3a 00 00       	call   400a1c5 <kputsSecure>
}
 40066db:	90                   	nop
 40066dc:	c9                   	leave
 40066dd:	c3                   	ret

00000000040066de <print_pgflags(pgflags)>:

// 辅助函数：打印1bit位图


// 打印pgflags结构
void print_pgflags(pgflags flags) {
 40066de:	55                   	push   %rbp
 40066df:	48 89 e5             	mov    %rsp,%rbp
 40066e2:	48 83 ec 20          	sub    $0x20,%rsp
 40066e6:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    kputsSecure("Flags:\n");
 40066ea:	48 8d 05 25 9f 00 00 	lea    0x9f25(%rip),%rax        # 4010616 <NullPgControlBlockHeader+0x126>
 40066f1:	48 89 c7             	mov    %rax,%rdi
 40066f4:	e8 cc 3a 00 00       	call   400a1c5 <kputsSecure>
    
    // 打印标志位
    kputsSecure("  physical_or_virtual_pg: ");
 40066f9:	48 8d 05 1e 9f 00 00 	lea    0x9f1e(%rip),%rax        # 401061e <NullPgControlBlockHeader+0x12e>
 4006700:	48 89 c7             	mov    %rax,%rdi
 4006703:	e8 bd 3a 00 00       	call   400a1c5 <kputsSecure>

    kputsSecure((bool)flags.physical_or_virtual_pg ? (char*)" (Virtual)" : (char*)" (Physical)\n");
 4006708:	0f b6 45 e8          	movzbl -0x18(%rbp),%eax
 400670c:	83 e0 01             	and    $0x1,%eax
 400670f:	84 c0                	test   %al,%al
 4006711:	74 09                	je     400671c <print_pgflags(pgflags)+0x3e>
 4006713:	48 8d 05 1f 9f 00 00 	lea    0x9f1f(%rip),%rax        # 4010639 <NullPgControlBlockHeader+0x149>
 400671a:	eb 07                	jmp    4006723 <print_pgflags(pgflags)+0x45>
 400671c:	48 8d 05 21 9f 00 00 	lea    0x9f21(%rip),%rax        # 4010644 <NullPgControlBlockHeader+0x154>
 4006723:	48 89 c7             	mov    %rax,%rdi
 4006726:	e8 9a 3a 00 00       	call   400a1c5 <kputsSecure>
    
    kputsSecure("  is_exist: ");
 400672b:	48 8d 05 1f 9f 00 00 	lea    0x9f1f(%rip),%rax        # 4010651 <NullPgControlBlockHeader+0x161>
 4006732:	48 89 c7             	mov    %rax,%rdi
 4006735:	e8 8b 3a 00 00       	call   400a1c5 <kputsSecure>
    kputcharSecure(flags.is_exist ? '1' : '0');
 400673a:	0f b6 45 e8          	movzbl -0x18(%rbp),%eax
 400673e:	83 e0 02             	and    $0x2,%eax
 4006741:	84 c0                	test   %al,%al
 4006743:	74 07                	je     400674c <print_pgflags(pgflags)+0x6e>
 4006745:	b8 31 00 00 00       	mov    $0x31,%eax
 400674a:	eb 05                	jmp    4006751 <print_pgflags(pgflags)+0x73>
 400674c:	b8 30 00 00 00       	mov    $0x30,%eax
 4006751:	89 c7                	mov    %eax,%edi
 4006753:	e8 05 38 00 00       	call   4009f5d <kputcharSecure>
    kputsSecure("\n");
 4006758:	48 8d 05 e0 9d 00 00 	lea    0x9de0(%rip),%rax        # 401053f <NullPgControlBlockHeader+0x4f>
 400675f:	48 89 c7             	mov    %rax,%rdi
 4006762:	e8 5e 3a 00 00       	call   400a1c5 <kputsSecure>
    
    kputsSecure("  is_atom: ");
 4006767:	48 8d 05 f0 9e 00 00 	lea    0x9ef0(%rip),%rax        # 401065e <NullPgControlBlockHeader+0x16e>
 400676e:	48 89 c7             	mov    %rax,%rdi
 4006771:	e8 4f 3a 00 00       	call   400a1c5 <kputsSecure>
    kputcharSecure(flags.is_atom ? '1' : '0');
 4006776:	0f b6 45 e8          	movzbl -0x18(%rbp),%eax
 400677a:	83 e0 04             	and    $0x4,%eax
 400677d:	84 c0                	test   %al,%al
 400677f:	74 07                	je     4006788 <print_pgflags(pgflags)+0xaa>
 4006781:	b8 31 00 00 00       	mov    $0x31,%eax
 4006786:	eb 05                	jmp    400678d <print_pgflags(pgflags)+0xaf>
 4006788:	b8 30 00 00 00       	mov    $0x30,%eax
 400678d:	89 c7                	mov    %eax,%edi
 400678f:	e8 c9 37 00 00       	call   4009f5d <kputcharSecure>
    kputsSecure("\n");
 4006794:	48 8d 05 a4 9d 00 00 	lea    0x9da4(%rip),%rax        # 401053f <NullPgControlBlockHeader+0x4f>
 400679b:	48 89 c7             	mov    %rax,%rdi
 400679e:	e8 22 3a 00 00       	call   400a1c5 <kputsSecure>

    kputsSecure("  is_reserved: ");
 40067a3:	48 8d 05 c0 9e 00 00 	lea    0x9ec0(%rip),%rax        # 401066a <NullPgControlBlockHeader+0x17a>
 40067aa:	48 89 c7             	mov    %rax,%rdi
 40067ad:	e8 13 3a 00 00       	call   400a1c5 <kputsSecure>
    kputcharSecure(flags.is_reserved ? '1' : '0');
 40067b2:	0f b6 45 e8          	movzbl -0x18(%rbp),%eax
 40067b6:	83 e0 08             	and    $0x8,%eax
 40067b9:	84 c0                	test   %al,%al
 40067bb:	74 07                	je     40067c4 <print_pgflags(pgflags)+0xe6>
 40067bd:	b8 31 00 00 00       	mov    $0x31,%eax
 40067c2:	eb 05                	jmp    40067c9 <print_pgflags(pgflags)+0xeb>
 40067c4:	b8 30 00 00 00       	mov    $0x30,%eax
 40067c9:	89 c7                	mov    %eax,%edi
 40067cb:	e8 8d 37 00 00       	call   4009f5d <kputcharSecure>
    kputsSecure("\n");
 40067d0:	48 8d 05 68 9d 00 00 	lea    0x9d68(%rip),%rax        # 401053f <NullPgControlBlockHeader+0x4f>
 40067d7:	48 89 c7             	mov    %rax,%rdi
 40067da:	e8 e6 39 00 00       	call   400a1c5 <kputsSecure>
    
    kputsSecure("  is_occupied: ");
 40067df:	48 8d 05 94 9e 00 00 	lea    0x9e94(%rip),%rax        # 401067a <NullPgControlBlockHeader+0x18a>
 40067e6:	48 89 c7             	mov    %rax,%rdi
 40067e9:	e8 d7 39 00 00       	call   400a1c5 <kputsSecure>
    kputsSecure(flags.is_occupied ? (char*)" (Occupied)" : (char*)" (Free)");
 40067ee:	0f b6 45 e8          	movzbl -0x18(%rbp),%eax
 40067f2:	83 e0 10             	and    $0x10,%eax
 40067f5:	84 c0                	test   %al,%al
 40067f7:	74 09                	je     4006802 <print_pgflags(pgflags)+0x124>
 40067f9:	48 8d 05 8a 9e 00 00 	lea    0x9e8a(%rip),%rax        # 401068a <NullPgControlBlockHeader+0x19a>
 4006800:	eb 07                	jmp    4006809 <print_pgflags(pgflags)+0x12b>
 4006802:	48 8d 05 8d 9e 00 00 	lea    0x9e8d(%rip),%rax        # 4010696 <NullPgControlBlockHeader+0x1a6>
 4006809:	48 89 c7             	mov    %rax,%rdi
 400680c:	e8 b4 39 00 00       	call   400a1c5 <kputsSecure>
    kputsSecure("\n");
 4006811:	48 8d 05 27 9d 00 00 	lea    0x9d27(%rip),%rax        # 401053f <NullPgControlBlockHeader+0x4f>
 4006818:	48 89 c7             	mov    %rax,%rdi
 400681b:	e8 a5 39 00 00       	call   400a1c5 <kputsSecure>
    
    kputsSecure("  is_kernel: ");
 4006820:	48 8d 05 77 9e 00 00 	lea    0x9e77(%rip),%rax        # 401069e <NullPgControlBlockHeader+0x1ae>
 4006827:	48 89 c7             	mov    %rax,%rdi
 400682a:	e8 96 39 00 00       	call   400a1c5 <kputsSecure>
    kputcharSecure(flags.is_kernel ? '1' : '0');
 400682f:	0f b6 45 e8          	movzbl -0x18(%rbp),%eax
 4006833:	83 e0 20             	and    $0x20,%eax
 4006836:	84 c0                	test   %al,%al
 4006838:	74 07                	je     4006841 <print_pgflags(pgflags)+0x163>
 400683a:	b8 31 00 00 00       	mov    $0x31,%eax
 400683f:	eb 05                	jmp    4006846 <print_pgflags(pgflags)+0x168>
 4006841:	b8 30 00 00 00       	mov    $0x30,%eax
 4006846:	89 c7                	mov    %eax,%edi
 4006848:	e8 10 37 00 00       	call   4009f5d <kputcharSecure>
    kputsSecure("\n");
 400684d:	48 8d 05 eb 9c 00 00 	lea    0x9ceb(%rip),%rax        # 401053f <NullPgControlBlockHeader+0x4f>
 4006854:	48 89 c7             	mov    %rax,%rdi
 4006857:	e8 69 39 00 00       	call   400a1c5 <kputsSecure>
    
    kputsSecure("  is_readable: ");
 400685c:	48 8d 05 49 9e 00 00 	lea    0x9e49(%rip),%rax        # 40106ac <NullPgControlBlockHeader+0x1bc>
 4006863:	48 89 c7             	mov    %rax,%rdi
 4006866:	e8 5a 39 00 00       	call   400a1c5 <kputsSecure>
    kputcharSecure  (flags.is_readable ? '1' : '0');
 400686b:	0f b6 45 e8          	movzbl -0x18(%rbp),%eax
 400686f:	83 e0 40             	and    $0x40,%eax
 4006872:	84 c0                	test   %al,%al
 4006874:	74 07                	je     400687d <print_pgflags(pgflags)+0x19f>
 4006876:	b8 31 00 00 00       	mov    $0x31,%eax
 400687b:	eb 05                	jmp    4006882 <print_pgflags(pgflags)+0x1a4>
 400687d:	b8 30 00 00 00       	mov    $0x30,%eax
 4006882:	89 c7                	mov    %eax,%edi
 4006884:	e8 d4 36 00 00       	call   4009f5d <kputcharSecure>
    kputsSecure("\n");
 4006889:	48 8d 05 af 9c 00 00 	lea    0x9caf(%rip),%rax        # 401053f <NullPgControlBlockHeader+0x4f>
 4006890:	48 89 c7             	mov    %rax,%rdi
 4006893:	e8 2d 39 00 00       	call   400a1c5 <kputsSecure>
    
    kputsSecure("  is_writable: ");
 4006898:	48 8d 05 1d 9e 00 00 	lea    0x9e1d(%rip),%rax        # 40106bc <NullPgControlBlockHeader+0x1cc>
 400689f:	48 89 c7             	mov    %rax,%rdi
 40068a2:	e8 1e 39 00 00       	call   400a1c5 <kputsSecure>
    kputcharSecure(flags.is_writable ? '1' : '0');
 40068a7:	0f b6 45 e8          	movzbl -0x18(%rbp),%eax
 40068ab:	83 e0 80             	and    $0xffffff80,%eax
 40068ae:	84 c0                	test   %al,%al
 40068b0:	74 07                	je     40068b9 <print_pgflags(pgflags)+0x1db>
 40068b2:	b8 31 00 00 00       	mov    $0x31,%eax
 40068b7:	eb 05                	jmp    40068be <print_pgflags(pgflags)+0x1e0>
 40068b9:	b8 30 00 00 00       	mov    $0x30,%eax
 40068be:	89 c7                	mov    %eax,%edi
 40068c0:	e8 98 36 00 00       	call   4009f5d <kputcharSecure>
    kputsSecure("\n");
 40068c5:	48 8d 05 73 9c 00 00 	lea    0x9c73(%rip),%rax        # 401053f <NullPgControlBlockHeader+0x4f>
 40068cc:	48 89 c7             	mov    %rax,%rdi
 40068cf:	e8 f1 38 00 00       	call   400a1c5 <kputsSecure>
    
    kputsSecure("  is_executable: ");
 40068d4:	48 8d 05 f1 9d 00 00 	lea    0x9df1(%rip),%rax        # 40106cc <NullPgControlBlockHeader+0x1dc>
 40068db:	48 89 c7             	mov    %rax,%rdi
 40068de:	e8 e2 38 00 00       	call   400a1c5 <kputsSecure>
    kputcharSecure(flags.is_executable ? '1' : '0');
 40068e3:	0f b6 45 e9          	movzbl -0x17(%rbp),%eax
 40068e7:	83 e0 01             	and    $0x1,%eax
 40068ea:	84 c0                	test   %al,%al
 40068ec:	74 07                	je     40068f5 <print_pgflags(pgflags)+0x217>
 40068ee:	b8 31 00 00 00       	mov    $0x31,%eax
 40068f3:	eb 05                	jmp    40068fa <print_pgflags(pgflags)+0x21c>
 40068f5:	b8 30 00 00 00       	mov    $0x30,%eax
 40068fa:	89 c7                	mov    %eax,%edi
 40068fc:	e8 5c 36 00 00       	call   4009f5d <kputcharSecure>
    kputsSecure("\n");
 4006901:	48 8d 05 37 9c 00 00 	lea    0x9c37(%rip),%rax        # 401053f <NullPgControlBlockHeader+0x4f>
 4006908:	48 89 c7             	mov    %rax,%rdi
 400690b:	e8 b5 38 00 00       	call   400a1c5 <kputsSecure>
    
    kputsSecure("  is_remaped: ");
 4006910:	48 8d 05 c7 9d 00 00 	lea    0x9dc7(%rip),%rax        # 40106de <NullPgControlBlockHeader+0x1ee>
 4006917:	48 89 c7             	mov    %rax,%rdi
 400691a:	e8 a6 38 00 00       	call   400a1c5 <kputsSecure>
    kputcharSecure(flags.is_remaped ? '1' : '0');
 400691f:	0f b6 45 e9          	movzbl -0x17(%rbp),%eax
 4006923:	83 e0 02             	and    $0x2,%eax
 4006926:	84 c0                	test   %al,%al
 4006928:	74 07                	je     4006931 <print_pgflags(pgflags)+0x253>
 400692a:	b8 31 00 00 00       	mov    $0x31,%eax
 400692f:	eb 05                	jmp    4006936 <print_pgflags(pgflags)+0x258>
 4006931:	b8 30 00 00 00       	mov    $0x30,%eax
 4006936:	89 c7                	mov    %eax,%edi
 4006938:	e8 20 36 00 00       	call   4009f5d <kputcharSecure>
    kputsSecure("\n");
 400693d:	48 8d 05 fb 9b 00 00 	lea    0x9bfb(%rip),%rax        # 401053f <NullPgControlBlockHeader+0x4f>
 4006944:	48 89 c7             	mov    %rax,%rdi
 4006947:	e8 79 38 00 00       	call   400a1c5 <kputsSecure>
    
    kputsSecure("  pg_lv: ");
 400694c:	48 8d 05 9a 9d 00 00 	lea    0x9d9a(%rip),%rax        # 40106ed <NullPgControlBlockHeader+0x1fd>
 4006953:	48 89 c7             	mov    %rax,%rdi
 4006956:	e8 6a 38 00 00       	call   400a1c5 <kputsSecure>
    uint8_t pg_lv = flags.pg_lv;
 400695b:	0f b6 45 e9          	movzbl -0x17(%rbp),%eax
 400695f:	c0 e8 02             	shr    $0x2,%al
 4006962:	83 e0 07             	and    $0x7,%eax
 4006965:	88 45 ff             	mov    %al,-0x1(%rbp)
    kpnumSecure(&pg_lv, UNDEC, 1);
 4006968:	48 8d 45 ff          	lea    -0x1(%rbp),%rax
 400696c:	ba 01 00 00 00       	mov    $0x1,%edx
 4006971:	be 03 00 00 00       	mov    $0x3,%esi
 4006976:	48 89 c7             	mov    %rax,%rdi
 4006979:	e8 88 39 00 00       	call   400a306 <kpnumSecure>
    kputsSecure("\n");
 400697e:	48 8d 05 ba 9b 00 00 	lea    0x9bba(%rip),%rax        # 401053f <NullPgControlBlockHeader+0x4f>
 4006985:	48 89 c7             	mov    %rax,%rdi
 4006988:	e8 38 38 00 00       	call   400a1c5 <kputsSecure>
}
 400698d:	90                   	nop
 400698e:	c9                   	leave
 400698f:	c3                   	ret

0000000004006990 <print_PgControlBlockHeader(PgControlBlockHeader*)>:

// 打印1位宽位图

// 打印2位宽位图

void print_PgControlBlockHeader(struct PgControlBlockHeader* header) {
 4006990:	55                   	push   %rbp
 4006991:	48 89 e5             	mov    %rsp,%rbp
 4006994:	48 83 ec 10          	sub    $0x10,%rsp
 4006998:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    if (!header) {
 400699c:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
 40069a1:	75 14                	jne    40069b7 <print_PgControlBlockHeader(PgControlBlockHeader*)+0x27>
        kputsSecure("Invalid PgControlBlockHeader pointer\n");
 40069a3:	48 8d 05 4e 9d 00 00 	lea    0x9d4e(%rip),%rax        # 40106f8 <NullPgControlBlockHeader+0x208>
 40069aa:	48 89 c7             	mov    %rax,%rdi
 40069ad:	e8 13 38 00 00       	call   400a1c5 <kputsSecure>
        return;
 40069b2:	e9 e2 00 00 00       	jmp    4006a99 <print_PgControlBlockHeader(PgControlBlockHeader*)+0x109>
    }
    
    kputsSecure("==== PgControlBlockHeader ====\n");
 40069b7:	48 8d 05 62 9d 00 00 	lea    0x9d62(%rip),%rax        # 4010720 <NullPgControlBlockHeader+0x230>
 40069be:	48 89 c7             	mov    %rax,%rdi
 40069c1:	e8 ff 37 00 00       	call   400a1c5 <kputsSecure>
    
    // 打印标志
    print_pgflags(header->flags);
 40069c6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 40069ca:	48 8b 00             	mov    (%rax),%rax
 40069cd:	48 89 c7             	mov    %rax,%rdi
 40069d0:	e8 09 fd ff ff       	call   40066de <print_pgflags(pgflags)>
    
    // 打印base联合体
    kputsSecure("Base:\n");
 40069d5:	48 8d 05 64 9d 00 00 	lea    0x9d64(%rip),%rax        # 4010740 <NullPgControlBlockHeader+0x250>
 40069dc:	48 89 c7             	mov    %rax,%rdi
 40069df:	e8 e1 37 00 00       	call   400a1c5 <kputsSecure>
    
    if (!header->flags.is_exist) {
 40069e4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 40069e8:	0f b6 00             	movzbl (%rax),%eax
 40069eb:	83 e0 02             	and    $0x2,%eax
 40069ee:	84 c0                	test   %al,%al
 40069f0:	75 14                	jne    4006a06 <print_PgControlBlockHeader(PgControlBlockHeader*)+0x76>
        kputsSecure("  Page not exists\n");
 40069f2:	48 8d 05 4e 9d 00 00 	lea    0x9d4e(%rip),%rax        # 4010747 <NullPgControlBlockHeader+0x257>
 40069f9:	48 89 c7             	mov    %rax,%rdi
 40069fc:	e8 c4 37 00 00       	call   400a1c5 <kputsSecure>
        return;
 4006a01:	e9 93 00 00 00       	jmp    4006a99 <print_PgControlBlockHeader(PgControlBlockHeader*)+0x109>
    }
    
    if (header->flags.is_atom) {
 4006a06:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4006a0a:	0f b6 00             	movzbl (%rax),%eax
 4006a0d:	83 e0 04             	and    $0x4,%eax
 4006a10:	84 c0                	test   %al,%al
 4006a12:	74 11                	je     4006a25 <print_PgControlBlockHeader(PgControlBlockHeader*)+0x95>
        kputsSecure("  Atomic node - no lower levels\n");
 4006a14:	48 8d 05 45 9d 00 00 	lea    0x9d45(%rip),%rax        # 4010760 <NullPgControlBlockHeader+0x270>
 4006a1b:	48 89 c7             	mov    %rax,%rdi
 4006a1e:	e8 a2 37 00 00       	call   400a1c5 <kputsSecure>
        return;
 4006a23:	eb 74                	jmp    4006a99 <print_PgControlBlockHeader(PgControlBlockHeader*)+0x109>
    }
    

        kputsSecure("  Lower level table (lowerlv_PgCBtb):\n");
 4006a25:	48 8d 05 5c 9d 00 00 	lea    0x9d5c(%rip),%rax        # 4010788 <NullPgControlBlockHeader+0x298>
 4006a2c:	48 89 c7             	mov    %rax,%rdi
 4006a2f:	e8 91 37 00 00       	call   400a1c5 <kputsSecure>
        if (header->base.lowerlvPgCBtb) {
 4006a34:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4006a38:	48 8b 40 08          	mov    0x8(%rax),%rax
 4006a3c:	48 85 c0             	test   %rax,%rax
 4006a3f:	74 49                	je     4006a8a <print_PgControlBlockHeader(PgControlBlockHeader*)+0xfa>
            kputsSecure("    Table exists\n");
 4006a41:	48 8d 05 67 9d 00 00 	lea    0x9d67(%rip),%rax        # 40107af <NullPgControlBlockHeader+0x2bf>
 4006a48:	48 89 c7             	mov    %rax,%rdi
 4006a4b:	e8 75 37 00 00       	call   400a1c5 <kputsSecure>
            kputsSecure("    pgextention: ");
 4006a50:	48 8d 05 6a 9d 00 00 	lea    0x9d6a(%rip),%rax        # 40107c1 <NullPgControlBlockHeader+0x2d1>
 4006a57:	48 89 c7             	mov    %rax,%rdi
 4006a5a:	e8 66 37 00 00       	call   400a1c5 <kputsSecure>
            kpnumSecure(&header->base.lowerlvPgCBtb->pgextention, UNHEX, 8);
 4006a5f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4006a63:	48 8b 40 08          	mov    0x8(%rax),%rax
 4006a67:	ba 08 00 00 00       	mov    $0x8,%edx
 4006a6c:	be 05 00 00 00       	mov    $0x5,%esi
 4006a71:	48 89 c7             	mov    %rax,%rdi
 4006a74:	e8 8d 38 00 00       	call   400a306 <kpnumSecure>
            kputsSecure("\n");
 4006a79:	48 8d 05 bf 9a 00 00 	lea    0x9abf(%rip),%rax        # 401053f <NullPgControlBlockHeader+0x4f>
 4006a80:	48 89 c7             	mov    %rax,%rdi
 4006a83:	e8 3d 37 00 00       	call   400a1c5 <kputsSecure>
 4006a88:	eb 0f                	jmp    4006a99 <print_PgControlBlockHeader(PgControlBlockHeader*)+0x109>
        } else {
            kputsSecure("    Table pointer is NULL\n");
 4006a8a:	48 8d 05 42 9d 00 00 	lea    0x9d42(%rip),%rax        # 40107d3 <NullPgControlBlockHeader+0x2e3>
 4006a91:	48 89 c7             	mov    %rax,%rdi
 4006a94:	e8 2c 37 00 00       	call   400a1c5 <kputsSecure>
        }
    
}
 4006a99:	c9                   	leave
 4006a9a:	c3                   	ret
 4006a9b:	90                   	nop

0000000004006a9c <KernelSpacePgsMemMgr::Inner_fixed_addr_manage(unsigned long, KernelSpacePgsMemMgr::phymem_pgs_queue, bool, KernelSpacePgsMemMgr::pgaccess)>:
 * 输入的size_in_byte是字节数，向上取整到4kb
 * alloc_or_free1表示alloc.,0表示free
 */

phyaddr_t KernelSpacePgsMemMgr::Inner_fixed_addr_manage(phyaddr_t base, phymem_pgs_queue queue, bool alloc_or_free, pgaccess access)
{
 4006a9c:	55                   	push   %rbp
 4006a9d:	48 89 e5             	mov    %rsp,%rbp
 4006aa0:	48 83 ec 40          	sub    $0x40,%rsp
 4006aa4:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
 4006aa8:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
 4006aac:	89 d0                	mov    %edx,%eax
 4006aae:	88 4d cf             	mov    %cl,-0x31(%rbp)
 4006ab1:	88 45 cc             	mov    %al,-0x34(%rbp)
    phyaddr_t scan_addr=base;
 4006ab4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
 4006ab8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    pgflags flag_of_pg={0 };
 4006abc:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
 4006ac3:	00 
    flag_of_pg.physical_or_virtual_pg=0;
 4006ac4:	0f b6 45 e0          	movzbl -0x20(%rbp),%eax
 4006ac8:	83 e0 fe             	and    $0xfffffffe,%eax
 4006acb:	88 45 e0             	mov    %al,-0x20(%rbp)
    flag_of_pg.is_occupied=alloc_or_free;
 4006ace:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
 4006ad2:	83 e0 01             	and    $0x1,%eax
 4006ad5:	c1 e0 04             	shl    $0x4,%eax
 4006ad8:	89 c2                	mov    %eax,%edx
 4006ada:	0f b6 45 e0          	movzbl -0x20(%rbp),%eax
 4006ade:	83 e0 ef             	and    $0xffffffef,%eax
 4006ae1:	09 d0                	or     %edx,%eax
 4006ae3:	88 45 e0             	mov    %al,-0x20(%rbp)
    flag_of_pg.is_atom=1;
 4006ae6:	0f b6 45 e0          	movzbl -0x20(%rbp),%eax
 4006aea:	83 c8 04             	or     $0x4,%eax
 4006aed:	88 45 e0             	mov    %al,-0x20(%rbp)
    flag_of_pg.is_exist=1;
 4006af0:	0f b6 45 e0          	movzbl -0x20(%rbp),%eax
 4006af4:	83 c8 02             	or     $0x2,%eax
 4006af7:	88 45 e0             	mov    %al,-0x20(%rbp)
    flag_of_pg.is_kernel=access.is_kernel;
 4006afa:	0f b6 45 cf          	movzbl -0x31(%rbp),%eax
 4006afe:	83 e0 01             	and    $0x1,%eax
 4006b01:	83 e0 01             	and    $0x1,%eax
 4006b04:	c1 e0 05             	shl    $0x5,%eax
 4006b07:	89 c2                	mov    %eax,%edx
 4006b09:	0f b6 45 e0          	movzbl -0x20(%rbp),%eax
 4006b0d:	83 e0 df             	and    $0xffffffdf,%eax
 4006b10:	09 d0                	or     %edx,%eax
 4006b12:	88 45 e0             	mov    %al,-0x20(%rbp)
    flag_of_pg.is_readable=access.is_readable;
 4006b15:	0f b6 45 cf          	movzbl -0x31(%rbp),%eax
 4006b19:	c0 e8 02             	shr    $0x2,%al
 4006b1c:	83 e0 01             	and    $0x1,%eax
 4006b1f:	83 e0 01             	and    $0x1,%eax
 4006b22:	c1 e0 06             	shl    $0x6,%eax
 4006b25:	89 c2                	mov    %eax,%edx
 4006b27:	0f b6 45 e0          	movzbl -0x20(%rbp),%eax
 4006b2b:	83 e0 bf             	and    $0xffffffbf,%eax
 4006b2e:	09 d0                	or     %edx,%eax
 4006b30:	88 45 e0             	mov    %al,-0x20(%rbp)
    flag_of_pg.is_writable=access.is_writeable;
 4006b33:	0f b6 45 cf          	movzbl -0x31(%rbp),%eax
 4006b37:	d0 e8                	shr    $1,%al
 4006b39:	83 e0 01             	and    $0x1,%eax
 4006b3c:	c1 e0 07             	shl    $0x7,%eax
 4006b3f:	89 c2                	mov    %eax,%edx
 4006b41:	0f b6 45 e0          	movzbl -0x20(%rbp),%eax
 4006b45:	83 e0 7f             	and    $0x7f,%eax
 4006b48:	09 d0                	or     %edx,%eax
 4006b4a:	88 45 e0             	mov    %al,-0x20(%rbp)
    flag_of_pg.is_executable=access.is_executable;
 4006b4d:	0f b6 45 cf          	movzbl -0x31(%rbp),%eax
 4006b51:	c0 e8 03             	shr    $0x3,%al
 4006b54:	83 e0 01             	and    $0x1,%eax
 4006b57:	83 e0 01             	and    $0x1,%eax
 4006b5a:	89 c2                	mov    %eax,%edx
 4006b5c:	0f b6 45 e1          	movzbl -0x1f(%rbp),%eax
 4006b60:	83 e0 fe             	and    $0xfffffffe,%eax
 4006b63:	09 d0                	or     %edx,%eax
 4006b65:	88 45 e1             	mov    %al,-0x1f(%rbp)
    for(int i=0;i<queue.entry_count;i++)
 4006b68:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
 4006b6f:	e9 ff 00 00 00       	jmp    4006c73 <KernelSpacePgsMemMgr::Inner_fixed_addr_manage(unsigned long, KernelSpacePgsMemMgr::phymem_pgs_queue, bool, KernelSpacePgsMemMgr::pgaccess)+0x1d7>
    {
        uint8_t lv=queue.entry[i].pgs_lv;
 4006b74:	8b 45 f4             	mov    -0xc(%rbp),%eax
 4006b77:	48 98                	cltq
 4006b79:	48 c1 e0 04          	shl    $0x4,%rax
 4006b7d:	48 8d 40 10          	lea    0x10(%rax),%rax
 4006b81:	48 01 e8             	add    %rbp,%rax
 4006b84:	48 83 c0 10          	add    $0x10,%rax
 4006b88:	0f b6 00             	movzbl (%rax),%eax
 4006b8b:	88 45 ef             	mov    %al,-0x11(%rbp)
        flag_of_pg.pg_lv=lv;
 4006b8e:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
 4006b92:	83 e0 07             	and    $0x7,%eax
 4006b95:	83 e0 07             	and    $0x7,%eax
 4006b98:	8d 14 85 00 00 00 00 	lea    0x0(,%rax,4),%edx
 4006b9f:	0f b6 45 e1          	movzbl -0x1f(%rbp),%eax
 4006ba3:	83 e0 e3             	and    $0xffffffe3,%eax
 4006ba6:	09 d0                	or     %edx,%eax
 4006ba8:	88 45 e1             	mov    %al,-0x1f(%rbp)
        for(int j=0;j<queue.entry[i].pgs_count;j++)
 4006bab:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
 4006bb2:	e9 92 00 00 00       	jmp    4006c49 <KernelSpacePgsMemMgr::Inner_fixed_addr_manage(unsigned long, KernelSpacePgsMemMgr::phymem_pgs_queue, bool, KernelSpacePgsMemMgr::pgaccess)+0x1ad>
        {
            if((this->*PgCBtb_construct_func[lv])(scan_addr,flag_of_pg)!=OS_SUCCESS)
 4006bb7:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
 4006bbb:	0f b6 55 ef          	movzbl -0x11(%rbp),%edx
 4006bbf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4006bc3:	48 63 d2             	movslq %edx,%rdx
 4006bc6:	48 81 c2 02 01 00 00 	add    $0x102,%rdx
 4006bcd:	48 c1 e2 04          	shl    $0x4,%rdx
 4006bd1:	48 01 d0             	add    %rdx,%rax
 4006bd4:	48 8b 50 10          	mov    0x10(%rax),%rdx
 4006bd8:	48 8b 40 08          	mov    0x8(%rax),%rax
 4006bdc:	48 89 c6             	mov    %rax,%rsi
 4006bdf:	83 e6 01             	and    $0x1,%esi
 4006be2:	48 85 f6             	test   %rsi,%rsi
 4006be5:	74 18                	je     4006bff <KernelSpacePgsMemMgr::Inner_fixed_addr_manage(unsigned long, KernelSpacePgsMemMgr::phymem_pgs_queue, bool, KernelSpacePgsMemMgr::pgaccess)+0x163>
 4006be7:	48 89 d6             	mov    %rdx,%rsi
 4006bea:	48 01 ce             	add    %rcx,%rsi
 4006bed:	48 8b 36             	mov    (%rsi),%rsi
 4006bf0:	48 89 c7             	mov    %rax,%rdi
 4006bf3:	48 83 ef 01          	sub    $0x1,%rdi
 4006bf7:	48 01 fe             	add    %rdi,%rsi
 4006bfa:	4c 8b 06             	mov    (%rsi),%r8
 4006bfd:	eb 03                	jmp    4006c02 <KernelSpacePgsMemMgr::Inner_fixed_addr_manage(unsigned long, KernelSpacePgsMemMgr::phymem_pgs_queue, bool, KernelSpacePgsMemMgr::pgaccess)+0x166>
 4006bff:	49 89 c0             	mov    %rax,%r8
 4006c02:	48 89 d0             	mov    %rdx,%rax
 4006c05:	48 01 c1             	add    %rax,%rcx
 4006c08:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
 4006c0c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4006c10:	48 89 c6             	mov    %rax,%rsi
 4006c13:	48 89 cf             	mov    %rcx,%rdi
 4006c16:	41 ff d0             	call   *%r8
 4006c19:	85 c0                	test   %eax,%eax
 4006c1b:	0f 95 c0             	setne  %al
 4006c1e:	84 c0                	test   %al,%al
 4006c20:	74 06                	je     4006c28 <KernelSpacePgsMemMgr::Inner_fixed_addr_manage(unsigned long, KernelSpacePgsMemMgr::phymem_pgs_queue, bool, KernelSpacePgsMemMgr::pgaccess)+0x18c>
            return scan_addr;
 4006c22:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4006c26:	eb 5f                	jmp    4006c87 <KernelSpacePgsMemMgr::Inner_fixed_addr_manage(unsigned long, KernelSpacePgsMemMgr::phymem_pgs_queue, bool, KernelSpacePgsMemMgr::pgaccess)+0x1eb>
            scan_addr+=PAGE_SIZE_IN_LV[lv];
 4006c28:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
 4006c2c:	48 98                	cltq
 4006c2e:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
 4006c35:	00 
 4006c36:	48 8d 05 c3 9b 00 00 	lea    0x9bc3(%rip),%rax        # 4010800 <PAGE_SIZE_IN_LV>
 4006c3d:	48 8b 04 02          	mov    (%rdx,%rax,1),%rax
 4006c41:	48 01 45 f8          	add    %rax,-0x8(%rbp)
        for(int j=0;j<queue.entry[i].pgs_count;j++)
 4006c45:	83 45 f0 01          	addl   $0x1,-0x10(%rbp)
 4006c49:	8b 45 f0             	mov    -0x10(%rbp),%eax
 4006c4c:	48 63 d0             	movslq %eax,%rdx
 4006c4f:	8b 45 f4             	mov    -0xc(%rbp),%eax
 4006c52:	48 98                	cltq
 4006c54:	48 c1 e0 04          	shl    $0x4,%rax
 4006c58:	48 8d 40 10          	lea    0x10(%rax),%rax
 4006c5c:	48 01 e8             	add    %rbp,%rax
 4006c5f:	48 83 c0 08          	add    $0x8,%rax
 4006c63:	48 8b 00             	mov    (%rax),%rax
 4006c66:	48 39 c2             	cmp    %rax,%rdx
 4006c69:	0f 82 48 ff ff ff    	jb     4006bb7 <KernelSpacePgsMemMgr::Inner_fixed_addr_manage(unsigned long, KernelSpacePgsMemMgr::phymem_pgs_queue, bool, KernelSpacePgsMemMgr::pgaccess)+0x11b>
    for(int i=0;i<queue.entry_count;i++)
 4006c6f:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
 4006c73:	0f b6 45 10          	movzbl 0x10(%rbp),%eax
 4006c77:	0f b6 c0             	movzbl %al,%eax
 4006c7a:	39 45 f4             	cmp    %eax,-0xc(%rbp)
 4006c7d:	0f 8c f1 fe ff ff    	jl     4006b74 <KernelSpacePgsMemMgr::Inner_fixed_addr_manage(unsigned long, KernelSpacePgsMemMgr::phymem_pgs_queue, bool, KernelSpacePgsMemMgr::pgaccess)+0xd8>
        }
    }
    return scan_addr;
 4006c83:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
 4006c87:	c9                   	leave
 4006c88:	c3                   	ret
 4006c89:	90                   	nop

0000000004006c8a <KernelSpacePgsMemMgr::pgs_allocate(unsigned long, KernelSpacePgsMemMgr::pgaccess, unsigned char)>:
void *KernelSpacePgsMemMgr::pgs_allocate(uint64_t size_in_byte, uint8_t align_require)
{
 4006c8a:	55                   	push   %rbp
 4006c8b:	48 89 e5             	mov    %rsp,%rbp
 4006c8e:	53                   	push   %rbx
 4006c8f:	48 83 ec 58          	sub    $0x58,%rsp
 4006c93:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
 4006c97:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
 4006c9b:	88 55 af             	mov    %dl,-0x51(%rbp)
 4006c9e:	89 c8                	mov    %ecx,%eax
 4006ca0:	88 45 ac             	mov    %al,-0x54(%rbp)

 4006ca3:	48 83 7d b0 00       	cmpq   $0x0,-0x50(%rbp)
 4006ca8:	75 0a                	jne    4006cb4 <KernelSpacePgsMemMgr::pgs_allocate(unsigned long, KernelSpacePgsMemMgr::pgaccess, unsigned char)+0x2a>
 4006caa:	b8 00 00 00 00       	mov    $0x0,%eax
 4006caf:	e9 81 02 00 00       	jmp    4006f35 <KernelSpacePgsMemMgr::pgs_allocate(unsigned long, KernelSpacePgsMemMgr::pgaccess, unsigned char)+0x2ab>
    return nullptr;
 4006cb4:	48 c7 45 e8 00 00 10 	movq   $0x100000,-0x18(%rbp)
 4006cbb:	00 
}
 4006cbc:	b8 ff 0f 00 00       	mov    $0xfff,%eax
 4006cc1:	48 01 45 b0          	add    %rax,-0x50(%rbp)

 4006cc5:	b8 ff 0f 00 00       	mov    $0xfff,%eax
 4006cca:	48 f7 d0             	not    %rax
 4006ccd:	48 21 45 b0          	and    %rax,-0x50(%rbp)
int KernelSpacePgsMemMgr::pgs_fixedaddr_allocate(IN phyaddr_t addr, IN size_t size_in_byte)
 4006cd1:	0f b6 45 ac          	movzbl -0x54(%rbp),%eax
 4006cd5:	ba 01 00 00 00       	mov    $0x1,%edx
 4006cda:	89 c1                	mov    %eax,%ecx
 4006cdc:	48 d3 e2             	shl    %cl,%rdx
 4006cdf:	48 89 d0             	mov    %rdx,%rax
 4006ce2:	48 83 e8 01          	sub    $0x1,%rax
 4006ce6:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
{
 4006cea:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
 4006cf1:	00 

    return OS_SUCCESS;
 4006cf2:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
 4006cf6:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
 4006cfa:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 4006cfe:	48 89 ce             	mov    %rcx,%rsi
 4006d01:	48 89 c7             	mov    %rax,%rdi
 4006d04:	e8 75 0d 00 00       	call   4007a7e <KernelSpacePgsMemMgr::queryPhysicalMemoryUsage(unsigned long, unsigned long)>
 4006d09:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
}
 4006d0d:	48 81 7d d8 01 10 00 	cmpq   $0x1001,-0x28(%rbp)
 4006d14:	00 
 4006d15:	75 0a                	jne    4006d21 <KernelSpacePgsMemMgr::pgs_allocate(unsigned long, KernelSpacePgsMemMgr::pgaccess, unsigned char)+0x97>

 4006d17:	b8 01 10 00 00       	mov    $0x1001,%eax
 4006d1c:	e9 14 02 00 00       	jmp    4006f35 <KernelSpacePgsMemMgr::pgs_allocate(unsigned long, KernelSpacePgsMemMgr::pgaccess, unsigned char)+0x2ab>

 4006d21:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
 4006d26:	75 0a                	jne    4006d32 <KernelSpacePgsMemMgr::pgs_allocate(unsigned long, KernelSpacePgsMemMgr::pgaccess, unsigned char)+0xa8>
 4006d28:	b8 00 00 00 00       	mov    $0x0,%eax
 4006d2d:	e9 03 02 00 00       	jmp    4006f35 <KernelSpacePgsMemMgr::pgs_allocate(unsigned long, KernelSpacePgsMemMgr::pgaccess, unsigned char)+0x2ab>
int KernelSpacePgsMemMgr::pgs_free(phyaddr_t addr )
 4006d32:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4006d36:	8b 00                	mov    (%rax),%eax
 4006d38:	83 f8 15             	cmp    $0x15,%eax
 4006d3b:	75 3f                	jne    4006d7c <KernelSpacePgsMemMgr::pgs_allocate(unsigned long, KernelSpacePgsMemMgr::pgaccess, unsigned char)+0xf2>
{   
 4006d3d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4006d41:	48 8b 40 20          	mov    0x20(%rax),%rax
 4006d45:	83 e0 01             	and    $0x1,%eax
int KernelSpacePgsMemMgr::pgs_free(phyaddr_t addr )
 4006d48:	48 85 c0             	test   %rax,%rax
 4006d4b:	75 2f                	jne    4006d7c <KernelSpacePgsMemMgr::pgs_allocate(unsigned long, KernelSpacePgsMemMgr::pgaccess, unsigned char)+0xf2>
    return OS_SUCCESS;
 4006d4d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4006d51:	48 8b 40 18          	mov    0x18(%rax),%rax
 4006d55:	ba 00 10 00 00       	mov    $0x1000,%edx
 4006d5a:	48 0f af c2          	imul   %rdx,%rax
{   
 4006d5e:	48 3b 45 b0          	cmp    -0x50(%rbp),%rax
 4006d62:	72 18                	jb     4006d7c <KernelSpacePgsMemMgr::pgs_allocate(unsigned long, KernelSpacePgsMemMgr::pgaccess, unsigned char)+0xf2>
}

 4006d64:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4006d68:	48 85 c0             	test   %rax,%rax
 4006d6b:	74 53                	je     4006dc0 <KernelSpacePgsMemMgr::pgs_allocate(unsigned long, KernelSpacePgsMemMgr::pgaccess, unsigned char)+0x136>
 4006d6d:	be 30 00 00 00       	mov    $0x30,%esi
 4006d72:	48 89 c7             	mov    %rax,%rdi
 4006d75:	e8 34 d9 ff ff       	call   40046ae <operator delete(void*, unsigned long)>
 KernelSpacePgsMemMgr::phymem_pgs_queue *KernelSpacePgsMemMgr::seg_to_queue(phyaddr_t base,uint64_t size_in_bytes){
 4006d7a:	eb 44                	jmp    4006dc0 <KernelSpacePgsMemMgr::pgs_allocate(unsigned long, KernelSpacePgsMemMgr::pgaccess, unsigned char)+0x136>
    uint64_t end_addr = base + size_in_bytes;
    end_addr+=PAGE_SIZE_IN_LV[0]-1;
    end_addr&=~PAGE_OFFSET_MASK[0];
    phymem_pgs_queue* queue = new phymem_pgs_queue;
 4006d7c:	ba 00 10 00 00       	mov    $0x1000,%edx
 4006d81:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4006d85:	48 8b 40 18          	mov    0x18(%rax),%rax
 4006d89:	48 0f af c2          	imul   %rdx,%rax
 4006d8d:	48 01 45 e8          	add    %rax,-0x18(%rbp)
    if (queue==nullptr)
 4006d91:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4006d95:	48 01 45 e8          	add    %rax,-0x18(%rbp)
    {
 4006d99:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4006d9d:	48 f7 d0             	not    %rax
 4006da0:	48 21 45 e8          	and    %rax,-0x18(%rbp)
        return nullptr;
 4006da4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4006da8:	48 85 c0             	test   %rax,%rax
 4006dab:	74 0d                	je     4006dba <KernelSpacePgsMemMgr::pgs_allocate(unsigned long, KernelSpacePgsMemMgr::pgaccess, unsigned char)+0x130>
 4006dad:	be 30 00 00 00       	mov    $0x30,%esi
 4006db2:	48 89 c7             	mov    %rax,%rdi
 4006db5:	e8 f4 d8 ff ff       	call   40046ae <operator delete(void*, unsigned long)>
    }
 4006dba:	90                   	nop
    {
        // 从最大支持的页大小开始尝试
        int pglv_index = Max_huge_pg_index;
        
        // 找到适合当前地址的最大页大小
        while (pglv_index >= 0)
 4006dbb:	e9 32 ff ff ff       	jmp    4006cf2 <KernelSpacePgsMemMgr::pgs_allocate(unsigned long, KernelSpacePgsMemMgr::pgaccess, unsigned char)+0x68>
 KernelSpacePgsMemMgr::phymem_pgs_queue *KernelSpacePgsMemMgr::seg_to_queue(phyaddr_t base,uint64_t size_in_bytes){
 4006dc0:	90                   	nop
        {
            // 检查地址对齐和是否超出内存区域
 4006dc1:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
 4006dc5:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
 4006dc9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 4006dcd:	48 89 ce             	mov    %rcx,%rsi
 4006dd0:	48 89 c7             	mov    %rax,%rdi
 4006dd3:	e8 b6 05 00 00       	call   400738e <KernelSpacePgsMemMgr::seg_to_queue(unsigned long, unsigned long)>
 4006dd8:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
            if ((scan_addr & PAGE_OFFSET_MASK[pglv_index]) == 0 && // 地址对齐
 4006ddc:	44 0f b6 45 af       	movzbl -0x51(%rbp),%r8d
 4006de1:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
 4006de5:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
 4006de9:	48 83 ec 08          	sub    $0x8,%rsp
 4006ded:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
 4006df1:	48 81 ec a8 00 00 00 	sub    $0xa8,%rsp
 4006df8:	48 89 e2             	mov    %rsp,%rdx
 4006dfb:	48 8b 08             	mov    (%rax),%rcx
 4006dfe:	48 8b 58 08          	mov    0x8(%rax),%rbx
 4006e02:	48 89 0a             	mov    %rcx,(%rdx)
 4006e05:	48 89 5a 08          	mov    %rbx,0x8(%rdx)
 4006e09:	48 8b 48 10          	mov    0x10(%rax),%rcx
 4006e0d:	48 8b 58 18          	mov    0x18(%rax),%rbx
 4006e11:	48 89 4a 10          	mov    %rcx,0x10(%rdx)
 4006e15:	48 89 5a 18          	mov    %rbx,0x18(%rdx)
 4006e19:	48 8b 48 20          	mov    0x20(%rax),%rcx
 4006e1d:	48 8b 58 28          	mov    0x28(%rax),%rbx
 4006e21:	48 89 4a 20          	mov    %rcx,0x20(%rdx)
 4006e25:	48 89 5a 28          	mov    %rbx,0x28(%rdx)
 4006e29:	48 8b 48 30          	mov    0x30(%rax),%rcx
 4006e2d:	48 8b 58 38          	mov    0x38(%rax),%rbx
 4006e31:	48 89 4a 30          	mov    %rcx,0x30(%rdx)
 4006e35:	48 89 5a 38          	mov    %rbx,0x38(%rdx)
 4006e39:	48 8b 48 40          	mov    0x40(%rax),%rcx
 4006e3d:	48 8b 58 48          	mov    0x48(%rax),%rbx
 4006e41:	48 89 4a 40          	mov    %rcx,0x40(%rdx)
 4006e45:	48 89 5a 48          	mov    %rbx,0x48(%rdx)
 4006e49:	48 8b 48 50          	mov    0x50(%rax),%rcx
 4006e4d:	48 8b 58 58          	mov    0x58(%rax),%rbx
 4006e51:	48 89 4a 50          	mov    %rcx,0x50(%rdx)
 4006e55:	48 89 5a 58          	mov    %rbx,0x58(%rdx)
 4006e59:	48 8b 48 60          	mov    0x60(%rax),%rcx
 4006e5d:	48 8b 58 68          	mov    0x68(%rax),%rbx
 4006e61:	48 89 4a 60          	mov    %rcx,0x60(%rdx)
 4006e65:	48 89 5a 68          	mov    %rbx,0x68(%rdx)
 4006e69:	48 8b 48 70          	mov    0x70(%rax),%rcx
 4006e6d:	48 8b 58 78          	mov    0x78(%rax),%rbx
 4006e71:	48 89 4a 70          	mov    %rcx,0x70(%rdx)
 4006e75:	48 89 5a 78          	mov    %rbx,0x78(%rdx)
 4006e79:	48 8b 88 80 00 00 00 	mov    0x80(%rax),%rcx
 4006e80:	48 8b 98 88 00 00 00 	mov    0x88(%rax),%rbx
 4006e87:	48 89 8a 80 00 00 00 	mov    %rcx,0x80(%rdx)
 4006e8e:	48 89 9a 88 00 00 00 	mov    %rbx,0x88(%rdx)
 4006e95:	48 8b 88 90 00 00 00 	mov    0x90(%rax),%rcx
 4006e9c:	48 8b 98 98 00 00 00 	mov    0x98(%rax),%rbx
 4006ea3:	48 89 8a 90 00 00 00 	mov    %rcx,0x90(%rdx)
 4006eaa:	48 89 9a 98 00 00 00 	mov    %rbx,0x98(%rdx)
 4006eb1:	48 8b 80 a0 00 00 00 	mov    0xa0(%rax),%rax
 4006eb8:	48 89 82 a0 00 00 00 	mov    %rax,0xa0(%rdx)
 4006ebf:	44 89 c1             	mov    %r8d,%ecx
 4006ec2:	ba 01 00 00 00       	mov    $0x1,%edx
 4006ec7:	e8 d0 fb ff ff       	call   4006a9c <KernelSpacePgsMemMgr::Inner_fixed_addr_manage(unsigned long, KernelSpacePgsMemMgr::phymem_pgs_queue, bool, KernelSpacePgsMemMgr::pgaccess)>
 4006ecc:	48 81 c4 b0 00 00 00 	add    $0xb0,%rsp
 4006ed3:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
                scan_addr + PAGE_SIZE_IN_LV[pglv_index] - 1 <= end_addr) // 不超出内存区域
 4006ed7:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
 4006edb:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
 4006edf:	48 01 d0             	add    %rdx,%rax
 4006ee2:	48 39 45 c8          	cmp    %rax,-0x38(%rbp)
 4006ee6:	74 1d                	je     4006f05 <KernelSpacePgsMemMgr::pgs_allocate(unsigned long, KernelSpacePgsMemMgr::pgaccess, unsigned char)+0x27b>
            {
                break;
 4006ee8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
 4006eec:	48 85 c0             	test   %rax,%rax
 4006eef:	74 0d                	je     4006efe <KernelSpacePgsMemMgr::pgs_allocate(unsigned long, KernelSpacePgsMemMgr::pgaccess, unsigned char)+0x274>
 4006ef1:	be a8 00 00 00       	mov    $0xa8,%esi
 4006ef6:	48 89 c7             	mov    %rax,%rdi
 4006ef9:	e8 b0 d7 ff ff       	call   40046ae <operator delete(void*, unsigned long)>
            }
 4006efe:	b8 00 00 00 00       	mov    $0x0,%eax
 4006f03:	eb 30                	jmp    4006f35 <KernelSpacePgsMemMgr::pgs_allocate(unsigned long, KernelSpacePgsMemMgr::pgaccess, unsigned char)+0x2ab>
            pglv_index--;
        }
 4006f05:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4006f09:	48 85 c0             	test   %rax,%rax
 4006f0c:	74 0d                	je     4006f1b <KernelSpacePgsMemMgr::pgs_allocate(unsigned long, KernelSpacePgsMemMgr::pgaccess, unsigned char)+0x291>
 4006f0e:	be 30 00 00 00       	mov    $0x30,%esi
 4006f13:	48 89 c7             	mov    %rax,%rdi
 4006f16:	e8 93 d7 ff ff       	call   40046ae <operator delete(void*, unsigned long)>
        
 4006f1b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
 4006f1f:	48 85 c0             	test   %rax,%rax
 4006f22:	74 0d                	je     4006f31 <KernelSpacePgsMemMgr::pgs_allocate(unsigned long, KernelSpacePgsMemMgr::pgaccess, unsigned char)+0x2a7>
 4006f24:	be a8 00 00 00       	mov    $0xa8,%esi
 4006f29:	48 89 c7             	mov    %rax,%rdi
 4006f2c:	e8 7d d7 ff ff       	call   40046ae <operator delete(void*, unsigned long)>
        if (pglv_index < 0)
 4006f31:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
        {
 4006f35:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
 4006f39:	c9                   	leave
 4006f3a:	c3                   	ret
 4006f3b:	90                   	nop

0000000004006f3c <KernelSpacePgsMemMgr::pgs_fixedaddr_allocate(unsigned long, unsigned long, KernelSpacePgsMemMgr::pgaccess)>:
            delete queue;
            return nullptr;
        }
 4006f3c:	55                   	push   %rbp
 4006f3d:	48 89 e5             	mov    %rsp,%rbp
 4006f40:	53                   	push   %rbx
 4006f41:	48 83 ec 48          	sub    $0x48,%rsp
 4006f45:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
 4006f49:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
 4006f4d:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
 4006f51:	88 4d b7             	mov    %cl,-0x49(%rbp)
        
 4006f54:	b8 ff 0f 00 00       	mov    $0xfff,%eax
 4006f59:	48 23 45 c0          	and    -0x40(%rbp),%rax
 4006f5d:	48 85 c0             	test   %rax,%rax
 4006f60:	74 0a                	je     4006f6c <KernelSpacePgsMemMgr::pgs_fixedaddr_allocate(unsigned long, unsigned long, KernelSpacePgsMemMgr::pgaccess)+0x30>
 4006f62:	b8 04 10 00 00       	mov    $0x1004,%eax
 4006f67:	e9 f8 01 00 00       	jmp    4007164 <KernelSpacePgsMemMgr::pgs_fixedaddr_allocate(unsigned long, unsigned long, KernelSpacePgsMemMgr::pgaccess)+0x228>
        // 添加到队列
 4006f6c:	b8 ff 0f 00 00       	mov    $0xfff,%eax
 4006f71:	48 01 45 b8          	add    %rax,-0x48(%rbp)
        if (queue->entry_count == 0 || 
 4006f75:	b8 ff 0f 00 00       	mov    $0xfff,%eax
 4006f7a:	48 f7 d0             	not    %rax
 4006f7d:	48 21 45 b8          	and    %rax,-0x48(%rbp)
            queue->entry[queue->entry_count - 1].pgs_lv != pglv_index)
 4006f81:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
 4006f85:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
 4006f89:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 4006f8d:	48 89 ce             	mov    %rcx,%rsi
 4006f90:	48 89 c7             	mov    %rax,%rdi
 4006f93:	e8 e6 0a 00 00       	call   4007a7e <KernelSpacePgsMemMgr::queryPhysicalMemoryUsage(unsigned long, unsigned long)>
 4006f98:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
        {
 4006f9c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4006fa0:	48 83 c0 30          	add    $0x30,%rax
 4006fa4:	8b 00                	mov    (%rax),%eax
 4006fa6:	85 c0                	test   %eax,%eax
 4006fa8:	74 20                	je     4006fca <KernelSpacePgsMemMgr::pgs_fixedaddr_allocate(unsigned long, unsigned long, KernelSpacePgsMemMgr::pgaccess)+0x8e>
            // 新类型的页
            if (queue->entry_count >= 10)
 4006faa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4006fae:	48 85 c0             	test   %rax,%rax
 4006fb1:	74 0d                	je     4006fc0 <KernelSpacePgsMemMgr::pgs_fixedaddr_allocate(unsigned long, unsigned long, KernelSpacePgsMemMgr::pgaccess)+0x84>
 4006fb3:	be 30 00 00 00       	mov    $0x30,%esi
 4006fb8:	48 89 c7             	mov    %rax,%rdi
 4006fbb:	e8 ee d6 ff ff       	call   40046ae <operator delete(void*, unsigned long)>
            {
 4006fc0:	b8 13 10 00 00       	mov    $0x1013,%eax
 4006fc5:	e9 9a 01 00 00       	jmp    4007164 <KernelSpacePgsMemMgr::pgs_fixedaddr_allocate(unsigned long, unsigned long, KernelSpacePgsMemMgr::pgaccess)+0x228>
                delete queue;
                return nullptr; // 队列已满
            }
 4006fca:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4006fce:	8b 00                	mov    (%rax),%eax
 4006fd0:	83 f8 15             	cmp    $0x15,%eax
 4006fd3:	74 30                	je     4007005 <KernelSpacePgsMemMgr::pgs_fixedaddr_allocate(unsigned long, unsigned long, KernelSpacePgsMemMgr::pgaccess)+0xc9>
            queue->entry[queue->entry_count].pgs_lv = pglv_index;
 4006fd5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4006fd9:	48 8b 40 20          	mov    0x20(%rax),%rax
 4006fdd:	83 e0 01             	and    $0x1,%eax
            }
 4006fe0:	48 85 c0             	test   %rax,%rax
 4006fe3:	74 20                	je     4007005 <KernelSpacePgsMemMgr::pgs_fixedaddr_allocate(unsigned long, unsigned long, KernelSpacePgsMemMgr::pgaccess)+0xc9>
            queue->entry[queue->entry_count].pgs_count = 1;
            queue->entry_count++;
 4006fe5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4006fe9:	48 85 c0             	test   %rax,%rax
 4006fec:	74 0d                	je     4006ffb <KernelSpacePgsMemMgr::pgs_fixedaddr_allocate(unsigned long, unsigned long, KernelSpacePgsMemMgr::pgaccess)+0xbf>
 4006fee:	be 30 00 00 00       	mov    $0x30,%esi
 4006ff3:	48 89 c7             	mov    %rax,%rdi
 4006ff6:	e8 b3 d6 ff ff       	call   40046ae <operator delete(void*, unsigned long)>
        }
 4006ffb:	b8 13 10 00 00       	mov    $0x1013,%eax
 4007000:	e9 5f 01 00 00       	jmp    4007164 <KernelSpacePgsMemMgr::pgs_fixedaddr_allocate(unsigned long, unsigned long, KernelSpacePgsMemMgr::pgaccess)+0x228>
        else
        {
            // 相同类型的页，增加计数
 4007005:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4007009:	48 85 c0             	test   %rax,%rax
 400700c:	74 0d                	je     400701b <KernelSpacePgsMemMgr::pgs_fixedaddr_allocate(unsigned long, unsigned long, KernelSpacePgsMemMgr::pgaccess)+0xdf>
 400700e:	be 30 00 00 00       	mov    $0x30,%esi
 4007013:	48 89 c7             	mov    %rax,%rdi
 4007016:	e8 93 d6 ff ff       	call   40046ae <operator delete(void*, unsigned long)>
            queue->entry[queue->entry_count - 1].pgs_count++;
 400701b:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
 400701f:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
 4007023:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 4007027:	48 89 ce             	mov    %rcx,%rsi
 400702a:	48 89 c7             	mov    %rax,%rdi
 400702d:	e8 5c 03 00 00       	call   400738e <KernelSpacePgsMemMgr::seg_to_queue(unsigned long, unsigned long)>
 4007032:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
        }
 4007036:	44 0f b6 45 b7       	movzbl -0x49(%rbp),%r8d
 400703b:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
 400703f:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
 4007043:	48 83 ec 08          	sub    $0x8,%rsp
 4007047:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 400704b:	48 81 ec a8 00 00 00 	sub    $0xa8,%rsp
 4007052:	48 89 e2             	mov    %rsp,%rdx
 4007055:	48 8b 08             	mov    (%rax),%rcx
 4007058:	48 8b 58 08          	mov    0x8(%rax),%rbx
 400705c:	48 89 0a             	mov    %rcx,(%rdx)
 400705f:	48 89 5a 08          	mov    %rbx,0x8(%rdx)
 4007063:	48 8b 48 10          	mov    0x10(%rax),%rcx
 4007067:	48 8b 58 18          	mov    0x18(%rax),%rbx
 400706b:	48 89 4a 10          	mov    %rcx,0x10(%rdx)
 400706f:	48 89 5a 18          	mov    %rbx,0x18(%rdx)
 4007073:	48 8b 48 20          	mov    0x20(%rax),%rcx
 4007077:	48 8b 58 28          	mov    0x28(%rax),%rbx
 400707b:	48 89 4a 20          	mov    %rcx,0x20(%rdx)
 400707f:	48 89 5a 28          	mov    %rbx,0x28(%rdx)
 4007083:	48 8b 48 30          	mov    0x30(%rax),%rcx
 4007087:	48 8b 58 38          	mov    0x38(%rax),%rbx
 400708b:	48 89 4a 30          	mov    %rcx,0x30(%rdx)
 400708f:	48 89 5a 38          	mov    %rbx,0x38(%rdx)
 4007093:	48 8b 48 40          	mov    0x40(%rax),%rcx
 4007097:	48 8b 58 48          	mov    0x48(%rax),%rbx
 400709b:	48 89 4a 40          	mov    %rcx,0x40(%rdx)
 400709f:	48 89 5a 48          	mov    %rbx,0x48(%rdx)
 40070a3:	48 8b 48 50          	mov    0x50(%rax),%rcx
 40070a7:	48 8b 58 58          	mov    0x58(%rax),%rbx
 40070ab:	48 89 4a 50          	mov    %rcx,0x50(%rdx)
 40070af:	48 89 5a 58          	mov    %rbx,0x58(%rdx)
 40070b3:	48 8b 48 60          	mov    0x60(%rax),%rcx
 40070b7:	48 8b 58 68          	mov    0x68(%rax),%rbx
 40070bb:	48 89 4a 60          	mov    %rcx,0x60(%rdx)
 40070bf:	48 89 5a 68          	mov    %rbx,0x68(%rdx)
 40070c3:	48 8b 48 70          	mov    0x70(%rax),%rcx
 40070c7:	48 8b 58 78          	mov    0x78(%rax),%rbx
 40070cb:	48 89 4a 70          	mov    %rcx,0x70(%rdx)
 40070cf:	48 89 5a 78          	mov    %rbx,0x78(%rdx)
 40070d3:	48 8b 88 80 00 00 00 	mov    0x80(%rax),%rcx
 40070da:	48 8b 98 88 00 00 00 	mov    0x88(%rax),%rbx
 40070e1:	48 89 8a 80 00 00 00 	mov    %rcx,0x80(%rdx)
 40070e8:	48 89 9a 88 00 00 00 	mov    %rbx,0x88(%rdx)
 40070ef:	48 8b 88 90 00 00 00 	mov    0x90(%rax),%rcx
 40070f6:	48 8b 98 98 00 00 00 	mov    0x98(%rax),%rbx
 40070fd:	48 89 8a 90 00 00 00 	mov    %rcx,0x90(%rdx)
 4007104:	48 89 9a 98 00 00 00 	mov    %rbx,0x98(%rdx)
 400710b:	48 8b 80 a0 00 00 00 	mov    0xa0(%rax),%rax
 4007112:	48 89 82 a0 00 00 00 	mov    %rax,0xa0(%rdx)
 4007119:	44 89 c1             	mov    %r8d,%ecx
 400711c:	ba 01 00 00 00       	mov    $0x1,%edx
 4007121:	e8 76 f9 ff ff       	call   4006a9c <KernelSpacePgsMemMgr::Inner_fixed_addr_manage(unsigned long, KernelSpacePgsMemMgr::phymem_pgs_queue, bool, KernelSpacePgsMemMgr::pgaccess)>
 4007126:	48 81 c4 b0 00 00 00 	add    $0xb0,%rsp
 400712d:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
        
 4007131:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
 4007135:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 4007139:	48 01 d0             	add    %rdx,%rax
 400713c:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
 4007140:	74 07                	je     4007149 <KernelSpacePgsMemMgr::pgs_fixedaddr_allocate(unsigned long, unsigned long, KernelSpacePgsMemMgr::pgaccess)+0x20d>
        scan_addr += PAGE_SIZE_IN_LV[pglv_index];
    }
 4007142:	b8 13 10 00 00       	mov    $0x1013,%eax
 4007147:	eb 1b                	jmp    4007164 <KernelSpacePgsMemMgr::pgs_fixedaddr_allocate(unsigned long, unsigned long, KernelSpacePgsMemMgr::pgaccess)+0x228>
    return queue;
 4007149:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 400714d:	48 85 c0             	test   %rax,%rax
 4007150:	74 0d                	je     400715f <KernelSpacePgsMemMgr::pgs_fixedaddr_allocate(unsigned long, unsigned long, KernelSpacePgsMemMgr::pgaccess)+0x223>
 4007152:	be a8 00 00 00       	mov    $0xa8,%esi
 4007157:	48 89 c7             	mov    %rax,%rdi
 400715a:	e8 4f d5 ff ff       	call   40046ae <operator delete(void*, unsigned long)>
 400715f:	b8 00 00 00 00       	mov    $0x0,%eax
 4007164:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
 4007168:	c9                   	leave
 4007169:	c3                   	ret

000000000400716a <KernelSpacePgsMemMgr::pgs_free(unsigned long, unsigned long)>:
 400716a:	55                   	push   %rbp
 400716b:	48 89 e5             	mov    %rsp,%rbp
 400716e:	53                   	push   %rbx
 400716f:	48 83 ec 48          	sub    $0x48,%rsp
 4007173:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
 4007177:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
 400717b:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
 400717f:	b8 ff 0f 00 00       	mov    $0xfff,%eax
 4007184:	48 23 45 c0          	and    -0x40(%rbp),%rax
 4007188:	48 85 c0             	test   %rax,%rax
 400718b:	74 0a                	je     4007197 <KernelSpacePgsMemMgr::pgs_free(unsigned long, unsigned long)+0x2d>
 400718d:	b8 04 10 00 00       	mov    $0x1004,%eax
 4007192:	e9 f0 01 00 00       	jmp    4007387 <KernelSpacePgsMemMgr::pgs_free(unsigned long, unsigned long)+0x21d>
 4007197:	b8 ff 0f 00 00       	mov    $0xfff,%eax
 400719c:	48 01 45 b8          	add    %rax,-0x48(%rbp)
 40071a0:	b8 ff 0f 00 00       	mov    $0xfff,%eax
 40071a5:	48 f7 d0             	not    %rax
 40071a8:	48 21 45 b8          	and    %rax,-0x48(%rbp)
 40071ac:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
 40071b0:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
 40071b4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 40071b8:	48 89 ce             	mov    %rcx,%rsi
 40071bb:	48 89 c7             	mov    %rax,%rdi
 40071be:	e8 bb 08 00 00       	call   4007a7e <KernelSpacePgsMemMgr::queryPhysicalMemoryUsage(unsigned long, unsigned long)>
 40071c3:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
 40071c7:	eb 29                	jmp    40071f2 <KernelSpacePgsMemMgr::pgs_free(unsigned long, unsigned long)+0x88>
 40071c9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 40071cd:	8b 00                	mov    (%rax),%eax
 40071cf:	83 f8 15             	cmp    $0x15,%eax
 40071d2:	74 19                	je     40071ed <KernelSpacePgsMemMgr::pgs_free(unsigned long, unsigned long)+0x83>
 40071d4:	48 8d 05 4d 99 00 00 	lea    0x994d(%rip),%rax        # 4010b28 <INDEX_NOT_EXIST+0x8>
 40071db:	48 89 c7             	mov    %rax,%rdi
 40071de:	e8 e2 2f 00 00       	call   400a1c5 <kputsSecure>
 40071e3:	b8 13 10 00 00       	mov    $0x1013,%eax
 40071e8:	e9 9a 01 00 00       	jmp    4007387 <KernelSpacePgsMemMgr::pgs_free(unsigned long, unsigned long)+0x21d>
 40071ed:	48 83 45 e8 30       	addq   $0x30,-0x18(%rbp)
 40071f2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 40071f6:	8b 00                	mov    (%rax),%eax
 40071f8:	85 c0                	test   %eax,%eax
 40071fa:	75 cd                	jne    40071c9 <KernelSpacePgsMemMgr::pgs_free(unsigned long, unsigned long)+0x5f>
 40071fc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4007200:	48 85 c0             	test   %rax,%rax
 4007203:	74 0d                	je     4007212 <KernelSpacePgsMemMgr::pgs_free(unsigned long, unsigned long)+0xa8>
 4007205:	be 30 00 00 00       	mov    $0x30,%esi
 400720a:	48 89 c7             	mov    %rax,%rdi
 400720d:	e8 9c d4 ff ff       	call   40046ae <operator delete(void*, unsigned long)>
 4007212:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
 4007216:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
 400721a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 400721e:	48 89 ce             	mov    %rcx,%rsi
 4007221:	48 89 c7             	mov    %rax,%rdi
 4007224:	e8 65 01 00 00       	call   400738e <KernelSpacePgsMemMgr::seg_to_queue(unsigned long, unsigned long)>
 4007229:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
 400722d:	c6 45 d7 00          	movb   $0x0,-0x29(%rbp)
 4007231:	0f b6 45 d7          	movzbl -0x29(%rbp),%eax
 4007235:	83 c8 01             	or     $0x1,%eax
 4007238:	88 45 d7             	mov    %al,-0x29(%rbp)
 400723b:	0f b6 45 d7          	movzbl -0x29(%rbp),%eax
 400723f:	83 c8 02             	or     $0x2,%eax
 4007242:	88 45 d7             	mov    %al,-0x29(%rbp)
 4007245:	0f b6 45 d7          	movzbl -0x29(%rbp),%eax
 4007249:	83 c8 04             	or     $0x4,%eax
 400724c:	88 45 d7             	mov    %al,-0x29(%rbp)
 400724f:	0f b6 45 d7          	movzbl -0x29(%rbp),%eax
 4007253:	83 e0 f7             	and    $0xfffffff7,%eax
 4007256:	88 45 d7             	mov    %al,-0x29(%rbp)
 4007259:	44 0f b6 45 d7       	movzbl -0x29(%rbp),%r8d
 400725e:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
 4007262:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
 4007266:	48 83 ec 08          	sub    $0x8,%rsp
 400726a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 400726e:	48 81 ec a8 00 00 00 	sub    $0xa8,%rsp
 4007275:	48 89 e2             	mov    %rsp,%rdx
 4007278:	48 8b 08             	mov    (%rax),%rcx
 400727b:	48 8b 58 08          	mov    0x8(%rax),%rbx
 400727f:	48 89 0a             	mov    %rcx,(%rdx)
 4007282:	48 89 5a 08          	mov    %rbx,0x8(%rdx)
 4007286:	48 8b 48 10          	mov    0x10(%rax),%rcx
 400728a:	48 8b 58 18          	mov    0x18(%rax),%rbx
 400728e:	48 89 4a 10          	mov    %rcx,0x10(%rdx)
 4007292:	48 89 5a 18          	mov    %rbx,0x18(%rdx)
 4007296:	48 8b 48 20          	mov    0x20(%rax),%rcx
 400729a:	48 8b 58 28          	mov    0x28(%rax),%rbx
 400729e:	48 89 4a 20          	mov    %rcx,0x20(%rdx)
 40072a2:	48 89 5a 28          	mov    %rbx,0x28(%rdx)
 40072a6:	48 8b 48 30          	mov    0x30(%rax),%rcx
 40072aa:	48 8b 58 38          	mov    0x38(%rax),%rbx
 40072ae:	48 89 4a 30          	mov    %rcx,0x30(%rdx)
 40072b2:	48 89 5a 38          	mov    %rbx,0x38(%rdx)
 40072b6:	48 8b 48 40          	mov    0x40(%rax),%rcx
 40072ba:	48 8b 58 48          	mov    0x48(%rax),%rbx
 40072be:	48 89 4a 40          	mov    %rcx,0x40(%rdx)
 40072c2:	48 89 5a 48          	mov    %rbx,0x48(%rdx)
 40072c6:	48 8b 48 50          	mov    0x50(%rax),%rcx
 40072ca:	48 8b 58 58          	mov    0x58(%rax),%rbx
 40072ce:	48 89 4a 50          	mov    %rcx,0x50(%rdx)
 40072d2:	48 89 5a 58          	mov    %rbx,0x58(%rdx)
 40072d6:	48 8b 48 60          	mov    0x60(%rax),%rcx
 40072da:	48 8b 58 68          	mov    0x68(%rax),%rbx
 40072de:	48 89 4a 60          	mov    %rcx,0x60(%rdx)
 40072e2:	48 89 5a 68          	mov    %rbx,0x68(%rdx)
 40072e6:	48 8b 48 70          	mov    0x70(%rax),%rcx
 40072ea:	48 8b 58 78          	mov    0x78(%rax),%rbx
 40072ee:	48 89 4a 70          	mov    %rcx,0x70(%rdx)
 40072f2:	48 89 5a 78          	mov    %rbx,0x78(%rdx)
 40072f6:	48 8b 88 80 00 00 00 	mov    0x80(%rax),%rcx
 40072fd:	48 8b 98 88 00 00 00 	mov    0x88(%rax),%rbx
 4007304:	48 89 8a 80 00 00 00 	mov    %rcx,0x80(%rdx)
 400730b:	48 89 9a 88 00 00 00 	mov    %rbx,0x88(%rdx)
 4007312:	48 8b 88 90 00 00 00 	mov    0x90(%rax),%rcx
 4007319:	48 8b 98 98 00 00 00 	mov    0x98(%rax),%rbx
 4007320:	48 89 8a 90 00 00 00 	mov    %rcx,0x90(%rdx)
 4007327:	48 89 9a 98 00 00 00 	mov    %rbx,0x98(%rdx)
 400732e:	48 8b 80 a0 00 00 00 	mov    0xa0(%rax),%rax
 4007335:	48 89 82 a0 00 00 00 	mov    %rax,0xa0(%rdx)
 400733c:	44 89 c1             	mov    %r8d,%ecx
 400733f:	ba 00 00 00 00       	mov    $0x0,%edx
 4007344:	e8 53 f7 ff ff       	call   4006a9c <KernelSpacePgsMemMgr::Inner_fixed_addr_manage(unsigned long, KernelSpacePgsMemMgr::phymem_pgs_queue, bool, KernelSpacePgsMemMgr::pgaccess)>
 4007349:	48 81 c4 b0 00 00 00 	add    $0xb0,%rsp
 4007350:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
 4007354:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
 4007358:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 400735c:	48 01 d0             	add    %rdx,%rax
 400735f:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
 4007363:	74 07                	je     400736c <KernelSpacePgsMemMgr::pgs_free(unsigned long, unsigned long)+0x202>
 4007365:	b8 13 10 00 00       	mov    $0x1013,%eax
 400736a:	eb 1b                	jmp    4007387 <KernelSpacePgsMemMgr::pgs_free(unsigned long, unsigned long)+0x21d>
 400736c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4007370:	48 85 c0             	test   %rax,%rax
 4007373:	74 0d                	je     4007382 <KernelSpacePgsMemMgr::pgs_free(unsigned long, unsigned long)+0x218>
 4007375:	be a8 00 00 00       	mov    $0xa8,%esi
 400737a:	48 89 c7             	mov    %rax,%rdi
 400737d:	e8 2c d3 ff ff       	call   40046ae <operator delete(void*, unsigned long)>
 4007382:	b8 00 00 00 00       	mov    $0x0,%eax
 4007387:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
 400738b:	c9                   	leave
 400738c:	c3                   	ret
 400738d:	90                   	nop

000000000400738e <KernelSpacePgsMemMgr::seg_to_queue(unsigned long, unsigned long)>:
 400738e:	55                   	push   %rbp
 400738f:	48 89 e5             	mov    %rsp,%rbp
 4007392:	53                   	push   %rbx
 4007393:	48 83 ec 58          	sub    $0x58,%rsp
 4007397:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
 400739b:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
 400739f:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
 40073a3:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
 40073a7:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
 40073ab:	48 01 d0             	add    %rdx,%rax
 40073ae:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
 40073b2:	ba 00 10 00 00       	mov    $0x1000,%edx
 40073b7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 40073bb:	48 01 d0             	add    %rdx,%rax
 40073be:	48 83 e8 01          	sub    $0x1,%rax
 40073c2:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
 40073c6:	b8 ff 0f 00 00       	mov    $0xfff,%eax
 40073cb:	48 f7 d0             	not    %rax
 40073ce:	48 21 45 d8          	and    %rax,-0x28(%rbp)
 40073d2:	bf a8 00 00 00       	mov    $0xa8,%edi
 40073d7:	e8 c3 d1 ff ff       	call   400459f <operator new(unsigned long)>
 40073dc:	48 89 c3             	mov    %rax,%rbx
 40073df:	48 89 df             	mov    %rbx,%rdi
 40073e2:	e8 d9 01 00 00       	call   40075c0 <KernelSpacePgsMemMgr::phymem_pgs_queue::phymem_pgs_queue()>
 40073e7:	48 89 5d d0          	mov    %rbx,-0x30(%rbp)
 40073eb:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
 40073f0:	75 0a                	jne    40073fc <KernelSpacePgsMemMgr::seg_to_queue(unsigned long, unsigned long)+0x6e>
 40073f2:	b8 00 00 00 00       	mov    $0x0,%eax
 40073f7:	e9 be 01 00 00       	jmp    40075ba <KernelSpacePgsMemMgr::seg_to_queue(unsigned long, unsigned long)+0x22c>
 40073fc:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
 4007400:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
 4007404:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%rbp)
 400740b:	e9 98 01 00 00       	jmp    40075a8 <KernelSpacePgsMemMgr::seg_to_queue(unsigned long, unsigned long)+0x21a>
 4007410:	c7 45 e4 02 00 00 00 	movl   $0x2,-0x1c(%rbp)
 4007417:	eb 4e                	jmp    4007467 <KernelSpacePgsMemMgr::seg_to_queue(unsigned long, unsigned long)+0xd9>
 4007419:	8b 45 e4             	mov    -0x1c(%rbp),%eax
 400741c:	48 98                	cltq
 400741e:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
 4007425:	00 
 4007426:	48 8d 05 13 94 00 00 	lea    0x9413(%rip),%rax        # 4010840 <PAGE_OFFSET_MASK>
 400742d:	48 8b 04 02          	mov    (%rdx,%rax,1),%rax
 4007431:	48 23 45 e8          	and    -0x18(%rbp),%rax
 4007435:	48 85 c0             	test   %rax,%rax
 4007438:	75 29                	jne    4007463 <KernelSpacePgsMemMgr::seg_to_queue(unsigned long, unsigned long)+0xd5>
 400743a:	8b 45 e4             	mov    -0x1c(%rbp),%eax
 400743d:	48 98                	cltq
 400743f:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
 4007446:	00 
 4007447:	48 8d 05 b2 93 00 00 	lea    0x93b2(%rip),%rax        # 4010800 <PAGE_SIZE_IN_LV>
 400744e:	48 8b 14 02          	mov    (%rdx,%rax,1),%rdx
 4007452:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4007456:	48 01 d0             	add    %rdx,%rax
 4007459:	48 83 e8 01          	sub    $0x1,%rax
 400745d:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
 4007461:	73 0c                	jae    400746f <KernelSpacePgsMemMgr::seg_to_queue(unsigned long, unsigned long)+0xe1>
 4007463:	83 6d e4 01          	subl   $0x1,-0x1c(%rbp)
 4007467:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
 400746b:	79 ac                	jns    4007419 <KernelSpacePgsMemMgr::seg_to_queue(unsigned long, unsigned long)+0x8b>
 400746d:	eb 01                	jmp    4007470 <KernelSpacePgsMemMgr::seg_to_queue(unsigned long, unsigned long)+0xe2>
 400746f:	90                   	nop
 4007470:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
 4007474:	79 20                	jns    4007496 <KernelSpacePgsMemMgr::seg_to_queue(unsigned long, unsigned long)+0x108>
 4007476:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
 400747a:	48 85 c0             	test   %rax,%rax
 400747d:	74 0d                	je     400748c <KernelSpacePgsMemMgr::seg_to_queue(unsigned long, unsigned long)+0xfe>
 400747f:	be a8 00 00 00       	mov    $0xa8,%esi
 4007484:	48 89 c7             	mov    %rax,%rdi
 4007487:	e8 22 d2 ff ff       	call   40046ae <operator delete(void*, unsigned long)>
 400748c:	b8 00 00 00 00       	mov    $0x0,%eax
 4007491:	e9 24 01 00 00       	jmp    40075ba <KernelSpacePgsMemMgr::seg_to_queue(unsigned long, unsigned long)+0x22c>
 4007496:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
 400749a:	0f b6 00             	movzbl (%rax),%eax
 400749d:	84 c0                	test   %al,%al
 400749f:	74 2e                	je     40074cf <KernelSpacePgsMemMgr::seg_to_queue(unsigned long, unsigned long)+0x141>
 40074a1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
 40074a5:	0f b6 00             	movzbl (%rax),%eax
 40074a8:	0f b6 c0             	movzbl %al,%eax
 40074ab:	8d 50 ff             	lea    -0x1(%rax),%edx
 40074ae:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
 40074b2:	48 63 d2             	movslq %edx,%rdx
 40074b5:	48 c1 e2 04          	shl    $0x4,%rdx
 40074b9:	48 01 d0             	add    %rdx,%rax
 40074bc:	48 83 c0 10          	add    $0x10,%rax
 40074c0:	0f b6 00             	movzbl (%rax),%eax
 40074c3:	0f b6 c0             	movzbl %al,%eax
 40074c6:	39 45 e4             	cmp    %eax,-0x1c(%rbp)
 40074c9:	0f 84 83 00 00 00    	je     4007552 <KernelSpacePgsMemMgr::seg_to_queue(unsigned long, unsigned long)+0x1c4>
 40074cf:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
 40074d3:	0f b6 00             	movzbl (%rax),%eax
 40074d6:	3c 09                	cmp    $0x9,%al
 40074d8:	76 20                	jbe    40074fa <KernelSpacePgsMemMgr::seg_to_queue(unsigned long, unsigned long)+0x16c>
 40074da:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
 40074de:	48 85 c0             	test   %rax,%rax
 40074e1:	74 0d                	je     40074f0 <KernelSpacePgsMemMgr::seg_to_queue(unsigned long, unsigned long)+0x162>
 40074e3:	be a8 00 00 00       	mov    $0xa8,%esi
 40074e8:	48 89 c7             	mov    %rax,%rdi
 40074eb:	e8 be d1 ff ff       	call   40046ae <operator delete(void*, unsigned long)>
 40074f0:	b8 00 00 00 00       	mov    $0x0,%eax
 40074f5:	e9 c0 00 00 00       	jmp    40075ba <KernelSpacePgsMemMgr::seg_to_queue(unsigned long, unsigned long)+0x22c>
 40074fa:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
 40074fe:	0f b6 00             	movzbl (%rax),%eax
 4007501:	0f b6 d0             	movzbl %al,%edx
 4007504:	8b 45 e4             	mov    -0x1c(%rbp),%eax
 4007507:	89 c1                	mov    %eax,%ecx
 4007509:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
 400750d:	48 63 d2             	movslq %edx,%rdx
 4007510:	48 c1 e2 04          	shl    $0x4,%rdx
 4007514:	48 01 d0             	add    %rdx,%rax
 4007517:	48 83 c0 10          	add    $0x10,%rax
 400751b:	88 08                	mov    %cl,(%rax)
 400751d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
 4007521:	0f b6 00             	movzbl (%rax),%eax
 4007524:	0f b6 d0             	movzbl %al,%edx
 4007527:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
 400752b:	48 63 d2             	movslq %edx,%rdx
 400752e:	48 c1 e2 04          	shl    $0x4,%rdx
 4007532:	48 01 d0             	add    %rdx,%rax
 4007535:	48 83 c0 08          	add    $0x8,%rax
 4007539:	48 c7 00 01 00 00 00 	movq   $0x1,(%rax)
 4007540:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
 4007544:	0f b6 00             	movzbl (%rax),%eax
 4007547:	8d 50 01             	lea    0x1(%rax),%edx
 400754a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
 400754e:	88 10                	mov    %dl,(%rax)
 4007550:	eb 3a                	jmp    400758c <KernelSpacePgsMemMgr::seg_to_queue(unsigned long, unsigned long)+0x1fe>
 4007552:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
 4007556:	0f b6 00             	movzbl (%rax),%eax
 4007559:	0f b6 c0             	movzbl %al,%eax
 400755c:	83 e8 01             	sub    $0x1,%eax
 400755f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
 4007563:	48 63 c8             	movslq %eax,%rcx
 4007566:	48 c1 e1 04          	shl    $0x4,%rcx
 400756a:	48 01 ca             	add    %rcx,%rdx
 400756d:	48 83 c2 08          	add    $0x8,%rdx
 4007571:	48 8b 12             	mov    (%rdx),%rdx
 4007574:	48 83 c2 01          	add    $0x1,%rdx
 4007578:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
 400757c:	48 98                	cltq
 400757e:	48 c1 e0 04          	shl    $0x4,%rax
 4007582:	48 01 c8             	add    %rcx,%rax
 4007585:	48 83 c0 08          	add    $0x8,%rax
 4007589:	48 89 10             	mov    %rdx,(%rax)
 400758c:	8b 45 e4             	mov    -0x1c(%rbp),%eax
 400758f:	48 98                	cltq
 4007591:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
 4007598:	00 
 4007599:	48 8d 05 60 92 00 00 	lea    0x9260(%rip),%rax        # 4010800 <PAGE_SIZE_IN_LV>
 40075a0:	48 8b 04 02          	mov    (%rdx,%rax,1),%rax
 40075a4:	48 01 45 e8          	add    %rax,-0x18(%rbp)
 40075a8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 40075ac:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
 40075b0:	0f 82 5a fe ff ff    	jb     4007410 <KernelSpacePgsMemMgr::seg_to_queue(unsigned long, unsigned long)+0x82>
 40075b6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
 40075ba:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
 40075be:	c9                   	leave
 40075bf:	c3                   	ret

00000000040075c0 <KernelSpacePgsMemMgr::phymem_pgs_queue::phymem_pgs_queue()>:
 */
{
    uint8_t entry_count=0;
    pgs_queue_entry_t entry[10]={0};//最极端的情况是4kb,2mb,1gb,512gb,256tb,512gb,1gb,2mb,4kb
};

 40075c0:	55                   	push   %rbp
 40075c1:	48 89 e5             	mov    %rsp,%rbp
 40075c4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
 40075c8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 40075cc:	c6 00 00             	movb   $0x0,(%rax)
 40075cf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 40075d3:	48 8d 50 08          	lea    0x8(%rax),%rdx
 40075d7:	b8 00 00 00 00       	mov    $0x0,%eax
 40075dc:	b9 14 00 00 00       	mov    $0x14,%ecx
 40075e1:	48 89 d7             	mov    %rdx,%rdi
 40075e4:	f3 48 ab             	rep stos %rax,(%rdi)
 40075e7:	90                   	nop
 40075e8:	5d                   	pop    %rbp
 40075e9:	c3                   	ret

00000000040075ea <KernelSpacePgsMemMgr::PgCBtb_lv4_entry_query(unsigned long)>:
#include "OS_utils.h"
#include "DoubleLinkList.h"
PgControlBlockHeader NullPgCBHeader_prototype = {0};
PgControlBlockHeader&NullPgCBHeader= NullPgCBHeader_prototype;
// LV4查询（顶级节点，无父级位图处理）
PgControlBlockHeader&KernelSpacePgsMemMgr::PgCBtb_lv4_entry_query(phyaddr_t addr) {
 40075ea:	55                   	push   %rbp
 40075eb:	48 89 e5             	mov    %rsp,%rbp
 40075ee:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
 40075f2:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
    uint64_t lv4_index = (addr & PML5_INDEX_MASK_lv4) >> 48;
 40075f6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 40075fa:	48 c1 e8 30          	shr    $0x30,%rax
 40075fe:	25 ff 01 00 00       	and    $0x1ff,%eax
 4007603:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    return gKspacePgsMemMgr.rootlv4PgCBtb[lv4_index];
 4007607:	48 8b 05 12 5b 80 00 	mov    0x805b12(%rip),%rax        # 480d120 <gKspacePgsMemMgr+0x1020>
 400760e:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
 4007612:	48 c1 e2 04          	shl    $0x4,%rdx
 4007616:	48 01 d0             	add    %rdx,%rax
}
 4007619:	5d                   	pop    %rbp
 400761a:	c3                   	ret
 400761b:	90                   	nop

000000000400761c <KernelSpacePgsMemMgr::PgCBtb_lv3_entry_query(unsigned long)>:

// LV3查询（需处理LV4父级的位图存储）
PgControlBlockHeader&KernelSpacePgsMemMgr::PgCBtb_lv3_entry_query(phyaddr_t addr) {
 400761c:	55                   	push   %rbp
 400761d:	48 89 e5             	mov    %rsp,%rbp
 4007620:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
 4007624:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
    
    uint16_t lv3_index = (addr & PML4_INDEX_MASK_lv3) >> 39;
 4007628:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
 400762c:	48 c1 e8 27          	shr    $0x27,%rax
 4007630:	66 25 ff 01          	and    $0x1ff,%ax
 4007634:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
    uint64_t lv4_index = (addr & PML5_INDEX_MASK_lv4) >> 48;
 4007638:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
 400763c:	48 c1 e8 30          	shr    $0x30,%rax
 4007640:	25 ff 01 00 00       	and    $0x1ff,%eax
 4007645:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

    PgCBlv4header* lv4_PgCBHeader = gKspacePgsMemMgr.cpu_pglv == 5 ? 
 4007649:	0f b6 05 b0 4a 80 00 	movzbl 0x804ab0(%rip),%eax        # 480c100 <gKspacePgsMemMgr>
 4007650:	3c 05                	cmp    $0x5,%al
 4007652:	75 18                	jne    400766c <KernelSpacePgsMemMgr::PgCBtb_lv3_entry_query(unsigned long)+0x50>
                                    &gKspacePgsMemMgr.rootlv4PgCBtb[lv4_index] : 
 4007654:	48 8b 05 c5 5a 80 00 	mov    0x805ac5(%rip),%rax        # 480d120 <gKspacePgsMemMgr+0x1020>
 400765b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
 400765f:	48 c1 e2 04          	shl    $0x4,%rdx
    PgCBlv4header* lv4_PgCBHeader = gKspacePgsMemMgr.cpu_pglv == 5 ? 
 4007663:	48 01 d0             	add    %rdx,%rax
 4007666:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
 400766a:	eb 0b                	jmp    4007677 <KernelSpacePgsMemMgr::PgCBtb_lv3_entry_query(unsigned long)+0x5b>
 400766c:	48 8b 05 ad 5a 80 00 	mov    0x805aad(%rip),%rax        # 480d120 <gKspacePgsMemMgr+0x1020>
 4007673:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
                                    gKspacePgsMemMgr.rootlv4PgCBtb;
    if (lv4_PgCBHeader->flags.is_exist == 0||lv4_PgCBHeader->flags.is_atom==1) {
 4007677:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 400767b:	0f b6 00             	movzbl (%rax),%eax
 400767e:	83 e0 02             	and    $0x2,%eax
 4007681:	84 c0                	test   %al,%al
 4007683:	74 0e                	je     4007693 <KernelSpacePgsMemMgr::PgCBtb_lv3_entry_query(unsigned long)+0x77>
 4007685:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4007689:	0f b6 00             	movzbl (%rax),%eax
 400768c:	83 e0 04             	and    $0x4,%eax
 400768f:	84 c0                	test   %al,%al
 4007691:	74 09                	je     400769c <KernelSpacePgsMemMgr::PgCBtb_lv3_entry_query(unsigned long)+0x80>
        return NullPgCBHeader;
 4007693:	48 8d 05 36 5b 80 00 	lea    0x805b36(%rip),%rax        # 480d1d0 <NullPgCBHeader_prototype>
 400769a:	eb 1a                	jmp    40076b6 <KernelSpacePgsMemMgr::PgCBtb_lv3_entry_query(unsigned long)+0x9a>
    }


        return lv4_PgCBHeader->base.lowerlvPgCBtb->entries[lv3_index];
 400769c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 40076a0:	48 8b 40 08          	mov    0x8(%rax),%rax
 40076a4:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
 40076a8:	48 63 d2             	movslq %edx,%rdx
 40076ab:	48 c1 e2 04          	shl    $0x4,%rdx
 40076af:	48 01 d0             	add    %rdx,%rax
 40076b2:	48 83 c0 08          	add    $0x8,%rax
    
}
 40076b6:	5d                   	pop    %rbp
 40076b7:	c3                   	ret

00000000040076b8 <KernelSpacePgsMemMgr::PgCBtb_lv2_entry_query(unsigned long)>:

// LV2查询（需处理LV3父级的位图存储）
PgControlBlockHeader&KernelSpacePgsMemMgr::PgCBtb_lv2_entry_query(phyaddr_t addr) {
 40076b8:	55                   	push   %rbp
 40076b9:	48 89 e5             	mov    %rsp,%rbp
 40076bc:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
 40076c0:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)

    uint16_t lv2_index = (addr & PDPT_INDEX_MASK_lv2) >> 30;
 40076c4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
 40076c8:	48 c1 e8 1e          	shr    $0x1e,%rax
 40076cc:	66 25 ff 01          	and    $0x1ff,%ax
 40076d0:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
    uint16_t lv3_index = (addr & PML4_INDEX_MASK_lv3) >> 39;
 40076d4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
 40076d8:	48 c1 e8 27          	shr    $0x27,%rax
 40076dc:	66 25 ff 01          	and    $0x1ff,%ax
 40076e0:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
    uint64_t lv4_index = (addr & PML5_INDEX_MASK_lv4) >> 48;
 40076e4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
 40076e8:	48 c1 e8 30          	shr    $0x30,%rax
 40076ec:	25 ff 01 00 00       	and    $0x1ff,%eax
 40076f1:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

    PgCBlv4header* lv4_PgCBHeader = gKspacePgsMemMgr.cpu_pglv == 5 ? 
 40076f5:	0f b6 05 04 4a 80 00 	movzbl 0x804a04(%rip),%eax        # 480c100 <gKspacePgsMemMgr>
 40076fc:	3c 05                	cmp    $0x5,%al
 40076fe:	75 18                	jne    4007718 <KernelSpacePgsMemMgr::PgCBtb_lv2_entry_query(unsigned long)+0x60>
                                    &gKspacePgsMemMgr.rootlv4PgCBtb[lv4_index] : 
 4007700:	48 8b 05 19 5a 80 00 	mov    0x805a19(%rip),%rax        # 480d120 <gKspacePgsMemMgr+0x1020>
 4007707:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
 400770b:	48 c1 e2 04          	shl    $0x4,%rdx
    PgCBlv4header* lv4_PgCBHeader = gKspacePgsMemMgr.cpu_pglv == 5 ? 
 400770f:	48 01 d0             	add    %rdx,%rax
 4007712:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
 4007716:	eb 0b                	jmp    4007723 <KernelSpacePgsMemMgr::PgCBtb_lv2_entry_query(unsigned long)+0x6b>
 4007718:	48 8b 05 01 5a 80 00 	mov    0x805a01(%rip),%rax        # 480d120 <gKspacePgsMemMgr+0x1020>
 400771f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
                                    gKspacePgsMemMgr.rootlv4PgCBtb;
    if (lv4_PgCBHeader->flags.is_exist == 0||lv4_PgCBHeader->flags.is_atom==1) {
 4007723:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4007727:	0f b6 00             	movzbl (%rax),%eax
 400772a:	83 e0 02             	and    $0x2,%eax
 400772d:	84 c0                	test   %al,%al
 400772f:	74 0e                	je     400773f <KernelSpacePgsMemMgr::PgCBtb_lv2_entry_query(unsigned long)+0x87>
 4007731:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4007735:	0f b6 00             	movzbl (%rax),%eax
 4007738:	83 e0 04             	and    $0x4,%eax
 400773b:	84 c0                	test   %al,%al
 400773d:	74 09                	je     4007748 <KernelSpacePgsMemMgr::PgCBtb_lv2_entry_query(unsigned long)+0x90>
        return NullPgCBHeader;
 400773f:	48 8d 05 8a 5a 80 00 	lea    0x805a8a(%rip),%rax        # 480d1d0 <NullPgCBHeader_prototype>
 4007746:	eb 5b                	jmp    40077a3 <KernelSpacePgsMemMgr::PgCBtb_lv2_entry_query(unsigned long)+0xeb>
    }

    // 获取LV3节点（处理LV4的位图存储）
    PgControlBlockHeader lv3_header = lv4_PgCBHeader->base.lowerlvPgCBtb->entries[lv3_index];
 4007748:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 400774c:	48 8b 40 08          	mov    0x8(%rax),%rax
 4007750:	0f b7 55 f4          	movzwl -0xc(%rbp),%edx
 4007754:	48 63 d2             	movslq %edx,%rdx
 4007757:	48 c1 e2 04          	shl    $0x4,%rdx
 400775b:	48 01 d0             	add    %rdx,%rax
 400775e:	48 8b 50 10          	mov    0x10(%rax),%rdx
 4007762:	48 8b 40 08          	mov    0x8(%rax),%rax
 4007766:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
 400776a:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
    if (lv3_header.flags.is_exist == 0||lv3_header.flags.is_atom==1) {
 400776e:	0f b6 45 d0          	movzbl -0x30(%rbp),%eax
 4007772:	83 e0 02             	and    $0x2,%eax
 4007775:	84 c0                	test   %al,%al
 4007777:	74 0b                	je     4007784 <KernelSpacePgsMemMgr::PgCBtb_lv2_entry_query(unsigned long)+0xcc>
 4007779:	0f b6 45 d0          	movzbl -0x30(%rbp),%eax
 400777d:	83 e0 04             	and    $0x4,%eax
 4007780:	84 c0                	test   %al,%al
 4007782:	74 09                	je     400778d <KernelSpacePgsMemMgr::PgCBtb_lv2_entry_query(unsigned long)+0xd5>
        return NullPgCBHeader;
 4007784:	48 8d 05 45 5a 80 00 	lea    0x805a45(%rip),%rax        # 480d1d0 <NullPgCBHeader_prototype>
 400778b:	eb 16                	jmp    40077a3 <KernelSpacePgsMemMgr::PgCBtb_lv2_entry_query(unsigned long)+0xeb>
    }


        return lv3_header.base.lowerlvPgCBtb->entries[lv2_index];
 400778d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4007791:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
 4007795:	48 63 d2             	movslq %edx,%rdx
 4007798:	48 c1 e2 04          	shl    $0x4,%rdx
 400779c:	48 01 d0             	add    %rdx,%rax
 400779f:	48 83 c0 08          	add    $0x8,%rax
}
 40077a3:	5d                   	pop    %rbp
 40077a4:	c3                   	ret
 40077a5:	90                   	nop

00000000040077a6 <KernelSpacePgsMemMgr::PgCBtb_lv1_entry_query(unsigned long)>:

// LV1查询（需处理LV2父级的位图存储）
PgControlBlockHeader&KernelSpacePgsMemMgr::PgCBtb_lv1_entry_query(phyaddr_t addr) {
 40077a6:	55                   	push   %rbp
 40077a7:	48 89 e5             	mov    %rsp,%rbp
 40077aa:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
 40077ae:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)

    uint16_t lv1_index = (addr & PD_INDEX_MASK_lv1) >> 21;
 40077b2:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
 40077b6:	48 c1 e8 15          	shr    $0x15,%rax
 40077ba:	66 25 ff 01          	and    $0x1ff,%ax
 40077be:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
    uint16_t lv2_index = (addr & PDPT_INDEX_MASK_lv2) >> 30;
 40077c2:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
 40077c6:	48 c1 e8 1e          	shr    $0x1e,%rax
 40077ca:	66 25 ff 01          	and    $0x1ff,%ax
 40077ce:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
    uint16_t lv3_index = (addr & PML4_INDEX_MASK_lv3) >> 39;
 40077d2:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
 40077d6:	48 c1 e8 27          	shr    $0x27,%rax
 40077da:	66 25 ff 01          	and    $0x1ff,%ax
 40077de:	66 89 45 f2          	mov    %ax,-0xe(%rbp)
    uint64_t lv4_index = (addr & PML5_INDEX_MASK_lv4) >> 48;
 40077e2:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
 40077e6:	48 c1 e8 30          	shr    $0x30,%rax
 40077ea:	25 ff 01 00 00       	and    $0x1ff,%eax
 40077ef:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

    PgCBlv4header* lv4_PgCBHeader = gKspacePgsMemMgr.cpu_pglv == 5 ? 
 40077f3:	0f b6 05 06 49 80 00 	movzbl 0x804906(%rip),%eax        # 480c100 <gKspacePgsMemMgr>
 40077fa:	3c 05                	cmp    $0x5,%al
 40077fc:	75 18                	jne    4007816 <KernelSpacePgsMemMgr::PgCBtb_lv1_entry_query(unsigned long)+0x70>
                                    &gKspacePgsMemMgr.rootlv4PgCBtb[lv4_index] : 
 40077fe:	48 8b 05 1b 59 80 00 	mov    0x80591b(%rip),%rax        # 480d120 <gKspacePgsMemMgr+0x1020>
 4007805:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
 4007809:	48 c1 e2 04          	shl    $0x4,%rdx
    PgCBlv4header* lv4_PgCBHeader = gKspacePgsMemMgr.cpu_pglv == 5 ? 
 400780d:	48 01 d0             	add    %rdx,%rax
 4007810:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
 4007814:	eb 0b                	jmp    4007821 <KernelSpacePgsMemMgr::PgCBtb_lv1_entry_query(unsigned long)+0x7b>
 4007816:	48 8b 05 03 59 80 00 	mov    0x805903(%rip),%rax        # 480d120 <gKspacePgsMemMgr+0x1020>
 400781d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
                                    gKspacePgsMemMgr.rootlv4PgCBtb;
    if (lv4_PgCBHeader->flags.is_exist == 0||lv4_PgCBHeader->flags.is_atom==1) {
 4007821:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4007825:	0f b6 00             	movzbl (%rax),%eax
 4007828:	83 e0 02             	and    $0x2,%eax
 400782b:	84 c0                	test   %al,%al
 400782d:	74 0e                	je     400783d <KernelSpacePgsMemMgr::PgCBtb_lv1_entry_query(unsigned long)+0x97>
 400782f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4007833:	0f b6 00             	movzbl (%rax),%eax
 4007836:	83 e0 04             	and    $0x4,%eax
 4007839:	84 c0                	test   %al,%al
 400783b:	74 0c                	je     4007849 <KernelSpacePgsMemMgr::PgCBtb_lv1_entry_query(unsigned long)+0xa3>
        return NullPgCBHeader;
 400783d:	48 8d 05 8c 59 80 00 	lea    0x80598c(%rip),%rax        # 480d1d0 <NullPgCBHeader_prototype>
 4007844:	e9 9c 00 00 00       	jmp    40078e5 <KernelSpacePgsMemMgr::PgCBtb_lv1_entry_query(unsigned long)+0x13f>
    }

    // 获取LV3节点（处理LV4的位图存储）
    PgControlBlockHeader lv3_header = lv4_PgCBHeader->base.lowerlvPgCBtb->entries[lv3_index];
 4007849:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 400784d:	48 8b 40 08          	mov    0x8(%rax),%rax
 4007851:	0f b7 55 f2          	movzwl -0xe(%rbp),%edx
 4007855:	48 63 d2             	movslq %edx,%rdx
 4007858:	48 c1 e2 04          	shl    $0x4,%rdx
 400785c:	48 01 d0             	add    %rdx,%rax
 400785f:	48 8b 50 10          	mov    0x10(%rax),%rdx
 4007863:	48 8b 40 08          	mov    0x8(%rax),%rax
 4007867:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
 400786b:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
    if (lv3_header.flags.is_exist == 0||lv3_header.flags.is_atom==1) {
 400786f:	0f b6 45 d0          	movzbl -0x30(%rbp),%eax
 4007873:	83 e0 02             	and    $0x2,%eax
 4007876:	84 c0                	test   %al,%al
 4007878:	74 0b                	je     4007885 <KernelSpacePgsMemMgr::PgCBtb_lv1_entry_query(unsigned long)+0xdf>
 400787a:	0f b6 45 d0          	movzbl -0x30(%rbp),%eax
 400787e:	83 e0 04             	and    $0x4,%eax
 4007881:	84 c0                	test   %al,%al
 4007883:	74 09                	je     400788e <KernelSpacePgsMemMgr::PgCBtb_lv1_entry_query(unsigned long)+0xe8>
        return NullPgCBHeader;
 4007885:	48 8d 05 44 59 80 00 	lea    0x805944(%rip),%rax        # 480d1d0 <NullPgCBHeader_prototype>
 400788c:	eb 57                	jmp    40078e5 <KernelSpacePgsMemMgr::PgCBtb_lv1_entry_query(unsigned long)+0x13f>
    }

    // 获取LV2节点（处理LV3的位图存储）
    PgControlBlockHeader lv2_header = lv3_header.base.lowerlvPgCBtb->entries[lv2_index];
 400788e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4007892:	0f b7 55 f4          	movzwl -0xc(%rbp),%edx
 4007896:	48 63 d2             	movslq %edx,%rdx
 4007899:	48 c1 e2 04          	shl    $0x4,%rdx
 400789d:	48 01 d0             	add    %rdx,%rax
 40078a0:	48 8b 50 10          	mov    0x10(%rax),%rdx
 40078a4:	48 8b 40 08          	mov    0x8(%rax),%rax
 40078a8:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
 40078ac:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
    if (lv2_header.flags.is_exist == 0||lv2_header.flags.is_atom==1) {
 40078b0:	0f b6 45 c0          	movzbl -0x40(%rbp),%eax
 40078b4:	83 e0 02             	and    $0x2,%eax
 40078b7:	84 c0                	test   %al,%al
 40078b9:	74 0b                	je     40078c6 <KernelSpacePgsMemMgr::PgCBtb_lv1_entry_query(unsigned long)+0x120>
 40078bb:	0f b6 45 c0          	movzbl -0x40(%rbp),%eax
 40078bf:	83 e0 04             	and    $0x4,%eax
 40078c2:	84 c0                	test   %al,%al
 40078c4:	74 09                	je     40078cf <KernelSpacePgsMemMgr::PgCBtb_lv1_entry_query(unsigned long)+0x129>
        return NullPgCBHeader;
 40078c6:	48 8d 05 03 59 80 00 	lea    0x805903(%rip),%rax        # 480d1d0 <NullPgCBHeader_prototype>
 40078cd:	eb 16                	jmp    40078e5 <KernelSpacePgsMemMgr::PgCBtb_lv1_entry_query(unsigned long)+0x13f>
    }


        return lv2_header.base.lowerlvPgCBtb->entries[lv1_index];
 40078cf:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 40078d3:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
 40078d7:	48 63 d2             	movslq %edx,%rdx
 40078da:	48 c1 e2 04          	shl    $0x4,%rdx
 40078de:	48 01 d0             	add    %rdx,%rax
 40078e1:	48 83 c0 08          	add    $0x8,%rax
    
}
 40078e5:	5d                   	pop    %rbp
 40078e6:	c3                   	ret
 40078e7:	90                   	nop

00000000040078e8 <KernelSpacePgsMemMgr::PgCBtb_lv0_entry_query(unsigned long)>:

// LV0查询（需处理LV1父级的位图存储）
PgControlBlockHeader&KernelSpacePgsMemMgr::PgCBtb_lv0_entry_query(phyaddr_t addr) {
 40078e8:	55                   	push   %rbp
 40078e9:	48 89 e5             	mov    %rsp,%rbp
 40078ec:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
 40078f0:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)

    uint16_t lv0_index = (addr & PT_INDEX_MASK_lv0) >> 12;
 40078f4:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
 40078f8:	48 c1 e8 0c          	shr    $0xc,%rax
 40078fc:	66 25 ff 01          	and    $0x1ff,%ax
 4007900:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
    uint16_t lv1_index = (addr & PD_INDEX_MASK_lv1) >> 21;
 4007904:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
 4007908:	48 c1 e8 15          	shr    $0x15,%rax
 400790c:	66 25 ff 01          	and    $0x1ff,%ax
 4007910:	66 89 45 f4          	mov    %ax,-0xc(%rbp)
    uint16_t lv2_index = (addr & PDPT_INDEX_MASK_lv2) >> 30;
 4007914:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
 4007918:	48 c1 e8 1e          	shr    $0x1e,%rax
 400791c:	66 25 ff 01          	and    $0x1ff,%ax
 4007920:	66 89 45 f2          	mov    %ax,-0xe(%rbp)
    uint16_t lv3_index = (addr & PML4_INDEX_MASK_lv3) >> 39;
 4007924:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
 4007928:	48 c1 e8 27          	shr    $0x27,%rax
 400792c:	66 25 ff 01          	and    $0x1ff,%ax
 4007930:	66 89 45 f0          	mov    %ax,-0x10(%rbp)
    uint64_t lv4_index = (addr & PML5_INDEX_MASK_lv4) >> 48;
 4007934:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
 4007938:	48 c1 e8 30          	shr    $0x30,%rax
 400793c:	25 ff 01 00 00       	and    $0x1ff,%eax
 4007941:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

    PgCBlv4header* lv4_PgCBHeader = gKspacePgsMemMgr.cpu_pglv == 5 ? 
 4007945:	0f b6 05 b4 47 80 00 	movzbl 0x8047b4(%rip),%eax        # 480c100 <gKspacePgsMemMgr>
 400794c:	3c 05                	cmp    $0x5,%al
 400794e:	75 18                	jne    4007968 <KernelSpacePgsMemMgr::PgCBtb_lv0_entry_query(unsigned long)+0x80>
                                    &gKspacePgsMemMgr.rootlv4PgCBtb[lv4_index] : 
 4007950:	48 8b 05 c9 57 80 00 	mov    0x8057c9(%rip),%rax        # 480d120 <gKspacePgsMemMgr+0x1020>
 4007957:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
 400795b:	48 c1 e2 04          	shl    $0x4,%rdx
    PgCBlv4header* lv4_PgCBHeader = gKspacePgsMemMgr.cpu_pglv == 5 ? 
 400795f:	48 01 d0             	add    %rdx,%rax
 4007962:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
 4007966:	eb 0b                	jmp    4007973 <KernelSpacePgsMemMgr::PgCBtb_lv0_entry_query(unsigned long)+0x8b>
 4007968:	48 8b 05 b1 57 80 00 	mov    0x8057b1(%rip),%rax        # 480d120 <gKspacePgsMemMgr+0x1020>
 400796f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
                                    gKspacePgsMemMgr.rootlv4PgCBtb;
    if (lv4_PgCBHeader->flags.is_exist == 0||lv4_PgCBHeader->flags.is_atom==1) {
 4007973:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4007977:	0f b6 00             	movzbl (%rax),%eax
 400797a:	83 e0 02             	and    $0x2,%eax
 400797d:	84 c0                	test   %al,%al
 400797f:	74 0e                	je     400798f <KernelSpacePgsMemMgr::PgCBtb_lv0_entry_query(unsigned long)+0xa7>
 4007981:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4007985:	0f b6 00             	movzbl (%rax),%eax
 4007988:	83 e0 04             	and    $0x4,%eax
 400798b:	84 c0                	test   %al,%al
 400798d:	74 0c                	je     400799b <KernelSpacePgsMemMgr::PgCBtb_lv0_entry_query(unsigned long)+0xb3>
        return NullPgCBHeader;
 400798f:	48 8d 05 3a 58 80 00 	lea    0x80583a(%rip),%rax        # 480d1d0 <NullPgCBHeader_prototype>
 4007996:	e9 e0 00 00 00       	jmp    4007a7b <KernelSpacePgsMemMgr::PgCBtb_lv0_entry_query(unsigned long)+0x193>
    }

    // 获取LV3节点（处理LV4的位图存储）
    PgControlBlockHeader lv3_header = lv4_PgCBHeader->base.lowerlvPgCBtb->entries[lv3_index];
 400799b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 400799f:	48 8b 40 08          	mov    0x8(%rax),%rax
 40079a3:	0f b7 55 f0          	movzwl -0x10(%rbp),%edx
 40079a7:	48 63 d2             	movslq %edx,%rdx
 40079aa:	48 c1 e2 04          	shl    $0x4,%rdx
 40079ae:	48 01 d0             	add    %rdx,%rax
 40079b1:	48 8b 50 10          	mov    0x10(%rax),%rdx
 40079b5:	48 8b 40 08          	mov    0x8(%rax),%rax
 40079b9:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
 40079bd:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
    if (lv3_header.flags.is_exist == 0||lv3_header.flags.is_atom==1) {
 40079c1:	0f b6 45 d0          	movzbl -0x30(%rbp),%eax
 40079c5:	83 e0 02             	and    $0x2,%eax
 40079c8:	84 c0                	test   %al,%al
 40079ca:	74 0b                	je     40079d7 <KernelSpacePgsMemMgr::PgCBtb_lv0_entry_query(unsigned long)+0xef>
 40079cc:	0f b6 45 d0          	movzbl -0x30(%rbp),%eax
 40079d0:	83 e0 04             	and    $0x4,%eax
 40079d3:	84 c0                	test   %al,%al
 40079d5:	74 0c                	je     40079e3 <KernelSpacePgsMemMgr::PgCBtb_lv0_entry_query(unsigned long)+0xfb>
        return NullPgCBHeader;
 40079d7:	48 8d 05 f2 57 80 00 	lea    0x8057f2(%rip),%rax        # 480d1d0 <NullPgCBHeader_prototype>
 40079de:	e9 98 00 00 00       	jmp    4007a7b <KernelSpacePgsMemMgr::PgCBtb_lv0_entry_query(unsigned long)+0x193>
    }

    // 获取LV2节点（处理LV3的位图存储）
    PgControlBlockHeader lv2_header = lv3_header.base.lowerlvPgCBtb->entries[lv2_index];
 40079e3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 40079e7:	0f b7 55 f2          	movzwl -0xe(%rbp),%edx
 40079eb:	48 63 d2             	movslq %edx,%rdx
 40079ee:	48 c1 e2 04          	shl    $0x4,%rdx
 40079f2:	48 01 d0             	add    %rdx,%rax
 40079f5:	48 8b 50 10          	mov    0x10(%rax),%rdx
 40079f9:	48 8b 40 08          	mov    0x8(%rax),%rax
 40079fd:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
 4007a01:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
    if (lv2_header.flags.is_exist == 0||lv2_header.flags.is_atom==1) {
 4007a05:	0f b6 45 c0          	movzbl -0x40(%rbp),%eax
 4007a09:	83 e0 02             	and    $0x2,%eax
 4007a0c:	84 c0                	test   %al,%al
 4007a0e:	74 0b                	je     4007a1b <KernelSpacePgsMemMgr::PgCBtb_lv0_entry_query(unsigned long)+0x133>
 4007a10:	0f b6 45 c0          	movzbl -0x40(%rbp),%eax
 4007a14:	83 e0 04             	and    $0x4,%eax
 4007a17:	84 c0                	test   %al,%al
 4007a19:	74 09                	je     4007a24 <KernelSpacePgsMemMgr::PgCBtb_lv0_entry_query(unsigned long)+0x13c>
        return NullPgCBHeader;
 4007a1b:	48 8d 05 ae 57 80 00 	lea    0x8057ae(%rip),%rax        # 480d1d0 <NullPgCBHeader_prototype>
 4007a22:	eb 57                	jmp    4007a7b <KernelSpacePgsMemMgr::PgCBtb_lv0_entry_query(unsigned long)+0x193>
    }

    // 获取LV1节点（处理LV2的位图存储）
    PgControlBlockHeader lv1_header = lv2_header.base.lowerlvPgCBtb->entries[lv1_index];
 4007a24:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 4007a28:	0f b7 55 f4          	movzwl -0xc(%rbp),%edx
 4007a2c:	48 63 d2             	movslq %edx,%rdx
 4007a2f:	48 c1 e2 04          	shl    $0x4,%rdx
 4007a33:	48 01 d0             	add    %rdx,%rax
 4007a36:	48 8b 50 10          	mov    0x10(%rax),%rdx
 4007a3a:	48 8b 40 08          	mov    0x8(%rax),%rax
 4007a3e:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
 4007a42:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
    if (lv1_header.flags.is_exist == 0||lv1_header.flags.is_atom==1) {
 4007a46:	0f b6 45 b0          	movzbl -0x50(%rbp),%eax
 4007a4a:	83 e0 02             	and    $0x2,%eax
 4007a4d:	84 c0                	test   %al,%al
 4007a4f:	74 0b                	je     4007a5c <KernelSpacePgsMemMgr::PgCBtb_lv0_entry_query(unsigned long)+0x174>
 4007a51:	0f b6 45 b0          	movzbl -0x50(%rbp),%eax
 4007a55:	83 e0 04             	and    $0x4,%eax
 4007a58:	84 c0                	test   %al,%al
 4007a5a:	74 09                	je     4007a65 <KernelSpacePgsMemMgr::PgCBtb_lv0_entry_query(unsigned long)+0x17d>
        return NullPgCBHeader;
 4007a5c:	48 8d 05 6d 57 80 00 	lea    0x80576d(%rip),%rax        # 480d1d0 <NullPgCBHeader_prototype>
 4007a63:	eb 16                	jmp    4007a7b <KernelSpacePgsMemMgr::PgCBtb_lv0_entry_query(unsigned long)+0x193>
    }


        return lv1_header.base.lowerlvPgCBtb->entries[lv0_index];
 4007a65:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 4007a69:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
 4007a6d:	48 63 d2             	movslq %edx,%rdx
 4007a70:	48 c1 e2 04          	shl    $0x4,%rdx
 4007a74:	48 01 d0             	add    %rdx,%rax
 4007a77:	48 83 c0 08          	add    $0x8,%rax
    
}
 4007a7b:	5d                   	pop    %rbp
 4007a7c:	c3                   	ret
 4007a7d:	90                   	nop

0000000004007a7e <KernelSpacePgsMemMgr::queryPhysicalMemoryUsage(unsigned long, unsigned long)>:
 * 。。。。。。
 * 如果是类型为freeSystemRam则需要特殊处理，不过这部分我来研究
 */

phy_memDesriptor *KernelSpacePgsMemMgr::queryPhysicalMemoryUsage(phyaddr_t base, uint64_t len_in_bytes)
{
 4007a7e:	55                   	push   %rbp
 4007a7f:	48 89 e5             	mov    %rsp,%rbp
 4007a82:	53                   	push   %rbx
 4007a83:	48 81 ec 08 01 00 00 	sub    $0x108,%rsp
 4007a8a:	48 89 bd 08 ff ff ff 	mov    %rdi,-0xf8(%rbp)
 4007a91:	48 89 b5 00 ff ff ff 	mov    %rsi,-0x100(%rbp)
 4007a98:	48 89 95 f8 fe ff ff 	mov    %rdx,-0x108(%rbp)
    if (base & PAGE_OFFSET_MASK[0])         
 4007a9f:	b8 ff 0f 00 00       	mov    $0xfff,%eax
 4007aa4:	48 23 85 00 ff ff ff 	and    -0x100(%rbp),%rax
 4007aab:	48 85 c0             	test   %rax,%rax
 4007aae:	74 0a                	je     4007aba <KernelSpacePgsMemMgr::queryPhysicalMemoryUsage(unsigned long, unsigned long)+0x3c>
        return (phy_memDesriptor*)OS_INVALID_ADDRESS;
 4007ab0:	bb 04 10 00 00       	mov    $0x1004,%ebx
 4007ab5:	e9 75 04 00 00       	jmp    4007f2f <KernelSpacePgsMemMgr::queryPhysicalMemoryUsage(unsigned long, unsigned long)+0x4b1>
    if(base+len_in_bytes>gBaseMemMgr.getMaxPhyaddr())return (phy_memDesriptor*)OS_OUT_OF_MEMORY;
 4007aba:	48 8b 95 00 ff ff ff 	mov    -0x100(%rbp),%rdx
 4007ac1:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
 4007ac8:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
 4007acc:	48 8d 05 6d 85 7f 00 	lea    0x7f856d(%rip),%rax        # 4800040 <gBaseMemMgr>
 4007ad3:	48 89 c7             	mov    %rax,%rdi
 4007ad6:	e8 89 ae ff ff       	call   4002964 <GlobalMemoryPGlevelMgr_t::getMaxPhyaddr()>
 4007adb:	48 39 d8             	cmp    %rbx,%rax
 4007ade:	0f 92 c0             	setb   %al
 4007ae1:	84 c0                	test   %al,%al
 4007ae3:	74 0a                	je     4007aef <KernelSpacePgsMemMgr::queryPhysicalMemoryUsage(unsigned long, unsigned long)+0x71>
 4007ae5:	bb 01 10 00 00       	mov    $0x1001,%ebx
 4007aea:	e9 40 04 00 00       	jmp    4007f2f <KernelSpacePgsMemMgr::queryPhysicalMemoryUsage(unsigned long, unsigned long)+0x4b1>
    len_in_bytes += PAGE_SIZE_IN_LV[0] - 1;
 4007aef:	ba 00 10 00 00       	mov    $0x1000,%edx
 4007af4:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
 4007afb:	48 01 d0             	add    %rdx,%rax
 4007afe:	48 83 e8 01          	sub    $0x1,%rax
 4007b02:	48 89 85 f8 fe ff ff 	mov    %rax,-0x108(%rbp)
    len_in_bytes &= ~PAGE_OFFSET_MASK[0];
 4007b09:	b8 ff 0f 00 00       	mov    $0xfff,%eax
 4007b0e:	48 f7 d0             	not    %rax
 4007b11:	48 21 85 f8 fe ff ff 	and    %rax,-0x108(%rbp)
    bool is_dyn_pushed;
    phyaddr_t endaddr=base+len_in_bytes;
 4007b18:	48 8b 95 00 ff ff ff 	mov    -0x100(%rbp),%rdx
 4007b1f:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
 4007b26:	48 01 d0             	add    %rdx,%rax
 4007b29:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    DoublyLinkedList<phy_memDesriptor> table;  
 4007b2d:	48 8d 45 90          	lea    -0x70(%rbp),%rax
 4007b31:	48 89 c7             	mov    %rax,%rdi
 4007b34:	e8 31 04 00 00       	call   4007f6a <DoublyLinkedList<phy_memDesriptor>::DoublyLinkedList()>
    phyaddr_t scan_addr=base;
 4007b39:	48 8b 85 00 ff ff ff 	mov    -0x100(%rbp),%rax
 4007b40:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    phy_memDesriptor dyn_descriptor={0};
 4007b44:	66 0f ef c0          	pxor   %xmm0,%xmm0
 4007b48:	0f 29 85 60 ff ff ff 	movaps %xmm0,-0xa0(%rbp)
 4007b4f:	0f 29 85 70 ff ff ff 	movaps %xmm0,-0x90(%rbp)
 4007b56:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
    uint64_t descriptor_count=0;
 4007b5a:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
 4007b61:	00 
    while (scan_addr<endaddr)//一次遍历至少一个页
 4007b62:	e9 4a 02 00 00       	jmp    4007db1 <KernelSpacePgsMemMgr::queryPhysicalMemoryUsage(unsigned long, unsigned long)+0x333>
    {   //返回结果中改成OS_ALLOCATABLE_MEMORY
        int lv=0;
 4007b67:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
        PgControlBlockHeader pg_entry;
        for( lv=0;lv<5;lv++)
 4007b6e:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
 4007b75:	e9 99 00 00 00       	jmp    4007c13 <KernelSpacePgsMemMgr::queryPhysicalMemoryUsage(unsigned long, unsigned long)+0x195>
        {
            pg_entry=(this->*(PgCBtb_query_func[lv]))(scan_addr);
 4007b7a:	48 8b 8d 08 ff ff ff 	mov    -0xf8(%rbp),%rcx
 4007b81:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
 4007b88:	8b 55 d4             	mov    -0x2c(%rbp),%edx
 4007b8b:	48 63 d2             	movslq %edx,%rdx
 4007b8e:	48 81 c2 07 01 00 00 	add    $0x107,%rdx
 4007b95:	48 c1 e2 04          	shl    $0x4,%rdx
 4007b99:	48 01 d0             	add    %rdx,%rax
 4007b9c:	48 8b 50 10          	mov    0x10(%rax),%rdx
 4007ba0:	48 8b 40 08          	mov    0x8(%rax),%rax
 4007ba4:	48 89 c6             	mov    %rax,%rsi
 4007ba7:	83 e6 01             	and    $0x1,%esi
 4007baa:	48 85 f6             	test   %rsi,%rsi
 4007bad:	74 18                	je     4007bc7 <KernelSpacePgsMemMgr::queryPhysicalMemoryUsage(unsigned long, unsigned long)+0x149>
 4007baf:	48 89 d6             	mov    %rdx,%rsi
 4007bb2:	48 01 ce             	add    %rcx,%rsi
 4007bb5:	48 8b 36             	mov    (%rsi),%rsi
 4007bb8:	48 89 c7             	mov    %rax,%rdi
 4007bbb:	48 83 ef 01          	sub    $0x1,%rdi
 4007bbf:	48 01 fe             	add    %rdi,%rsi
 4007bc2:	4c 8b 06             	mov    (%rsi),%r8
 4007bc5:	eb 03                	jmp    4007bca <KernelSpacePgsMemMgr::queryPhysicalMemoryUsage(unsigned long, unsigned long)+0x14c>
 4007bc7:	49 89 c0             	mov    %rax,%r8
 4007bca:	48 89 d0             	mov    %rdx,%rax
 4007bcd:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
 4007bd1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4007bd5:	48 89 c6             	mov    %rax,%rsi
 4007bd8:	48 89 d7             	mov    %rdx,%rdi
 4007bdb:	41 ff d0             	call   *%r8
 4007bde:	48 8b 50 08          	mov    0x8(%rax),%rdx
 4007be2:	48 8b 00             	mov    (%rax),%rax
 4007be5:	48 89 85 50 ff ff ff 	mov    %rax,-0xb0(%rbp)
 4007bec:	48 89 95 58 ff ff ff 	mov    %rdx,-0xa8(%rbp)
            if (pg_entry.flags.is_exist&&pg_entry.flags.is_atom)
 4007bf3:	0f b6 85 50 ff ff ff 	movzbl -0xb0(%rbp),%eax
 4007bfa:	83 e0 02             	and    $0x2,%eax
 4007bfd:	84 c0                	test   %al,%al
 4007bff:	74 0e                	je     4007c0f <KernelSpacePgsMemMgr::queryPhysicalMemoryUsage(unsigned long, unsigned long)+0x191>
 4007c01:	0f b6 85 50 ff ff ff 	movzbl -0xb0(%rbp),%eax
 4007c08:	83 e0 04             	and    $0x4,%eax
 4007c0b:	84 c0                	test   %al,%al
 4007c0d:	75 10                	jne    4007c1f <KernelSpacePgsMemMgr::queryPhysicalMemoryUsage(unsigned long, unsigned long)+0x1a1>
        for( lv=0;lv<5;lv++)
 4007c0f:	83 45 d4 01          	addl   $0x1,-0x2c(%rbp)
 4007c13:	83 7d d4 04          	cmpl   $0x4,-0x2c(%rbp)
 4007c17:	0f 8e 5d ff ff ff    	jle    4007b7a <KernelSpacePgsMemMgr::queryPhysicalMemoryUsage(unsigned long, unsigned long)+0xfc>
 4007c1d:	eb 01                	jmp    4007c20 <KernelSpacePgsMemMgr::queryPhysicalMemoryUsage(unsigned long, unsigned long)+0x1a2>
            {
                break;
 4007c1f:	90                   	nop
        *  上面的attribute0位是否占用，1位是否读，2位是否写，3位是否可执行，
        *
        * 上面的约定只在phy_memDesriptor *queryPhysicalMemoryUsage(phyaddr_t base, uint64_t len_in_bytes)
        * 的返回结果中有效
        */
        if(lv>=5) 
 4007c20:	83 7d d4 04          	cmpl   $0x4,-0x2c(%rbp)
 4007c24:	7e 0a                	jle    4007c30 <KernelSpacePgsMemMgr::queryPhysicalMemoryUsage(unsigned long, unsigned long)+0x1b2>
        //由于对于高于最高物理地址的不会初始化，如果是查询到最高物理地址则是会
        return nullptr;
 4007c26:	bb 00 00 00 00       	mov    $0x0,%ebx
 4007c2b:	e9 f3 02 00 00       	jmp    4007f23 <KernelSpacePgsMemMgr::queryPhysicalMemoryUsage(unsigned long, unsigned long)+0x4a5>
            
        uint64_t pg_attribute = 0;
 4007c30:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
 4007c37:	00 
        // 根据pg_entry构建pg_attribute
        pg_attribute |= pg_entry.flags.is_occupied;
 4007c38:	0f b6 85 50 ff ff ff 	movzbl -0xb0(%rbp),%eax
 4007c3f:	c0 e8 04             	shr    $0x4,%al
 4007c42:	83 e0 01             	and    $0x1,%eax
 4007c45:	0f b6 c0             	movzbl %al,%eax
 4007c48:	48 09 45 b8          	or     %rax,-0x48(%rbp)
        pg_attribute |= pg_entry.flags.is_readable << 1;
 4007c4c:	0f b6 85 50 ff ff ff 	movzbl -0xb0(%rbp),%eax
 4007c53:	c0 e8 06             	shr    $0x6,%al
 4007c56:	83 e0 01             	and    $0x1,%eax
 4007c59:	0f b6 c0             	movzbl %al,%eax
 4007c5c:	01 c0                	add    %eax,%eax
 4007c5e:	48 98                	cltq
 4007c60:	48 09 45 b8          	or     %rax,-0x48(%rbp)
        pg_attribute |= pg_entry.flags.is_writable << 2;
 4007c64:	0f b6 85 50 ff ff ff 	movzbl -0xb0(%rbp),%eax
 4007c6b:	c0 e8 07             	shr    $0x7,%al
 4007c6e:	0f b6 c0             	movzbl %al,%eax
 4007c71:	c1 e0 02             	shl    $0x2,%eax
 4007c74:	48 98                	cltq
 4007c76:	48 09 45 b8          	or     %rax,-0x48(%rbp)
        pg_attribute |= pg_entry.flags.is_executable << 3;
 4007c7a:	0f b6 85 51 ff ff ff 	movzbl -0xaf(%rbp),%eax
 4007c81:	83 e0 01             	and    $0x1,%eax
 4007c84:	0f b6 c0             	movzbl %al,%eax
 4007c87:	c1 e0 03             	shl    $0x3,%eax
 4007c8a:	48 98                	cltq
 4007c8c:	48 09 45 b8          	or     %rax,-0x48(%rbp)
            
        if (dyn_descriptor.Type == EfiReservedMemoryType)
 4007c90:	8b 85 60 ff ff ff    	mov    -0xa0(%rbp),%eax
 4007c96:	85 c0                	test   %eax,%eax
 4007c98:	75 42                	jne    4007cdc <KernelSpacePgsMemMgr::queryPhysicalMemoryUsage(unsigned long, unsigned long)+0x25e>
        {
            // 初始化动态描述符
            dyn_descriptor.PhysicalStart = scan_addr;
 4007c9a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4007c9e:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
            dyn_descriptor.NumberOfPages = 0;
 4007ca5:	48 c7 85 78 ff ff ff 	movq   $0x0,-0x88(%rbp)
 4007cac:	00 00 00 00 
            dyn_descriptor.Attribute = pg_attribute;
 4007cb0:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 4007cb4:	48 89 45 80          	mov    %rax,-0x80(%rbp)
            dyn_descriptor.Type = pg_entry.flags.is_reserved ? OS_RESERVED_MEMORY : OS_ALLOCATABLE_MEMORY;
 4007cb8:	0f b6 85 50 ff ff ff 	movzbl -0xb0(%rbp),%eax
 4007cbf:	83 e0 08             	and    $0x8,%eax
 4007cc2:	84 c0                	test   %al,%al
 4007cc4:	74 07                	je     4007ccd <KernelSpacePgsMemMgr::queryPhysicalMemoryUsage(unsigned long, unsigned long)+0x24f>
 4007cc6:	b8 16 00 00 00       	mov    $0x16,%eax
 4007ccb:	eb 05                	jmp    4007cd2 <KernelSpacePgsMemMgr::queryPhysicalMemoryUsage(unsigned long, unsigned long)+0x254>
 4007ccd:	b8 15 00 00 00       	mov    $0x15,%eax
 4007cd2:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%rbp)
            is_dyn_pushed=false;
 4007cd8:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
        }
            
        if(pg_attribute != dyn_descriptor.Attribute ||
 4007cdc:	48 8b 45 80          	mov    -0x80(%rbp),%rax
 4007ce0:	48 39 45 b8          	cmp    %rax,-0x48(%rbp)
 4007ce4:	75 26                	jne    4007d0c <KernelSpacePgsMemMgr::queryPhysicalMemoryUsage(unsigned long, unsigned long)+0x28e>
           ((dyn_descriptor.Type == OS_RESERVED_MEMORY) != (bool)pg_entry.flags.is_reserved))//描述符属性不一致
 4007ce6:	8b 85 60 ff ff ff    	mov    -0xa0(%rbp),%eax
 4007cec:	83 f8 16             	cmp    $0x16,%eax
 4007cef:	0f 94 c0             	sete   %al
 4007cf2:	0f b6 d0             	movzbl %al,%edx
 4007cf5:	0f b6 85 50 ff ff ff 	movzbl -0xb0(%rbp),%eax
 4007cfc:	83 e0 08             	and    $0x8,%eax
 4007cff:	c0 e8 03             	shr    $0x3,%al
 4007d02:	83 e0 01             	and    $0x1,%eax
 4007d05:	0f b6 c0             	movzbl %al,%eax
        if(pg_attribute != dyn_descriptor.Attribute ||
 4007d08:	39 c2                	cmp    %eax,%edx
 4007d0a:	74 61                	je     4007d6d <KernelSpacePgsMemMgr::queryPhysicalMemoryUsage(unsigned long, unsigned long)+0x2ef>
        {
            table.push_back(dyn_descriptor);
 4007d0c:	48 8d 95 60 ff ff ff 	lea    -0xa0(%rbp),%rdx
 4007d13:	48 8d 45 90          	lea    -0x70(%rbp),%rax
 4007d17:	48 89 d6             	mov    %rdx,%rsi
 4007d1a:	48 89 c7             	mov    %rax,%rdi
 4007d1d:	e8 92 02 00 00       	call   4007fb4 <DoublyLinkedList<phy_memDesriptor>::push_back(phy_memDesriptor const&)>
            descriptor_count++;is_dyn_pushed=true;
 4007d22:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
 4007d27:	c6 45 ef 01          	movb   $0x1,-0x11(%rbp)
            dyn_descriptor.PhysicalStart = scan_addr;
 4007d2b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4007d2f:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
            dyn_descriptor.NumberOfPages = 0;
 4007d36:	48 c7 85 78 ff ff ff 	movq   $0x0,-0x88(%rbp)
 4007d3d:	00 00 00 00 
            dyn_descriptor.Attribute = pg_attribute;
 4007d41:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 4007d45:	48 89 45 80          	mov    %rax,-0x80(%rbp)
            dyn_descriptor.Type = pg_entry.flags.is_reserved ? OS_RESERVED_MEMORY : OS_ALLOCATABLE_MEMORY;
 4007d49:	0f b6 85 50 ff ff ff 	movzbl -0xb0(%rbp),%eax
 4007d50:	83 e0 08             	and    $0x8,%eax
 4007d53:	84 c0                	test   %al,%al
 4007d55:	74 07                	je     4007d5e <KernelSpacePgsMemMgr::queryPhysicalMemoryUsage(unsigned long, unsigned long)+0x2e0>
 4007d57:	b8 16 00 00 00       	mov    $0x16,%eax
 4007d5c:	eb 05                	jmp    4007d63 <KernelSpacePgsMemMgr::queryPhysicalMemoryUsage(unsigned long, unsigned long)+0x2e5>
 4007d5e:	b8 15 00 00 00       	mov    $0x15,%eax
 4007d63:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%rbp)
            is_dyn_pushed=false;
 4007d69:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
        }
        dyn_descriptor.NumberOfPages += 1ULL << 9*lv;
 4007d6d:	48 8b b5 78 ff ff ff 	mov    -0x88(%rbp),%rsi
 4007d74:	8b 55 d4             	mov    -0x2c(%rbp),%edx
 4007d77:	89 d0                	mov    %edx,%eax
 4007d79:	c1 e0 03             	shl    $0x3,%eax
 4007d7c:	01 d0                	add    %edx,%eax
 4007d7e:	ba 01 00 00 00       	mov    $0x1,%edx
 4007d83:	89 c1                	mov    %eax,%ecx
 4007d85:	48 d3 e2             	shl    %cl,%rdx
 4007d88:	48 89 d0             	mov    %rdx,%rax
 4007d8b:	48 01 f0             	add    %rsi,%rax
 4007d8e:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
        scan_addr += PAGE_SIZE_IN_LV[lv];
 4007d95:	8b 45 d4             	mov    -0x2c(%rbp),%eax
 4007d98:	48 98                	cltq
 4007d9a:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
 4007da1:	00 
 4007da2:	48 8d 05 f7 8d 00 00 	lea    0x8df7(%rip),%rax        # 4010ba0 <PAGE_SIZE_IN_LV>
 4007da9:	48 8b 04 02          	mov    (%rdx,%rax,1),%rax
 4007dad:	48 01 45 e0          	add    %rax,-0x20(%rbp)
    while (scan_addr<endaddr)//一次遍历至少一个页
 4007db1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4007db5:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
 4007db9:	0f 82 a8 fd ff ff    	jb     4007b67 <KernelSpacePgsMemMgr::queryPhysicalMemoryUsage(unsigned long, unsigned long)+0xe9>
    }
    if(is_dyn_pushed==false){
 4007dbf:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
 4007dc3:	85 c0                	test   %eax,%eax
 4007dc5:	75 1f                	jne    4007de6 <KernelSpacePgsMemMgr::queryPhysicalMemoryUsage(unsigned long, unsigned long)+0x368>
    table.push_back(dyn_descriptor);
 4007dc7:	48 8d 95 60 ff ff ff 	lea    -0xa0(%rbp),%rdx
 4007dce:	48 8d 45 90          	lea    -0x70(%rbp),%rax
 4007dd2:	48 89 d6             	mov    %rdx,%rsi
 4007dd5:	48 89 c7             	mov    %rax,%rdi
 4007dd8:	e8 d7 01 00 00       	call   4007fb4 <DoublyLinkedList<phy_memDesriptor>::push_back(phy_memDesriptor const&)>
    descriptor_count++;
 4007ddd:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
    is_dyn_pushed=true;
 4007de2:	c6 45 ef 01          	movb   $0x1,-0x11(%rbp)
}
    phy_memDesriptor*result=new phy_memDesriptor[descriptor_count+1];
 4007de6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4007dea:	48 8d 50 01          	lea    0x1(%rax),%rdx
 4007dee:	48 b8 aa aa aa aa aa 	movabs $0x2aaaaaaaaaaaaaa,%rax
 4007df5:	aa aa 02 
 4007df8:	48 39 d0             	cmp    %rdx,%rax
 4007dfb:	72 0f                	jb     4007e0c <KernelSpacePgsMemMgr::queryPhysicalMemoryUsage(unsigned long, unsigned long)+0x38e>
 4007dfd:	48 89 d0             	mov    %rdx,%rax
 4007e00:	48 01 c0             	add    %rax,%rax
 4007e03:	48 01 d0             	add    %rdx,%rax
 4007e06:	48 c1 e0 04          	shl    $0x4,%rax
 4007e0a:	eb 07                	jmp    4007e13 <KernelSpacePgsMemMgr::queryPhysicalMemoryUsage(unsigned long, unsigned long)+0x395>
 4007e0c:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
 4007e13:	48 89 c7             	mov    %rax,%rdi
 4007e16:	e8 f9 c7 ff ff       	call   4004614 <operator new[](unsigned long)>
 4007e1b:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    gKpoolmemmgr.clear(result);
 4007e1f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
 4007e23:	48 8d 15 56 82 7f 00 	lea    0x7f8256(%rip),%rdx        # 4800080 <gKpoolmemmgr>
 4007e2a:	48 89 c6             	mov    %rax,%rsi
 4007e2d:	48 89 d7             	mov    %rdx,%rdi
 4007e30:	e8 f3 c5 ff ff       	call   4004428 <kpoolmemmgr_t::clear(void*)>
    int index=0;
 4007e35:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%rbp)
    for (auto i = table.begin(); i != table.end(); i++,index++)
 4007e3c:	48 8d 45 90          	lea    -0x70(%rbp),%rax
 4007e40:	48 89 c7             	mov    %rax,%rdi
 4007e43:	e8 0e 02 00 00       	call   4008056 <DoublyLinkedList<phy_memDesriptor>::begin() const>
 4007e48:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
 4007e4f:	e9 9d 00 00 00       	jmp    4007ef1 <KernelSpacePgsMemMgr::queryPhysicalMemoryUsage(unsigned long, unsigned long)+0x473>
    {
        phy_memDesriptor dyn2=*i;
 4007e54:	48 8d 85 48 ff ff ff 	lea    -0xb8(%rbp),%rax
 4007e5b:	48 89 c7             	mov    %rax,%rdi
 4007e5e:	e8 93 02 00 00       	call   40080f6 <DoublyLinkedList<phy_memDesriptor>::Iterator::operator*() const>
 4007e63:	48 8b 08             	mov    (%rax),%rcx
 4007e66:	48 8b 58 08          	mov    0x8(%rax),%rbx
 4007e6a:	48 89 8d 10 ff ff ff 	mov    %rcx,-0xf0(%rbp)
 4007e71:	48 89 9d 18 ff ff ff 	mov    %rbx,-0xe8(%rbp)
 4007e78:	48 8b 48 10          	mov    0x10(%rax),%rcx
 4007e7c:	48 8b 58 18          	mov    0x18(%rax),%rbx
 4007e80:	48 89 8d 20 ff ff ff 	mov    %rcx,-0xe0(%rbp)
 4007e87:	48 89 9d 28 ff ff ff 	mov    %rbx,-0xd8(%rbp)
 4007e8e:	48 8b 50 28          	mov    0x28(%rax),%rdx
 4007e92:	48 8b 40 20          	mov    0x20(%rax),%rax
 4007e96:	48 89 85 30 ff ff ff 	mov    %rax,-0xd0(%rbp)
 4007e9d:	48 89 95 38 ff ff ff 	mov    %rdx,-0xc8(%rbp)
        ksystemramcpy(&dyn2,result+index,sizeof(phy_memDesriptor));
 4007ea4:	8b 45 d0             	mov    -0x30(%rbp),%eax
 4007ea7:	48 63 d0             	movslq %eax,%rdx
 4007eaa:	48 89 d0             	mov    %rdx,%rax
 4007ead:	48 01 c0             	add    %rax,%rax
 4007eb0:	48 01 d0             	add    %rdx,%rax
 4007eb3:	48 c1 e0 04          	shl    $0x4,%rax
 4007eb7:	48 89 c2             	mov    %rax,%rdx
 4007eba:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
 4007ebe:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
 4007ec2:	48 8d 85 10 ff ff ff 	lea    -0xf0(%rbp),%rax
 4007ec9:	ba 30 00 00 00       	mov    $0x30,%edx
 4007ece:	48 89 ce             	mov    %rcx,%rsi
 4007ed1:	48 89 c7             	mov    %rax,%rdi
 4007ed4:	e8 4d 04 00 00       	call   4008326 <ksystemramcpy(void*, void*, unsigned long)>
    for (auto i = table.begin(); i != table.end(); i++,index++)
 4007ed9:	48 8d 85 48 ff ff ff 	lea    -0xb8(%rbp),%rax
 4007ee0:	be 00 00 00 00       	mov    $0x0,%esi
 4007ee5:	48 89 c7             	mov    %rax,%rdi
 4007ee8:	e8 dd 01 00 00       	call   40080ca <DoublyLinkedList<phy_memDesriptor>::Iterator::operator++(int)>
 4007eed:	83 45 d0 01          	addl   $0x1,-0x30(%rbp)
 4007ef1:	48 8d 45 90          	lea    -0x70(%rbp),%rax
 4007ef5:	48 89 c7             	mov    %rax,%rdi
 4007ef8:	e8 81 01 00 00       	call   400807e <DoublyLinkedList<phy_memDesriptor>::end() const>
 4007efd:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
 4007f01:	48 8d 55 b0          	lea    -0x50(%rbp),%rdx
 4007f05:	48 8d 85 48 ff ff ff 	lea    -0xb8(%rbp),%rax
 4007f0c:	48 89 d6             	mov    %rdx,%rsi
 4007f0f:	48 89 c7             	mov    %rax,%rdi
 4007f12:	e8 8b 01 00 00       	call   40080a2 <DoublyLinkedList<phy_memDesriptor>::Iterator::operator!=(DoublyLinkedList<phy_memDesriptor>::Iterator const&) const>
 4007f17:	84 c0                	test   %al,%al
 4007f19:	0f 85 35 ff ff ff    	jne    4007e54 <KernelSpacePgsMemMgr::queryPhysicalMemoryUsage(unsigned long, unsigned long)+0x3d6>
    }
    return result;
 4007f1f:	48 8b 5d c0          	mov    -0x40(%rbp),%rbx
}
 4007f23:	48 8d 45 90          	lea    -0x70(%rbp),%rax
 4007f27:	48 89 c7             	mov    %rax,%rdi
 4007f2a:	e8 69 00 00 00       	call   4007f98 <DoublyLinkedList<phy_memDesriptor>::~DoublyLinkedList()>
 4007f2f:	48 89 d8             	mov    %rbx,%rax
 4007f32:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
 4007f36:	c9                   	leave
 4007f37:	c3                   	ret

0000000004007f38 <KernelSpacePgsMemMgr::getPhyMemoryspace()>:

phy_memDesriptor *KernelSpacePgsMemMgr::getPhyMemoryspace()
{
 4007f38:	55                   	push   %rbp
 4007f39:	48 89 e5             	mov    %rsp,%rbp
 4007f3c:	48 83 ec 10          	sub    $0x10,%rsp
 4007f40:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    return queryPhysicalMemoryUsage(0,gBaseMemMgr.getMaxPhyaddr());
 4007f44:	48 8d 05 f5 80 7f 00 	lea    0x7f80f5(%rip),%rax        # 4800040 <gBaseMemMgr>
 4007f4b:	48 89 c7             	mov    %rax,%rdi
 4007f4e:	e8 11 aa ff ff       	call   4002964 <GlobalMemoryPGlevelMgr_t::getMaxPhyaddr()>
 4007f53:	48 89 c2             	mov    %rax,%rdx
 4007f56:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4007f5a:	be 00 00 00 00       	mov    $0x0,%esi
 4007f5f:	48 89 c7             	mov    %rax,%rdi
 4007f62:	e8 17 fb ff ff       	call   4007a7e <KernelSpacePgsMemMgr::queryPhysicalMemoryUsage(unsigned long, unsigned long)>
}
 4007f67:	c9                   	leave
 4007f68:	c3                   	ret
 4007f69:	90                   	nop

0000000004007f6a <DoublyLinkedList<phy_memDesriptor>::DoublyLinkedList()>:
    Node* tail;
    size_t size;

public:
    // 构造函数
    DoublyLinkedList() : head(nullptr), tail(nullptr), size(0) {}
 4007f6a:	55                   	push   %rbp
 4007f6b:	48 89 e5             	mov    %rsp,%rbp
 4007f6e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
 4007f72:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4007f76:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
 4007f7d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4007f81:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
 4007f88:	00 
 4007f89:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4007f8d:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
 4007f94:	00 
 4007f95:	90                   	nop
 4007f96:	5d                   	pop    %rbp
 4007f97:	c3                   	ret

0000000004007f98 <DoublyLinkedList<phy_memDesriptor>::~DoublyLinkedList()>:
    
    // 析构函数
    ~DoublyLinkedList() {
 4007f98:	55                   	push   %rbp
 4007f99:	48 89 e5             	mov    %rsp,%rbp
 4007f9c:	48 83 ec 10          	sub    $0x10,%rsp
 4007fa0:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
        clear();
 4007fa4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4007fa8:	48 89 c7             	mov    %rax,%rdi
 4007fab:	e8 58 01 00 00       	call   4008108 <DoublyLinkedList<phy_memDesriptor>::clear()>
    }
 4007fb0:	90                   	nop
 4007fb1:	c9                   	leave
 4007fb2:	c3                   	ret
 4007fb3:	90                   	nop

0000000004007fb4 <DoublyLinkedList<phy_memDesriptor>::push_back(phy_memDesriptor const&)>:
        }
        size++;
    }
    
    // 在链表尾部添加元素
    void push_back(const T& value) {
 4007fb4:	55                   	push   %rbp
 4007fb5:	48 89 e5             	mov    %rsp,%rbp
 4007fb8:	53                   	push   %rbx
 4007fb9:	48 83 ec 28          	sub    $0x28,%rsp
 4007fbd:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
 4007fc1:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
        Node* newNode = new Node(value);
 4007fc5:	bf 40 00 00 00       	mov    $0x40,%edi
 4007fca:	e8 d0 c5 ff ff       	call   400459f <operator new(unsigned long)>
 4007fcf:	48 89 c3             	mov    %rax,%rbx
 4007fd2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
 4007fd6:	48 89 c6             	mov    %rax,%rsi
 4007fd9:	48 89 df             	mov    %rbx,%rdi
 4007fdc:	e8 8f 01 00 00       	call   4008170 <DoublyLinkedList<phy_memDesriptor>::Node::Node(phy_memDesriptor const&)>
 4007fe1:	48 89 5d e8          	mov    %rbx,-0x18(%rbp)
        if (tail == nullptr) {
 4007fe5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4007fe9:	48 8b 40 08          	mov    0x8(%rax),%rax
 4007fed:	48 85 c0             	test   %rax,%rax
 4007ff0:	75 1d                	jne    400800f <DoublyLinkedList<phy_memDesriptor>::push_back(phy_memDesriptor const&)+0x5b>
            head = tail = newNode;
 4007ff2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4007ff6:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
 4007ffa:	48 89 50 08          	mov    %rdx,0x8(%rax)
 4007ffe:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4008002:	48 8b 50 08          	mov    0x8(%rax),%rdx
 4008006:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 400800a:	48 89 10             	mov    %rdx,(%rax)
 400800d:	eb 2c                	jmp    400803b <DoublyLinkedList<phy_memDesriptor>::push_back(phy_memDesriptor const&)+0x87>
        } else {
            tail->next = newNode;
 400800f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4008013:	48 8b 40 08          	mov    0x8(%rax),%rax
 4008017:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
 400801b:	48 89 50 38          	mov    %rdx,0x38(%rax)
            newNode->prev = tail;
 400801f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4008023:	48 8b 50 08          	mov    0x8(%rax),%rdx
 4008027:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 400802b:	48 89 50 30          	mov    %rdx,0x30(%rax)
            tail = newNode;
 400802f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4008033:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
 4008037:	48 89 50 08          	mov    %rdx,0x8(%rax)
        }
        size++;
 400803b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 400803f:	48 8b 40 10          	mov    0x10(%rax),%rax
 4008043:	48 8d 50 01          	lea    0x1(%rax),%rdx
 4008047:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 400804b:	48 89 50 10          	mov    %rdx,0x10(%rax)
    }
 400804f:	90                   	nop
 4008050:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
 4008054:	c9                   	leave
 4008055:	c3                   	ret

0000000004008056 <DoublyLinkedList<phy_memDesriptor>::begin() const>:
        bool operator!=(const Iterator& other) const {
            return !(*this == other);
        }
    };
    
    Iterator begin() const {
 4008056:	55                   	push   %rbp
 4008057:	48 89 e5             	mov    %rsp,%rbp
 400805a:	48 83 ec 20          	sub    $0x20,%rsp
 400805e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
        return Iterator(head);
 4008062:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4008066:	48 8b 10             	mov    (%rax),%rdx
 4008069:	48 8d 45 f8          	lea    -0x8(%rbp),%rax
 400806d:	48 89 d6             	mov    %rdx,%rsi
 4008070:	48 89 c7             	mov    %rax,%rdi
 4008073:	e8 5a 01 00 00       	call   40081d2 <DoublyLinkedList<phy_memDesriptor>::Iterator::Iterator(DoublyLinkedList<phy_memDesriptor>::Node*)>
 4008078:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    }
 400807c:	c9                   	leave
 400807d:	c3                   	ret

000000000400807e <DoublyLinkedList<phy_memDesriptor>::end() const>:
    
    Iterator end() const {
 400807e:	55                   	push   %rbp
 400807f:	48 89 e5             	mov    %rsp,%rbp
 4008082:	48 83 ec 20          	sub    $0x20,%rsp
 4008086:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
        return Iterator(nullptr);
 400808a:	48 8d 45 f8          	lea    -0x8(%rbp),%rax
 400808e:	be 00 00 00 00       	mov    $0x0,%esi
 4008093:	48 89 c7             	mov    %rax,%rdi
 4008096:	e8 37 01 00 00       	call   40081d2 <DoublyLinkedList<phy_memDesriptor>::Iterator::Iterator(DoublyLinkedList<phy_memDesriptor>::Node*)>
 400809b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
    }
 400809f:	c9                   	leave
 40080a0:	c3                   	ret
 40080a1:	90                   	nop

00000000040080a2 <DoublyLinkedList<phy_memDesriptor>::Iterator::operator!=(DoublyLinkedList<phy_memDesriptor>::Iterator const&) const>:
        bool operator!=(const Iterator& other) const {
 40080a2:	55                   	push   %rbp
 40080a3:	48 89 e5             	mov    %rsp,%rbp
 40080a6:	48 83 ec 10          	sub    $0x10,%rsp
 40080aa:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
 40080ae:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
            return !(*this == other);
 40080b2:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
 40080b6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 40080ba:	48 89 d6             	mov    %rdx,%rsi
 40080bd:	48 89 c7             	mov    %rax,%rdi
 40080c0:	e8 27 01 00 00       	call   40081ec <DoublyLinkedList<phy_memDesriptor>::Iterator::operator==(DoublyLinkedList<phy_memDesriptor>::Iterator const&) const>
 40080c5:	83 f0 01             	xor    $0x1,%eax
        }
 40080c8:	c9                   	leave
 40080c9:	c3                   	ret

00000000040080ca <DoublyLinkedList<phy_memDesriptor>::Iterator::operator++(int)>:
        Iterator operator++(int) {
 40080ca:	55                   	push   %rbp
 40080cb:	48 89 e5             	mov    %rsp,%rbp
 40080ce:	48 83 ec 20          	sub    $0x20,%rsp
 40080d2:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
 40080d6:	89 75 e4             	mov    %esi,-0x1c(%rbp)
            Iterator temp = *this;
 40080d9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 40080dd:	48 8b 00             	mov    (%rax),%rax
 40080e0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
            ++(*this);
 40080e4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 40080e8:	48 89 c7             	mov    %rax,%rdi
 40080eb:	e8 1e 01 00 00       	call   400820e <DoublyLinkedList<phy_memDesriptor>::Iterator::operator++()>
            return temp;
 40080f0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
        }
 40080f4:	c9                   	leave
 40080f5:	c3                   	ret

00000000040080f6 <DoublyLinkedList<phy_memDesriptor>::Iterator::operator*() const>:
        T& operator*() const {
 40080f6:	55                   	push   %rbp
 40080f7:	48 89 e5             	mov    %rsp,%rbp
 40080fa:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
            return current->data;
 40080fe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4008102:	48 8b 00             	mov    (%rax),%rax
        }
 4008105:	5d                   	pop    %rbp
 4008106:	c3                   	ret
 4008107:	90                   	nop

0000000004008108 <DoublyLinkedList<phy_memDesriptor>::clear()>:
    void clear() {
 4008108:	55                   	push   %rbp
 4008109:	48 89 e5             	mov    %rsp,%rbp
 400810c:	48 83 ec 20          	sub    $0x20,%rsp
 4008110:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
        while (head != nullptr) {
 4008114:	eb 33                	jmp    4008149 <DoublyLinkedList<phy_memDesriptor>::clear()+0x41>
            Node* temp = head;
 4008116:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 400811a:	48 8b 00             	mov    (%rax),%rax
 400811d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
            head = head->next;
 4008121:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4008125:	48 8b 00             	mov    (%rax),%rax
 4008128:	48 8b 50 38          	mov    0x38(%rax),%rdx
 400812c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4008130:	48 89 10             	mov    %rdx,(%rax)
            delete temp;
 4008133:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4008137:	48 85 c0             	test   %rax,%rax
 400813a:	74 0d                	je     4008149 <DoublyLinkedList<phy_memDesriptor>::clear()+0x41>
 400813c:	be 40 00 00 00       	mov    $0x40,%esi
 4008141:	48 89 c7             	mov    %rax,%rdi
 4008144:	e8 65 c5 ff ff       	call   40046ae <operator delete(void*, unsigned long)>
        while (head != nullptr) {
 4008149:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 400814d:	48 8b 00             	mov    (%rax),%rax
 4008150:	48 85 c0             	test   %rax,%rax
 4008153:	75 c1                	jne    4008116 <DoublyLinkedList<phy_memDesriptor>::clear()+0xe>
        tail = nullptr;
 4008155:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4008159:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
 4008160:	00 
        size = 0;
 4008161:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4008165:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
 400816c:	00 
    }
 400816d:	90                   	nop
 400816e:	c9                   	leave
 400816f:	c3                   	ret

0000000004008170 <DoublyLinkedList<phy_memDesriptor>::Node::Node(phy_memDesriptor const&)>:
        Node(const T& value) : data(value), prev(nullptr), next(nullptr) {}
 4008170:	55                   	push   %rbp
 4008171:	48 89 e5             	mov    %rsp,%rbp
 4008174:	53                   	push   %rbx
 4008175:	48 89 7d f0          	mov    %rdi,-0x10(%rbp)
 4008179:	48 89 75 e8          	mov    %rsi,-0x18(%rbp)
 400817d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 4008181:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
 4008185:	48 8b 0a             	mov    (%rdx),%rcx
 4008188:	48 8b 5a 08          	mov    0x8(%rdx),%rbx
 400818c:	48 89 08             	mov    %rcx,(%rax)
 400818f:	48 89 58 08          	mov    %rbx,0x8(%rax)
 4008193:	48 8b 4a 10          	mov    0x10(%rdx),%rcx
 4008197:	48 8b 5a 18          	mov    0x18(%rdx),%rbx
 400819b:	48 89 48 10          	mov    %rcx,0x10(%rax)
 400819f:	48 89 58 18          	mov    %rbx,0x18(%rax)
 40081a3:	48 8b 4a 20          	mov    0x20(%rdx),%rcx
 40081a7:	48 8b 5a 28          	mov    0x28(%rdx),%rbx
 40081ab:	48 89 48 20          	mov    %rcx,0x20(%rax)
 40081af:	48 89 58 28          	mov    %rbx,0x28(%rax)
 40081b3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 40081b7:	48 c7 40 30 00 00 00 	movq   $0x0,0x30(%rax)
 40081be:	00 
 40081bf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 40081c3:	48 c7 40 38 00 00 00 	movq   $0x0,0x38(%rax)
 40081ca:	00 
 40081cb:	90                   	nop
 40081cc:	48 8b 5d f8          	mov    -0x8(%rbp),%rbx
 40081d0:	c9                   	leave
 40081d1:	c3                   	ret

00000000040081d2 <DoublyLinkedList<phy_memDesriptor>::Iterator::Iterator(DoublyLinkedList<phy_memDesriptor>::Node*)>:
        Iterator(Node* node) : current(node) {}
 40081d2:	55                   	push   %rbp
 40081d3:	48 89 e5             	mov    %rsp,%rbp
 40081d6:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
 40081da:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
 40081de:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 40081e2:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
 40081e6:	48 89 10             	mov    %rdx,(%rax)
 40081e9:	90                   	nop
 40081ea:	5d                   	pop    %rbp
 40081eb:	c3                   	ret

00000000040081ec <DoublyLinkedList<phy_memDesriptor>::Iterator::operator==(DoublyLinkedList<phy_memDesriptor>::Iterator const&) const>:
        bool operator==(const Iterator& other) const {
 40081ec:	55                   	push   %rbp
 40081ed:	48 89 e5             	mov    %rsp,%rbp
 40081f0:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
 40081f4:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
            return current == other.current;
 40081f8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 40081fc:	48 8b 10             	mov    (%rax),%rdx
 40081ff:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 4008203:	48 8b 00             	mov    (%rax),%rax
 4008206:	48 39 c2             	cmp    %rax,%rdx
 4008209:	0f 94 c0             	sete   %al
        }
 400820c:	5d                   	pop    %rbp
 400820d:	c3                   	ret

000000000400820e <DoublyLinkedList<phy_memDesriptor>::Iterator::operator++()>:
        Iterator& operator++() {
 400820e:	55                   	push   %rbp
 400820f:	48 89 e5             	mov    %rsp,%rbp
 4008212:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
            current = current->next;
 4008216:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 400821a:	48 8b 00             	mov    (%rax),%rax
 400821d:	48 8b 50 38          	mov    0x38(%rax),%rdx
 4008221:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4008225:	48 89 10             	mov    %rdx,(%rax)
            return *this;
 4008228:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
        }
 400822c:	5d                   	pop    %rbp
 400822d:	c3                   	ret

000000000400822e <strlen(char const*)>:
#include "stdint.h"
typedef uint64_t size_t;
const uint8_t masks_entry1bit_width[8]={128,64,32,16,8,4,2,1};
const uint8_t masks_entry2bits_width[4]={192,48,12,3};

int strlen(const char *s) {
 400822e:	55                   	push   %rbp
 400822f:	48 89 e5             	mov    %rsp,%rbp
 4008232:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    int len = 0;
 4008236:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
    while (*s++)
 400823d:	eb 04                	jmp    4008243 <strlen(char const*)+0x15>
        len++;
 400823f:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
    while (*s++)
 4008243:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4008247:	48 8d 50 01          	lea    0x1(%rax),%rdx
 400824b:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
 400824f:	0f b6 00             	movzbl (%rax),%eax
 4008252:	84 c0                	test   %al,%al
 4008254:	0f 95 c0             	setne  %al
 4008257:	84 c0                	test   %al,%al
 4008259:	75 e4                	jne    400823f <strlen(char const*)+0x11>
    return len;
 400825b:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
 400825e:	5d                   	pop    %rbp
 400825f:	c3                   	ret

0000000004008260 <setmem(void*, unsigned long, unsigned char)>:
 void setmem(void* ptr, uint64_t size_in_byte, uint8_t value) {
 4008260:	55                   	push   %rbp
 4008261:	48 89 e5             	mov    %rsp,%rbp
 4008264:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
 4008268:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
 400826c:	89 d0                	mov    %edx,%eax
 400826e:	88 45 cc             	mov    %al,-0x34(%rbp)
    uint8_t* p = static_cast<uint8_t*>(ptr);
 4008271:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4008275:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    
    // 使用64位写入来加速内存设置
    uint64_t value64 = value;
 4008279:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
 400827d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    value64 |= value64 << 8;
 4008281:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4008285:	48 c1 e0 08          	shl    $0x8,%rax
 4008289:	48 09 45 e8          	or     %rax,-0x18(%rbp)
    value64 |= value64 << 16;
 400828d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4008291:	48 c1 e0 10          	shl    $0x10,%rax
 4008295:	48 09 45 e8          	or     %rax,-0x18(%rbp)
    value64 |= value64 << 32;
 4008299:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 400829d:	48 c1 e0 20          	shl    $0x20,%rax
 40082a1:	48 09 45 e8          	or     %rax,-0x18(%rbp)
    
    // 处理前缀不对齐部分
    while (size_in_byte > 0 && (reinterpret_cast<uint64_t>(p) & 7)) {
 40082a5:	eb 17                	jmp    40082be <setmem(void*, unsigned long, unsigned char)+0x5e>
        *p++ = value;
 40082a7:	0f b6 55 cc          	movzbl -0x34(%rbp),%edx
 40082ab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 40082af:	48 8d 48 01          	lea    0x1(%rax),%rcx
 40082b3:	48 89 4d f8          	mov    %rcx,-0x8(%rbp)
 40082b7:	88 10                	mov    %dl,(%rax)
        size_in_byte--;
 40082b9:	48 83 6d d0 01       	subq   $0x1,-0x30(%rbp)
    while (size_in_byte > 0 && (reinterpret_cast<uint64_t>(p) & 7)) {
 40082be:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
 40082c3:	74 0c                	je     40082d1 <setmem(void*, unsigned long, unsigned char)+0x71>
 40082c5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 40082c9:	83 e0 07             	and    $0x7,%eax
 40082cc:	48 85 c0             	test   %rax,%rax
 40082cf:	75 d6                	jne    40082a7 <setmem(void*, unsigned long, unsigned char)+0x47>
    }
    
    // 使用64位写入处理主体部分
    uint64_t* p64 = reinterpret_cast<uint64_t*>(p);
 40082d1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 40082d5:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    while (size_in_byte >= 8) {
 40082d9:	eb 18                	jmp    40082f3 <setmem(void*, unsigned long, unsigned char)+0x93>
        *p64++ = value64;
 40082db:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
 40082df:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 40082e3:	48 8d 48 08          	lea    0x8(%rax),%rcx
 40082e7:	48 89 4d f0          	mov    %rcx,-0x10(%rbp)
 40082eb:	48 89 10             	mov    %rdx,(%rax)
        size_in_byte -= 8;
 40082ee:	48 83 6d d0 08       	subq   $0x8,-0x30(%rbp)
    while (size_in_byte >= 8) {
 40082f3:	48 83 7d d0 07       	cmpq   $0x7,-0x30(%rbp)
 40082f8:	77 e1                	ja     40082db <setmem(void*, unsigned long, unsigned char)+0x7b>
    }
    
    // 处理剩余部分
    p = reinterpret_cast<uint8_t*>(p64);
 40082fa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 40082fe:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    while (size_in_byte > 0) {
 4008302:	eb 17                	jmp    400831b <setmem(void*, unsigned long, unsigned char)+0xbb>
        *p++ = value;
 4008304:	0f b6 55 cc          	movzbl -0x34(%rbp),%edx
 4008308:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 400830c:	48 8d 48 01          	lea    0x1(%rax),%rcx
 4008310:	48 89 4d f8          	mov    %rcx,-0x8(%rbp)
 4008314:	88 10                	mov    %dl,(%rax)
        size_in_byte--;
 4008316:	48 83 6d d0 01       	subq   $0x1,-0x30(%rbp)
    while (size_in_byte > 0) {
 400831b:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
 4008320:	75 e2                	jne    4008304 <setmem(void*, unsigned long, unsigned char)+0xa4>
    }
}
 4008322:	90                   	nop
 4008323:	90                   	nop
 4008324:	5d                   	pop    %rbp
 4008325:	c3                   	ret

0000000004008326 <ksystemramcpy(void*, void*, unsigned long)>:
void ksystemramcpy(void*src,void*dest,size_t length)
//最好用于内核内存空间内的内存拷贝，不然会出现未定义行为
{  uint64_t remainder=length&0x7;
 4008326:	55                   	push   %rbp
 4008327:	48 89 e5             	mov    %rsp,%rbp
 400832a:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
 400832e:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
 4008332:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
 4008336:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 400833a:	83 e0 07             	and    $0x7,%eax
 400833d:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    uint64_t count=length>>3;
 4008341:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 4008345:	48 c1 e8 03          	shr    $0x3,%rax
 4008349:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    //先范围重复判断
    if(uint64_t(src)>uint64_t(dest)){
 400834d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 4008351:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
 4008355:	48 39 c2             	cmp    %rax,%rdx
 4008358:	0f 83 9f 00 00 00    	jae    40083fd <ksystemramcpy(void*, void*, unsigned long)+0xd7>
    low_to_high:
 400835e:	90                   	nop
 400835f:	eb 01                	jmp    4008362 <ksystemramcpy(void*, void*, unsigned long)+0x3c>
    for (int i = count-1; i >= 0; i--)
    {
        ((uint64_t*)dest)[i]=((uint64_t*)src)[i];
    }
    
}else goto low_to_high;
 4008361:	90                   	nop
    for(uint64_t i=0;i<count;i++)
 4008362:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
 4008369:	00 
 400836a:	eb 31                	jmp    400839d <ksystemramcpy(void*, void*, unsigned long)+0x77>
        ((uint64_t*)dest)[i]=((uint64_t*)src)[i];
 400836c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4008370:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
 4008377:	00 
 4008378:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 400837c:	48 01 d0             	add    %rdx,%rax
 400837f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
 4008383:	48 8d 0c d5 00 00 00 	lea    0x0(,%rdx,8),%rcx
 400838a:	00 
 400838b:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
 400838f:	48 01 ca             	add    %rcx,%rdx
 4008392:	48 8b 00             	mov    (%rax),%rax
 4008395:	48 89 02             	mov    %rax,(%rdx)
    for(uint64_t i=0;i<count;i++)
 4008398:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
 400839d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 40083a1:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
 40083a5:	72 c5                	jb     400836c <ksystemramcpy(void*, void*, unsigned long)+0x46>
    for(uint64_t i=0;i<remainder;i++)
 40083a7:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
 40083ae:	00 
 40083af:	eb 3d                	jmp    40083ee <ksystemramcpy(void*, void*, unsigned long)+0xc8>
        ((uint8_t*)dest)[length-remainder+i]=((uint8_t*)src)[length-remainder+i];
 40083b1:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 40083b5:	48 2b 45 d8          	sub    -0x28(%rbp),%rax
 40083b9:	48 89 c2             	mov    %rax,%rdx
 40083bc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 40083c0:	48 01 c2             	add    %rax,%rdx
 40083c3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 40083c7:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
 40083cb:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 40083cf:	48 2b 45 d8          	sub    -0x28(%rbp),%rax
 40083d3:	48 89 c2             	mov    %rax,%rdx
 40083d6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 40083da:	48 01 c2             	add    %rax,%rdx
 40083dd:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
 40083e1:	48 01 c2             	add    %rax,%rdx
 40083e4:	0f b6 01             	movzbl (%rcx),%eax
 40083e7:	88 02                	mov    %al,(%rdx)
    for(uint64_t i=0;i<remainder;i++)
 40083e9:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
 40083ee:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 40083f2:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
 40083f6:	72 b9                	jb     40083b1 <ksystemramcpy(void*, void*, unsigned long)+0x8b>
    return ;
 40083f8:	e9 a2 00 00 00       	jmp    400849f <ksystemramcpy(void*, void*, unsigned long)+0x179>
if((uint64_t(src)+length>uint64_t(dest)))
 40083fd:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
 4008401:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 4008405:	48 01 d0             	add    %rdx,%rax
 4008408:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
 400840c:	48 39 c2             	cmp    %rax,%rdx
 400840f:	0f 83 4c ff ff ff    	jae    4008361 <ksystemramcpy(void*, void*, unsigned long)+0x3b>
    for(uint64_t i=0;i<remainder;i++)
 4008415:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
 400841c:	00 
 400841d:	eb 31                	jmp    4008450 <ksystemramcpy(void*, void*, unsigned long)+0x12a>
        ((uint8_t*)dest)[length-i-1]=((uint8_t*)src)[length-i-1];
 400841f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 4008423:	48 2b 45 e8          	sub    -0x18(%rbp),%rax
 4008427:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
 400842b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 400842f:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
 4008433:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 4008437:	48 2b 45 e8          	sub    -0x18(%rbp),%rax
 400843b:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
 400843f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
 4008443:	48 01 c2             	add    %rax,%rdx
 4008446:	0f b6 01             	movzbl (%rcx),%eax
 4008449:	88 02                	mov    %al,(%rdx)
    for(uint64_t i=0;i<remainder;i++)
 400844b:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
 4008450:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4008454:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
 4008458:	72 c5                	jb     400841f <ksystemramcpy(void*, void*, unsigned long)+0xf9>
    for (int i = count-1; i >= 0; i--)
 400845a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
 400845e:	83 e8 01             	sub    $0x1,%eax
 4008461:	89 45 e4             	mov    %eax,-0x1c(%rbp)
 4008464:	eb 33                	jmp    4008499 <ksystemramcpy(void*, void*, unsigned long)+0x173>
        ((uint64_t*)dest)[i]=((uint64_t*)src)[i];
 4008466:	8b 45 e4             	mov    -0x1c(%rbp),%eax
 4008469:	48 98                	cltq
 400846b:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
 4008472:	00 
 4008473:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 4008477:	48 01 d0             	add    %rdx,%rax
 400847a:	8b 55 e4             	mov    -0x1c(%rbp),%edx
 400847d:	48 63 d2             	movslq %edx,%rdx
 4008480:	48 8d 0c d5 00 00 00 	lea    0x0(,%rdx,8),%rcx
 4008487:	00 
 4008488:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
 400848c:	48 01 ca             	add    %rcx,%rdx
 400848f:	48 8b 00             	mov    (%rax),%rax
 4008492:	48 89 02             	mov    %rax,(%rdx)
    for (int i = count-1; i >= 0; i--)
 4008495:	83 6d e4 01          	subl   $0x1,-0x1c(%rbp)
 4008499:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
 400849d:	79 c7                	jns    4008466 <ksystemramcpy(void*, void*, unsigned long)+0x140>
}
}
 400849f:	5d                   	pop    %rbp
 40084a0:	c3                   	ret

00000000040084a1 <linearTBSerialDelete(unsigned long*, unsigned long, unsigned long, void*, unsigned int)>:
    uint64_t a,
    uint64_t b,
    void*linerTbBase,
    uint32_t entrysize
)
{ 
 40084a1:	55                   	push   %rbp
 40084a2:	48 89 e5             	mov    %rsp,%rbp
 40084a5:	48 83 ec 48          	sub    $0x48,%rsp
 40084a9:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
 40084ad:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
 40084b1:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
 40084b5:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
 40084b9:	44 89 45 bc          	mov    %r8d,-0x44(%rbp)
    char*bs=(char*)linerTbBase;
 40084bd:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
 40084c1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    char*srcadd=bs+entrysize*(b+1);
 40084c5:	8b 45 bc             	mov    -0x44(%rbp),%eax
 40084c8:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
 40084cc:	48 83 c2 01          	add    $0x1,%rdx
 40084d0:	48 0f af d0          	imul   %rax,%rdx
 40084d4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 40084d8:	48 01 d0             	add    %rdx,%rax
 40084db:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    char*destadd=bs+entrysize*a;
 40084df:	8b 45 bc             	mov    -0x44(%rbp),%eax
 40084e2:	48 0f af 45 d0       	imul   -0x30(%rbp),%rax
 40084e7:	48 89 c2             	mov    %rax,%rdx
 40084ea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 40084ee:	48 01 d0             	add    %rdx,%rax
 40084f1:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    uint64_t deletedEntryCount=b-a+1;
 40084f5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 40084f9:	48 2b 45 d0          	sub    -0x30(%rbp),%rax
 40084fd:	48 83 c0 01          	add    $0x1,%rax
 4008501:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    ksystemramcpy((void*)srcadd,(void*)destadd,entrysize*(*TotalEntryCount-b-1));
 4008505:	8b 45 bc             	mov    -0x44(%rbp),%eax
 4008508:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
 400850c:	48 8b 12             	mov    (%rdx),%rdx
 400850f:	48 2b 55 c8          	sub    -0x38(%rbp),%rdx
 4008513:	48 83 ea 01          	sub    $0x1,%rdx
 4008517:	48 0f af d0          	imul   %rax,%rdx
 400851b:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
 400851f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 4008523:	48 89 ce             	mov    %rcx,%rsi
 4008526:	48 89 c7             	mov    %rax,%rdi
 4008529:	e8 f8 fd ff ff       	call   4008326 <ksystemramcpy(void*, void*, unsigned long)>
    *TotalEntryCount-=deletedEntryCount;
 400852e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4008532:	48 8b 00             	mov    (%rax),%rax
 4008535:	48 2b 45 e0          	sub    -0x20(%rbp),%rax
 4008539:	48 89 c2             	mov    %rax,%rdx
 400853c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4008540:	48 89 10             	mov    %rdx,(%rax)
}
 4008543:	90                   	nop
 4008544:	c9                   	leave
 4008545:	c3                   	ret

0000000004008546 <linearTBSerialInsert(unsigned long*, unsigned long, void*, void*, unsigned int, unsigned long)>:
    uint64_t insertIndex,
    void* newEntry,
    void* linerTbBase,
    uint32_t entrysize,
    uint64_t entryCount
) {
 4008546:	55                   	push   %rbp
 4008547:	48 89 e5             	mov    %rsp,%rbp
 400854a:	48 83 ec 70          	sub    $0x70,%rsp
 400854e:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
 4008552:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
 4008556:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
 400855a:	48 89 4d a0          	mov    %rcx,-0x60(%rbp)
 400855e:	44 89 45 9c          	mov    %r8d,-0x64(%rbp)
 4008562:	4c 89 4d 90          	mov    %r9,-0x70(%rbp)
    if (insertIndex > *TotalEntryCount) {
 4008566:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 400856a:	48 8b 00             	mov    (%rax),%rax
 400856d:	48 3b 45 b0          	cmp    -0x50(%rbp),%rax
 4008571:	73 0b                	jae    400857e <linearTBSerialInsert(unsigned long*, unsigned long, void*, void*, unsigned int, unsigned long)+0x38>
        // 插入位置超出当前表范围，直接追加到末尾
        insertIndex = *TotalEntryCount;
 4008573:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 4008577:	48 8b 00             	mov    (%rax),%rax
 400857a:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    }
    
    char* base = (char*)linerTbBase;
 400857e:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
 4008582:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    char* src = (char*)newEntry;
 4008586:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
 400858a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    
    // 计算需要移动的数据量（从插入点到表尾）
    uint64_t moveCount = *TotalEntryCount - insertIndex;
 400858e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 4008592:	48 8b 00             	mov    (%rax),%rax
 4008595:	48 2b 45 b0          	sub    -0x50(%rbp),%rax
 4008599:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    uint64_t moveSize = moveCount * entrysize;
 400859d:	8b 45 9c             	mov    -0x64(%rbp),%eax
 40085a0:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
 40085a4:	48 0f af c2          	imul   %rdx,%rax
 40085a8:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    
    if (moveSize > 0) {
 40085ac:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
 40085b1:	74 43                	je     40085f6 <linearTBSerialInsert(unsigned long*, unsigned long, void*, void*, unsigned int, unsigned long)+0xb0>
        // 向后移动现有条目（使用内存安全拷贝）
        char* srcStart = base + insertIndex * entrysize;
 40085b3:	8b 45 9c             	mov    -0x64(%rbp),%eax
 40085b6:	48 0f af 45 b0       	imul   -0x50(%rbp),%rax
 40085bb:	48 89 c2             	mov    %rax,%rdx
 40085be:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 40085c2:	48 01 d0             	add    %rdx,%rax
 40085c5:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
        char* destStart = srcStart + entryCount * entrysize;
 40085c9:	8b 45 9c             	mov    -0x64(%rbp),%eax
 40085cc:	48 0f af 45 90       	imul   -0x70(%rbp),%rax
 40085d1:	48 89 c2             	mov    %rax,%rdx
 40085d4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
 40085d8:	48 01 d0             	add    %rdx,%rax
 40085db:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
        ksystemramcpy(srcStart, destStart, moveSize);
 40085df:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
 40085e3:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
 40085e7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
 40085eb:	48 89 ce             	mov    %rcx,%rsi
 40085ee:	48 89 c7             	mov    %rax,%rdi
 40085f1:	e8 30 fd ff ff       	call   4008326 <ksystemramcpy(void*, void*, unsigned long)>
    }
    
    // 插入新条目
    for (uint64_t i = 0; i < entryCount; i++) {
 40085f6:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
 40085fd:	00 
 40085fe:	eb 46                	jmp    4008646 <linearTBSerialInsert(unsigned long*, unsigned long, void*, void*, unsigned int, unsigned long)+0x100>
        char* dest = base + (insertIndex + i) * entrysize;
 4008600:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
 4008604:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4008608:	48 01 c2             	add    %rax,%rdx
 400860b:	8b 45 9c             	mov    -0x64(%rbp),%eax
 400860e:	48 0f af d0          	imul   %rax,%rdx
 4008612:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 4008616:	48 01 d0             	add    %rdx,%rax
 4008619:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
        ksystemramcpy(src + i * entrysize, dest, entrysize);
 400861d:	8b 55 9c             	mov    -0x64(%rbp),%edx
 4008620:	8b 45 9c             	mov    -0x64(%rbp),%eax
 4008623:	48 0f af 45 f8       	imul   -0x8(%rbp),%rax
 4008628:	48 89 c1             	mov    %rax,%rcx
 400862b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 400862f:	48 01 c1             	add    %rax,%rcx
 4008632:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
 4008636:	48 89 c6             	mov    %rax,%rsi
 4008639:	48 89 cf             	mov    %rcx,%rdi
 400863c:	e8 e5 fc ff ff       	call   4008326 <ksystemramcpy(void*, void*, unsigned long)>
    for (uint64_t i = 0; i < entryCount; i++) {
 4008641:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
 4008646:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 400864a:	48 3b 45 90          	cmp    -0x70(%rbp),%rax
 400864e:	72 b0                	jb     4008600 <linearTBSerialInsert(unsigned long*, unsigned long, void*, void*, unsigned int, unsigned long)+0xba>
    }
    
    // 更新表项总数
    *TotalEntryCount += entryCount;
 4008650:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 4008654:	48 8b 10             	mov    (%rax),%rdx
 4008657:	48 8b 45 90          	mov    -0x70(%rbp),%rax
 400865b:	48 01 c2             	add    %rax,%rdx
 400865e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
 4008662:	48 89 10             	mov    %rdx,(%rax)
}
 4008665:	90                   	nop
 4008666:	c9                   	leave
 4008667:	c3                   	ret

0000000004008668 <getbit_entry1bit_width(unsigned char (*) [64], unsigned short)>:
bool getbit_entry1bit_width(pgsbitmap_entry1bit_width* bitmap,uint16_t index)
{
 4008668:	55                   	push   %rbp
 4008669:	48 89 e5             	mov    %rsp,%rbp
 400866c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
 4008670:	89 f0                	mov    %esi,%eax
 4008672:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
    uint8_t* map=(uint8_t*)bitmap;
 4008676:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 400867a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    return (map[index>>3]&masks_entry1bit_width[index&7])!=0;
 400867e:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
 4008682:	66 c1 e8 03          	shr    $0x3,%ax
 4008686:	0f b7 d0             	movzwl %ax,%edx
 4008689:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 400868d:	48 01 d0             	add    %rdx,%rax
 4008690:	0f b6 08             	movzbl (%rax),%ecx
 4008693:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
 4008697:	83 e0 07             	and    $0x7,%eax
 400869a:	48 98                	cltq
 400869c:	48 8d 15 25 88 00 00 	lea    0x8825(%rip),%rdx        # 4010ec8 <masks_entry1bit_width>
 40086a3:	0f b6 04 10          	movzbl (%rax,%rdx,1),%eax
 40086a7:	21 c8                	and    %ecx,%eax
 40086a9:	84 c0                	test   %al,%al
 40086ab:	0f 95 c0             	setne  %al
}
 40086ae:	5d                   	pop    %rbp
 40086af:	c3                   	ret

00000000040086b0 <setbit_entry1bit_width(unsigned char (*) [64], bool, unsigned short)>:
void setbit_entry1bit_width(pgsbitmap_entry1bit_width*bitmap,bool value,uint16_t index)
{
 40086b0:	55                   	push   %rbp
 40086b1:	48 89 e5             	mov    %rsp,%rbp
 40086b4:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
 40086b8:	89 f1                	mov    %esi,%ecx
 40086ba:	89 d0                	mov    %edx,%eax
 40086bc:	89 ca                	mov    %ecx,%edx
 40086be:	88 55 e4             	mov    %dl,-0x1c(%rbp)
 40086c1:	66 89 45 e0          	mov    %ax,-0x20(%rbp)
    uint8_t* map=(uint8_t*)bitmap;
 40086c5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 40086c9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    if(value)
 40086cd:	80 7d e4 00          	cmpb   $0x0,-0x1c(%rbp)
 40086d1:	74 43                	je     4008716 <setbit_entry1bit_width(unsigned char (*) [64], bool, unsigned short)+0x66>
        map[index>>3]|=masks_entry1bit_width[index&7];
 40086d3:	0f b7 45 e0          	movzwl -0x20(%rbp),%eax
 40086d7:	66 c1 e8 03          	shr    $0x3,%ax
 40086db:	0f b7 d0             	movzwl %ax,%edx
 40086de:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 40086e2:	48 01 d0             	add    %rdx,%rax
 40086e5:	0f b6 30             	movzbl (%rax),%esi
 40086e8:	0f b7 45 e0          	movzwl -0x20(%rbp),%eax
 40086ec:	83 e0 07             	and    $0x7,%eax
 40086ef:	48 98                	cltq
 40086f1:	48 8d 15 d0 87 00 00 	lea    0x87d0(%rip),%rdx        # 4010ec8 <masks_entry1bit_width>
 40086f8:	0f b6 0c 10          	movzbl (%rax,%rdx,1),%ecx
 40086fc:	0f b7 45 e0          	movzwl -0x20(%rbp),%eax
 4008700:	66 c1 e8 03          	shr    $0x3,%ax
 4008704:	0f b7 d0             	movzwl %ax,%edx
 4008707:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 400870b:	48 01 d0             	add    %rdx,%rax
 400870e:	09 ce                	or     %ecx,%esi
 4008710:	89 f2                	mov    %esi,%edx
 4008712:	88 10                	mov    %dl,(%rax)
    else
        map[index>>3]&=~masks_entry1bit_width[index&7];
}
 4008714:	eb 45                	jmp    400875b <setbit_entry1bit_width(unsigned char (*) [64], bool, unsigned short)+0xab>
        map[index>>3]&=~masks_entry1bit_width[index&7];
 4008716:	0f b7 45 e0          	movzwl -0x20(%rbp),%eax
 400871a:	66 c1 e8 03          	shr    $0x3,%ax
 400871e:	0f b7 d0             	movzwl %ax,%edx
 4008721:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4008725:	48 01 d0             	add    %rdx,%rax
 4008728:	0f b6 00             	movzbl (%rax),%eax
 400872b:	89 c1                	mov    %eax,%ecx
 400872d:	0f b7 45 e0          	movzwl -0x20(%rbp),%eax
 4008731:	83 e0 07             	and    $0x7,%eax
 4008734:	48 98                	cltq
 4008736:	48 8d 15 8b 87 00 00 	lea    0x878b(%rip),%rdx        # 4010ec8 <masks_entry1bit_width>
 400873d:	0f b6 04 10          	movzbl (%rax,%rdx,1),%eax
 4008741:	f7 d0                	not    %eax
 4008743:	21 c1                	and    %eax,%ecx
 4008745:	0f b7 45 e0          	movzwl -0x20(%rbp),%eax
 4008749:	66 c1 e8 03          	shr    $0x3,%ax
 400874d:	0f b7 d0             	movzwl %ax,%edx
 4008750:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4008754:	48 01 d0             	add    %rdx,%rax
 4008757:	89 ca                	mov    %ecx,%edx
 4008759:	88 10                	mov    %dl,(%rax)
}
 400875b:	90                   	nop
 400875c:	5d                   	pop    %rbp
 400875d:	c3                   	ret

000000000400875e <setbits_entry1bit_width(unsigned char (*) [64], bool, unsigned short, unsigned short)>:
void setbits_entry1bit_width(pgsbitmap_entry1bit_width*bitmap,bool value,uint16_t Start_index,uint16_t len_in_bits)
{
 400875e:	55                   	push   %rbp
 400875f:	48 89 e5             	mov    %rsp,%rbp
 4008762:	48 83 ec 48          	sub    $0x48,%rsp
 4008766:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
 400876a:	89 c8                	mov    %ecx,%eax
 400876c:	89 f1                	mov    %esi,%ecx
 400876e:	88 4d c4             	mov    %cl,-0x3c(%rbp)
 4008771:	66 89 55 c0          	mov    %dx,-0x40(%rbp)
 4008775:	66 89 45 bc          	mov    %ax,-0x44(%rbp)
    int bits_left=len_in_bits;
 4008779:	0f b7 45 bc          	movzwl -0x44(%rbp),%eax
 400877d:	89 45 fc             	mov    %eax,-0x4(%rbp)
    uint8_t * map_8bit=(uint8_t*)bitmap;
 4008780:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 4008784:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    uint8_t fillcontent8=value?0xff:0;
 4008788:	80 7d c4 00          	cmpb   $0x0,-0x3c(%rbp)
 400878c:	74 06                	je     4008794 <setbits_entry1bit_width(unsigned char (*) [64], bool, unsigned short, unsigned short)+0x36>
 400878e:	c6 45 fb ff          	movb   $0xff,-0x5(%rbp)
 4008792:	eb 04                	jmp    4008798 <setbits_entry1bit_width(unsigned char (*) [64], bool, unsigned short, unsigned short)+0x3a>
 4008794:	c6 45 fb 00          	movb   $0x0,-0x5(%rbp)
    uint64_t* map_64bit=(uint64_t*)bitmap;
 4008798:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 400879c:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    uint64_t fillcontent64=value?0xffffffffffffffff:0;
 40087a0:	80 7d c4 00          	cmpb   $0x0,-0x3c(%rbp)
 40087a4:	74 0a                	je     40087b0 <setbits_entry1bit_width(unsigned char (*) [64], bool, unsigned short, unsigned short)+0x52>
 40087a6:	48 c7 45 f0 ff ff ff 	movq   $0xffffffffffffffff,-0x10(%rbp)
 40087ad:	ff 
 40087ae:	eb 08                	jmp    40087b8 <setbits_entry1bit_width(unsigned char (*) [64], bool, unsigned short, unsigned short)+0x5a>
 40087b0:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
 40087b7:	00 
    for (int i = Start_index; i < Start_index+len_in_bits; )
 40087b8:	0f b7 45 c0          	movzwl -0x40(%rbp),%eax
 40087bc:	89 45 ec             	mov    %eax,-0x14(%rbp)
 40087bf:	e9 90 00 00 00       	jmp    4008854 <setbits_entry1bit_width(unsigned char (*) [64], bool, unsigned short, unsigned short)+0xf6>
    {
       if (i&63ULL)
 40087c4:	8b 45 ec             	mov    -0x14(%rbp),%eax
 40087c7:	83 e0 3f             	and    $0x3f,%eax
 40087ca:	85 c0                	test   %eax,%eax
 40087cc:	74 5a                	je     4008828 <setbits_entry1bit_width(unsigned char (*) [64], bool, unsigned short, unsigned short)+0xca>
       {
not_aligned_6bits:
 40087ce:	90                   	nop
 40087cf:	eb 01                	jmp    40087d2 <setbits_entry1bit_width(unsigned char (*) [64], bool, unsigned short, unsigned short)+0x74>
            map_64bit[i>>6]=fillcontent64;  
            bits_left-=64;
            i+=64;
        }
        else{
            goto not_aligned_6bits;
 40087d1:	90                   	nop
        if(i&7ULL)
 40087d2:	8b 45 ec             	mov    -0x14(%rbp),%eax
 40087d5:	83 e0 07             	and    $0x7,%eax
 40087d8:	85 c0                	test   %eax,%eax
 40087da:	74 26                	je     4008802 <setbits_entry1bit_width(unsigned char (*) [64], bool, unsigned short, unsigned short)+0xa4>
not_aligned_3bits:            
 40087dc:	90                   	nop
 40087dd:	eb 01                	jmp    40087e0 <setbits_entry1bit_width(unsigned char (*) [64], bool, unsigned short, unsigned short)+0x82>
                goto not_aligned_3bits;
 40087df:	90                   	nop
            setbit_entry1bit_width(bitmap,value,i);
 40087e0:	8b 45 ec             	mov    -0x14(%rbp),%eax
 40087e3:	0f b7 d0             	movzwl %ax,%edx
 40087e6:	0f b6 4d c4          	movzbl -0x3c(%rbp),%ecx
 40087ea:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 40087ee:	89 ce                	mov    %ecx,%esi
 40087f0:	48 89 c7             	mov    %rax,%rdi
 40087f3:	e8 b8 fe ff ff       	call   40086b0 <setbit_entry1bit_width(unsigned char (*) [64], bool, unsigned short)>
            i++;
 40087f8:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
            bits_left--;
 40087fc:	83 6d fc 01          	subl   $0x1,-0x4(%rbp)
 4008800:	eb 52                	jmp    4008854 <setbits_entry1bit_width(unsigned char (*) [64], bool, unsigned short, unsigned short)+0xf6>
            if(bits_left>=8)
 4008802:	83 7d fc 07          	cmpl   $0x7,-0x4(%rbp)
 4008806:	7e d7                	jle    40087df <setbits_entry1bit_width(unsigned char (*) [64], bool, unsigned short, unsigned short)+0x81>
                map_8bit[i>>3]=fillcontent8;
 4008808:	8b 45 ec             	mov    -0x14(%rbp),%eax
 400880b:	c1 f8 03             	sar    $0x3,%eax
 400880e:	48 63 d0             	movslq %eax,%rdx
 4008811:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4008815:	48 01 c2             	add    %rax,%rdx
 4008818:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
 400881c:	88 02                	mov    %al,(%rdx)
                bits_left-=8;
 400881e:	83 6d fc 08          	subl   $0x8,-0x4(%rbp)
                i+=8;
 4008822:	83 45 ec 08          	addl   $0x8,-0x14(%rbp)
 4008826:	eb 2c                	jmp    4008854 <setbits_entry1bit_width(unsigned char (*) [64], bool, unsigned short, unsigned short)+0xf6>
        if(bits_left>=64)
 4008828:	83 7d fc 3f          	cmpl   $0x3f,-0x4(%rbp)
 400882c:	7e a3                	jle    40087d1 <setbits_entry1bit_width(unsigned char (*) [64], bool, unsigned short, unsigned short)+0x73>
            map_64bit[i>>6]=fillcontent64;  
 400882e:	8b 45 ec             	mov    -0x14(%rbp),%eax
 4008831:	c1 f8 06             	sar    $0x6,%eax
 4008834:	48 98                	cltq
 4008836:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
 400883d:	00 
 400883e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4008842:	48 01 c2             	add    %rax,%rdx
 4008845:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 4008849:	48 89 02             	mov    %rax,(%rdx)
            bits_left-=64;
 400884c:	83 6d fc 40          	subl   $0x40,-0x4(%rbp)
            i+=64;
 4008850:	83 45 ec 40          	addl   $0x40,-0x14(%rbp)
    for (int i = Start_index; i < Start_index+len_in_bits; )
 4008854:	0f b7 55 c0          	movzwl -0x40(%rbp),%edx
 4008858:	0f b7 45 bc          	movzwl -0x44(%rbp),%eax
 400885c:	01 d0                	add    %edx,%eax
 400885e:	39 45 ec             	cmp    %eax,-0x14(%rbp)
 4008861:	0f 8c 5d ff ff ff    	jl     40087c4 <setbits_entry1bit_width(unsigned char (*) [64], bool, unsigned short, unsigned short)+0x66>
        }
       }  
    }
}
 4008867:	90                   	nop
 4008868:	90                   	nop
 4008869:	c9                   	leave
 400886a:	c3                   	ret

000000000400886b <getentry_entry2bits_width(unsigned char (&) [128], unsigned short)>:
// 获取2bit宽度位图中指定索引的值（返回0-3）
uint8_t getentry_entry2bits_width(pgsbitmap_entry2bits_width& bitmap, uint16_t index) {
 400886b:	55                   	push   %rbp
 400886c:	48 89 e5             	mov    %rsp,%rbp
 400886f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
 4008873:	89 f0                	mov    %esi,%eax
 4008875:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
    uint8_t byte = bitmap[index >> 2];  // 每个字节包含4个2bit条目
 4008879:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
 400887d:	66 c1 e8 02          	shr    $0x2,%ax
 4008881:	0f b7 c0             	movzwl %ax,%eax
 4008884:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
 4008888:	48 98                	cltq
 400888a:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
 400888e:	88 45 ff             	mov    %al,-0x1(%rbp)
    uint8_t shift = (index & 3) * 2;    // 计算在字节内的偏移（0,2,4,6）
 4008891:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
 4008895:	83 e0 03             	and    $0x3,%eax
 4008898:	01 c0                	add    %eax,%eax
 400889a:	88 45 fe             	mov    %al,-0x2(%rbp)
    return (byte >> shift) & 3;         // 提取2bit值
 400889d:	0f b6 55 ff          	movzbl -0x1(%rbp),%edx
 40088a1:	0f b6 45 fe          	movzbl -0x2(%rbp),%eax
 40088a5:	89 c1                	mov    %eax,%ecx
 40088a7:	d3 fa                	sar    %cl,%edx
 40088a9:	89 d0                	mov    %edx,%eax
 40088ab:	83 e0 03             	and    $0x3,%eax
}
 40088ae:	5d                   	pop    %rbp
 40088af:	c3                   	ret

00000000040088b0 <setentry_entry2bits_width(unsigned char (&) [128], unsigned char, unsigned short)>:

// 设置2bit宽度位图中指定索引的值
void setentry_entry2bits_width(pgsbitmap_entry2bits_width& bitmap, uint8_t value, uint16_t index) {
 40088b0:	55                   	push   %rbp
 40088b1:	48 89 e5             	mov    %rsp,%rbp
 40088b4:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
 40088b8:	89 f1                	mov    %esi,%ecx
 40088ba:	89 d0                	mov    %edx,%eax
 40088bc:	89 ca                	mov    %ecx,%edx
 40088be:	88 55 e4             	mov    %dl,-0x1c(%rbp)
 40088c1:	66 89 45 e0          	mov    %ax,-0x20(%rbp)
    uint8_t& byte = bitmap[index >> 2];     // 获取对应的字节引用
 40088c5:	0f b7 45 e0          	movzwl -0x20(%rbp),%eax
 40088c9:	66 c1 e8 02          	shr    $0x2,%ax
 40088cd:	0f b7 c0             	movzwl %ax,%eax
 40088d0:	48 63 d0             	movslq %eax,%rdx
 40088d3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 40088d7:	48 01 d0             	add    %rdx,%rax
 40088da:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    uint8_t shift = (index & 3) * 2;        // 计算偏移量
 40088de:	0f b7 45 e0          	movzwl -0x20(%rbp),%eax
 40088e2:	83 e0 03             	and    $0x3,%eax
 40088e5:	01 c0                	add    %eax,%eax
 40088e7:	88 45 f7             	mov    %al,-0x9(%rbp)
    byte = (byte & ~(3 << shift)) |         // 清除原有值
 40088ea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 40088ee:	0f b6 00             	movzbl (%rax),%eax
 40088f1:	89 c6                	mov    %eax,%esi
 40088f3:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
 40088f7:	ba 03 00 00 00       	mov    $0x3,%edx
 40088fc:	89 c1                	mov    %eax,%ecx
 40088fe:	d3 e2                	shl    %cl,%edx
 4008900:	89 d0                	mov    %edx,%eax
 4008902:	f7 d0                	not    %eax
 4008904:	21 c6                	and    %eax,%esi
           ((value & 3) << shift);          // 设置新值
 4008906:	0f b6 45 e4          	movzbl -0x1c(%rbp),%eax
 400890a:	83 e0 03             	and    $0x3,%eax
 400890d:	89 c2                	mov    %eax,%edx
 400890f:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
 4008913:	89 c1                	mov    %eax,%ecx
 4008915:	d3 e2                	shl    %cl,%edx
 4008917:	89 d0                	mov    %edx,%eax
    byte = (byte & ~(3 << shift)) |         // 清除原有值
 4008919:	09 f0                	or     %esi,%eax
 400891b:	89 c2                	mov    %eax,%edx
 400891d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4008921:	88 10                	mov    %dl,(%rax)
}
 4008923:	90                   	nop
 4008924:	5d                   	pop    %rbp
 4008925:	c3                   	ret

0000000004008926 <setentries_entry2bits_width(unsigned char (&) [128], unsigned char, unsigned short, unsigned short)>:

// 设置2bit宽度位图中连续多个条目的值
// 优化后的批量设置2bit宽度位图函数
void setentries_entry2bits_width(pgsbitmap_entry2bits_width& bitmap, uint8_t value, uint16_t start_index, uint16_t len_in_entries) {
 4008926:	55                   	push   %rbp
 4008927:	48 89 e5             	mov    %rsp,%rbp
 400892a:	48 83 ec 38          	sub    $0x38,%rsp
 400892e:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
 4008932:	89 c8                	mov    %ecx,%eax
 4008934:	89 f1                	mov    %esi,%ecx
 4008936:	88 4d d4             	mov    %cl,-0x2c(%rbp)
 4008939:	66 89 55 d0          	mov    %dx,-0x30(%rbp)
 400893d:	66 89 45 cc          	mov    %ax,-0x34(%rbp)
    value &= 3;  // 确保值在0-3范围内
 4008941:	80 65 d4 03          	andb   $0x3,-0x2c(%rbp)
    
    // 创建64位填充模式（每个2bit都是value）
    uint64_t fillpattern = 0;
 4008945:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
 400894c:	00 
    for (int i = 0; i < 32; i++) {  // 64位可容纳32个2bit条目
 400894d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
 4008954:	eb 19                	jmp    400896f <setentries_entry2bits_width(unsigned char (&) [128], unsigned char, unsigned short, unsigned short)+0x49>
        fillpattern |= (static_cast<uint64_t>(value) << (i * 2));
 4008956:	0f b6 55 d4          	movzbl -0x2c(%rbp),%edx
 400895a:	8b 45 f4             	mov    -0xc(%rbp),%eax
 400895d:	01 c0                	add    %eax,%eax
 400895f:	89 c1                	mov    %eax,%ecx
 4008961:	48 d3 e2             	shl    %cl,%rdx
 4008964:	48 89 d0             	mov    %rdx,%rax
 4008967:	48 09 45 f8          	or     %rax,-0x8(%rbp)
    for (int i = 0; i < 32; i++) {  // 64位可容纳32个2bit条目
 400896b:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
 400896f:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%rbp)
 4008973:	7e e1                	jle    4008956 <setentries_entry2bits_width(unsigned char (&) [128], unsigned char, unsigned short, unsigned short)+0x30>
    }
    
    uint16_t i = start_index;
 4008975:	0f b7 45 d0          	movzwl -0x30(%rbp),%eax
 4008979:	66 89 45 f2          	mov    %ax,-0xe(%rbp)
    uint16_t end_index = start_index + len_in_entries;
 400897d:	0f b7 55 d0          	movzwl -0x30(%rbp),%edx
 4008981:	0f b7 45 cc          	movzwl -0x34(%rbp),%eax
 4008985:	01 d0                	add    %edx,%eax
 4008987:	66 89 45 e6          	mov    %ax,-0x1a(%rbp)
    
    // 处理起始未对齐部分（按单个条目设置）
    while (i < end_index && (i & 31)) {
 400898b:	eb 21                	jmp    40089ae <setentries_entry2bits_width(unsigned char (&) [128], unsigned char, unsigned short, unsigned short)+0x88>
        setentry_entry2bits_width(bitmap, value, i);
 400898d:	0f b7 55 f2          	movzwl -0xe(%rbp),%edx
 4008991:	0f b6 4d d4          	movzbl -0x2c(%rbp),%ecx
 4008995:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4008999:	89 ce                	mov    %ecx,%esi
 400899b:	48 89 c7             	mov    %rax,%rdi
 400899e:	e8 0d ff ff ff       	call   40088b0 <setentry_entry2bits_width(unsigned char (&) [128], unsigned char, unsigned short)>
        i++;
 40089a3:	0f b7 45 f2          	movzwl -0xe(%rbp),%eax
 40089a7:	83 c0 01             	add    $0x1,%eax
 40089aa:	66 89 45 f2          	mov    %ax,-0xe(%rbp)
    while (i < end_index && (i & 31)) {
 40089ae:	0f b7 45 f2          	movzwl -0xe(%rbp),%eax
 40089b2:	66 3b 45 e6          	cmp    -0x1a(%rbp),%ax
 40089b6:	73 0b                	jae    40089c3 <setentries_entry2bits_width(unsigned char (&) [128], unsigned char, unsigned short, unsigned short)+0x9d>
 40089b8:	0f b7 45 f2          	movzwl -0xe(%rbp),%eax
 40089bc:	83 e0 1f             	and    $0x1f,%eax
 40089bf:	85 c0                	test   %eax,%eax
 40089c1:	75 ca                	jne    400898d <setentries_entry2bits_width(unsigned char (&) [128], unsigned char, unsigned short, unsigned short)+0x67>
    }
    
    // 处理中间对齐部分（按64位块设置，每次设置32个条目）
    uint64_t* map_64bit = reinterpret_cast<uint64_t*>(&bitmap[i >> 2]);
 40089c3:	0f b7 45 f2          	movzwl -0xe(%rbp),%eax
 40089c7:	66 c1 e8 02          	shr    $0x2,%ax
 40089cb:	0f b7 c0             	movzwl %ax,%eax
 40089ce:	48 63 d0             	movslq %eax,%rdx
 40089d1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 40089d5:	48 01 d0             	add    %rdx,%rax
 40089d8:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    while (i + 31 < end_index) {
 40089dc:	eb 18                	jmp    40089f6 <setentries_entry2bits_width(unsigned char (&) [128], unsigned char, unsigned short, unsigned short)+0xd0>
        *map_64bit++ = fillpattern;
 40089de:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
 40089e2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 40089e6:	48 8d 48 08          	lea    0x8(%rax),%rcx
 40089ea:	48 89 4d e8          	mov    %rcx,-0x18(%rbp)
 40089ee:	48 89 10             	mov    %rdx,(%rax)
        i += 32;
 40089f1:	66 83 45 f2 20       	addw   $0x20,-0xe(%rbp)
    while (i + 31 < end_index) {
 40089f6:	0f b7 45 f2          	movzwl -0xe(%rbp),%eax
 40089fa:	8d 50 1f             	lea    0x1f(%rax),%edx
 40089fd:	0f b7 45 e6          	movzwl -0x1a(%rbp),%eax
 4008a01:	39 c2                	cmp    %eax,%edx
 4008a03:	7c d9                	jl     40089de <setentries_entry2bits_width(unsigned char (&) [128], unsigned char, unsigned short, unsigned short)+0xb8>
    }
    
    // 处理剩余未对齐部分（按单个条目设置）
    while (i < end_index) {
 4008a05:	eb 21                	jmp    4008a28 <setentries_entry2bits_width(unsigned char (&) [128], unsigned char, unsigned short, unsigned short)+0x102>
        setentry_entry2bits_width(bitmap, value, i);
 4008a07:	0f b7 55 f2          	movzwl -0xe(%rbp),%edx
 4008a0b:	0f b6 4d d4          	movzbl -0x2c(%rbp),%ecx
 4008a0f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4008a13:	89 ce                	mov    %ecx,%esi
 4008a15:	48 89 c7             	mov    %rax,%rdi
 4008a18:	e8 93 fe ff ff       	call   40088b0 <setentry_entry2bits_width(unsigned char (&) [128], unsigned char, unsigned short)>
        i++;
 4008a1d:	0f b7 45 f2          	movzwl -0xe(%rbp),%eax
 4008a21:	83 c0 01             	add    $0x1,%eax
 4008a24:	66 89 45 f2          	mov    %ax,-0xe(%rbp)
    while (i < end_index) {
 4008a28:	0f b7 45 f2          	movzwl -0xe(%rbp),%eax
 4008a2c:	66 3b 45 e6          	cmp    -0x1a(%rbp),%ax
 4008a30:	72 d5                	jb     4008a07 <setentries_entry2bits_width(unsigned char (&) [128], unsigned char, unsigned short, unsigned short)+0xe1>
    }
 4008a32:	90                   	nop
 4008a33:	90                   	nop
 4008a34:	c9                   	leave
 4008a35:	c3                   	ret

0000000004008a36 <drawpixel(int, int, unsigned int)>:
static inline void drawpixel(int x,int y,UINT32 PixelData)
/*理论上只支持PixelBlueGreenRedReserved8BitPerColor像素格式
实际上只要单个像素函数符合32位像素格式，那么其他像素格式都可以位像素格式即可
*/

{
 4008a36:	55                   	push   %rbp
 4008a37:	48 89 e5             	mov    %rsp,%rbp
 4008a3a:	89 7d ec             	mov    %edi,-0x14(%rbp)
 4008a3d:	89 75 e8             	mov    %esi,-0x18(%rbp)
 4008a40:	89 55 e4             	mov    %edx,-0x1c(%rbp)
   UINT32* pixel=(UINT32*)GlobalBasicGraphicInfo.FrameBufferBase+x+y*GlobalBasicGraphicInfo.PixelsPerScanLine;
 4008a43:	8b 45 ec             	mov    -0x14(%rbp),%eax
 4008a46:	48 63 c8             	movslq %eax,%rcx
 4008a49:	8b 15 dd 67 80 00    	mov    0x8067dd(%rip),%edx        # 480f22c <GlobalBasicGraphicInfo+0xc>
 4008a4f:	8b 45 e8             	mov    -0x18(%rbp),%eax
 4008a52:	0f af c2             	imul   %edx,%eax
 4008a55:	89 c0                	mov    %eax,%eax
 4008a57:	48 01 c8             	add    %rcx,%rax
 4008a5a:	48 8d 14 85 00 00 00 	lea    0x0(,%rax,4),%rdx
 4008a61:	00 
 4008a62:	48 8b 05 c7 67 80 00 	mov    0x8067c7(%rip),%rax        # 480f230 <GlobalBasicGraphicInfo+0x10>
 4008a69:	48 01 d0             	add    %rdx,%rax
 4008a6c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    *pixel=PixelData;
 4008a70:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4008a74:	8b 55 e4             	mov    -0x1c(%rbp),%edx
 4008a77:	89 10                	mov    %edx,(%rax)
}
 4008a79:	90                   	nop
 4008a7a:	5d                   	pop    %rbp
 4008a7b:	c3                   	ret

0000000004008a7c <getpixel(int, int)>:
static inline UINT32 getpixel(
    int x,
    int y
)
{
 4008a7c:	55                   	push   %rbp
 4008a7d:	48 89 e5             	mov    %rsp,%rbp
 4008a80:	89 7d ec             	mov    %edi,-0x14(%rbp)
 4008a83:	89 75 e8             	mov    %esi,-0x18(%rbp)
    UINT32* pixel=(UINT32*)GlobalBasicGraphicInfo.FrameBufferBase+x+y*GlobalBasicGraphicInfo.PixelsPerScanLine;
 4008a86:	8b 45 ec             	mov    -0x14(%rbp),%eax
 4008a89:	48 63 c8             	movslq %eax,%rcx
 4008a8c:	8b 15 9a 67 80 00    	mov    0x80679a(%rip),%edx        # 480f22c <GlobalBasicGraphicInfo+0xc>
 4008a92:	8b 45 e8             	mov    -0x18(%rbp),%eax
 4008a95:	0f af c2             	imul   %edx,%eax
 4008a98:	89 c0                	mov    %eax,%eax
 4008a9a:	48 01 c8             	add    %rcx,%rax
 4008a9d:	48 8d 14 85 00 00 00 	lea    0x0(,%rax,4),%rdx
 4008aa4:	00 
 4008aa5:	48 8b 05 84 67 80 00 	mov    0x806784(%rip),%rax        # 480f230 <GlobalBasicGraphicInfo+0x10>
 4008aac:	48 01 d0             	add    %rdx,%rax
 4008aaf:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    return *pixel;
 4008ab3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4008ab7:	8b 00                	mov    (%rax),%eax
}
 4008ab9:	5d                   	pop    %rbp
 4008aba:	c3                   	ret

0000000004008abb <DrawHorizentalLine(unsigned int, unsigned int, int, unsigned int)>:
    UINT32 start_vector_y,
    int length,
    UINT32 PixelData
)

{  
 4008abb:	55                   	push   %rbp
 4008abc:	48 89 e5             	mov    %rsp,%rbp
 4008abf:	48 83 ec 20          	sub    $0x20,%rsp
 4008ac3:	89 7d ec             	mov    %edi,-0x14(%rbp)
 4008ac6:	89 75 e8             	mov    %esi,-0x18(%rbp)
 4008ac9:	89 55 e4             	mov    %edx,-0x1c(%rbp)
 4008acc:	89 4d e0             	mov    %ecx,-0x20(%rbp)
    if(length<=0)
 4008acf:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
 4008ad3:	7f 30                	jg     4008b05 <DrawHorizentalLine(unsigned int, unsigned int, int, unsigned int)+0x4a>
    {
        for (int i = 0; i > length; i--)
 4008ad5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
 4008adc:	eb 1d                	jmp    4008afb <DrawHorizentalLine(unsigned int, unsigned int, int, unsigned int)+0x40>
        {
            drawpixel(start_vector_x+i,start_vector_y,PixelData);
 4008ade:	8b 45 e8             	mov    -0x18(%rbp),%eax
 4008ae1:	8b 4d fc             	mov    -0x4(%rbp),%ecx
 4008ae4:	8b 55 ec             	mov    -0x14(%rbp),%edx
 4008ae7:	01 ca                	add    %ecx,%edx
 4008ae9:	89 d1                	mov    %edx,%ecx
 4008aeb:	8b 55 e0             	mov    -0x20(%rbp),%edx
 4008aee:	89 c6                	mov    %eax,%esi
 4008af0:	89 cf                	mov    %ecx,%edi
 4008af2:	e8 3f ff ff ff       	call   4008a36 <drawpixel(int, int, unsigned int)>
        for (int i = 0; i > length; i--)
 4008af7:	83 6d fc 01          	subl   $0x1,-0x4(%rbp)
 4008afb:	8b 45 fc             	mov    -0x4(%rbp),%eax
 4008afe:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
 4008b01:	7f db                	jg     4008ade <DrawHorizentalLine(unsigned int, unsigned int, int, unsigned int)+0x23>
    {
        drawpixel(start_vector_x+i,start_vector_y,PixelData);
    }
    }
    
}
 4008b03:	eb 2e                	jmp    4008b33 <DrawHorizentalLine(unsigned int, unsigned int, int, unsigned int)+0x78>
        for(int i=0;i<length;i++)
 4008b05:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
 4008b0c:	eb 1d                	jmp    4008b2b <DrawHorizentalLine(unsigned int, unsigned int, int, unsigned int)+0x70>
        drawpixel(start_vector_x+i,start_vector_y,PixelData);
 4008b0e:	8b 45 e8             	mov    -0x18(%rbp),%eax
 4008b11:	8b 4d f8             	mov    -0x8(%rbp),%ecx
 4008b14:	8b 55 ec             	mov    -0x14(%rbp),%edx
 4008b17:	01 ca                	add    %ecx,%edx
 4008b19:	89 d1                	mov    %edx,%ecx
 4008b1b:	8b 55 e0             	mov    -0x20(%rbp),%edx
 4008b1e:	89 c6                	mov    %eax,%esi
 4008b20:	89 cf                	mov    %ecx,%edi
 4008b22:	e8 0f ff ff ff       	call   4008a36 <drawpixel(int, int, unsigned int)>
        for(int i=0;i<length;i++)
 4008b27:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
 4008b2b:	8b 45 f8             	mov    -0x8(%rbp),%eax
 4008b2e:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
 4008b31:	7c db                	jl     4008b0e <DrawHorizentalLine(unsigned int, unsigned int, int, unsigned int)+0x53>
}
 4008b33:	90                   	nop
 4008b34:	c9                   	leave
 4008b35:	c3                   	ret

0000000004008b36 <FillRectangle(unsigned int, unsigned int, int, int, unsigned int)>:
    UINT32 start_vector_y,
    int width,
    int height,
    UINT32 PixelData
)
{   
 4008b36:	55                   	push   %rbp
 4008b37:	48 89 e5             	mov    %rsp,%rbp
 4008b3a:	48 83 ec 28          	sub    $0x28,%rsp
 4008b3e:	89 7d ec             	mov    %edi,-0x14(%rbp)
 4008b41:	89 75 e8             	mov    %esi,-0x18(%rbp)
 4008b44:	89 55 e4             	mov    %edx,-0x1c(%rbp)
 4008b47:	89 4d e0             	mov    %ecx,-0x20(%rbp)
 4008b4a:	44 89 45 dc          	mov    %r8d,-0x24(%rbp)
    if(height>0){
 4008b4e:	83 7d e0 00          	cmpl   $0x0,-0x20(%rbp)
 4008b52:	7e 30                	jle    4008b84 <FillRectangle(unsigned int, unsigned int, int, int, unsigned int)+0x4e>
    for (int i = 0; i < height; i++)
 4008b54:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
 4008b5b:	eb 1d                	jmp    4008b7a <FillRectangle(unsigned int, unsigned int, int, int, unsigned int)+0x44>
    {
        DrawHorizentalLine(start_vector_x, start_vector_y + i, width, PixelData);
 4008b5d:	8b 55 fc             	mov    -0x4(%rbp),%edx
 4008b60:	8b 45 e8             	mov    -0x18(%rbp),%eax
 4008b63:	8d 34 02             	lea    (%rdx,%rax,1),%esi
 4008b66:	8b 4d dc             	mov    -0x24(%rbp),%ecx
 4008b69:	8b 55 e4             	mov    -0x1c(%rbp),%edx
 4008b6c:	8b 45 ec             	mov    -0x14(%rbp),%eax
 4008b6f:	89 c7                	mov    %eax,%edi
 4008b71:	e8 45 ff ff ff       	call   4008abb <DrawHorizentalLine(unsigned int, unsigned int, int, unsigned int)>
    for (int i = 0; i < height; i++)
 4008b76:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
 4008b7a:	8b 45 fc             	mov    -0x4(%rbp),%eax
 4008b7d:	3b 45 e0             	cmp    -0x20(%rbp),%eax
 4008b80:	7c db                	jl     4008b5d <FillRectangle(unsigned int, unsigned int, int, int, unsigned int)+0x27>
        {
            DrawHorizentalLine(start_vector_x+i, start_vector_y, width, PixelData);
        }
        
    }
}
 4008b82:	eb 2e                	jmp    4008bb2 <FillRectangle(unsigned int, unsigned int, int, int, unsigned int)+0x7c>
        for (int i = 0; i >width; i--)
 4008b84:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
 4008b8b:	eb 1d                	jmp    4008baa <FillRectangle(unsigned int, unsigned int, int, int, unsigned int)+0x74>
            DrawHorizentalLine(start_vector_x+i, start_vector_y, width, PixelData);
 4008b8d:	8b 55 f8             	mov    -0x8(%rbp),%edx
 4008b90:	8b 45 ec             	mov    -0x14(%rbp),%eax
 4008b93:	8d 3c 02             	lea    (%rdx,%rax,1),%edi
 4008b96:	8b 4d dc             	mov    -0x24(%rbp),%ecx
 4008b99:	8b 55 e4             	mov    -0x1c(%rbp),%edx
 4008b9c:	8b 45 e8             	mov    -0x18(%rbp),%eax
 4008b9f:	89 c6                	mov    %eax,%esi
 4008ba1:	e8 15 ff ff ff       	call   4008abb <DrawHorizentalLine(unsigned int, unsigned int, int, unsigned int)>
        for (int i = 0; i >width; i--)
 4008ba6:	83 6d f8 01          	subl   $0x1,-0x8(%rbp)
 4008baa:	8b 45 f8             	mov    -0x8(%rbp),%eax
 4008bad:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
 4008bb0:	7f db                	jg     4008b8d <FillRectangle(unsigned int, unsigned int, int, int, unsigned int)+0x57>
}
 4008bb2:	90                   	nop
 4008bb3:	c9                   	leave
 4008bb4:	c3                   	ret

0000000004008bb5 <kernelshellclearScreenInternal()>:
static inline void kernelshellclearScreenInternal()
{
 4008bb5:	55                   	push   %rbp
 4008bb6:	48 89 e5             	mov    %rsp,%rbp
    FillRectangle(0, 0, 
 4008bb9:	8b 05 b9 66 80 00    	mov    0x8066b9(%rip),%eax        # 480f278 <KernelShellController+0x38>
                  GlobalBasicGraphicInfo.horizentalResolution, 
                  GlobalBasicGraphicInfo.verticalResolution, 
 4008bbf:	8b 15 5f 66 80 00    	mov    0x80665f(%rip),%edx        # 480f224 <GlobalBasicGraphicInfo+0x4>
    FillRectangle(0, 0, 
 4008bc5:	89 d1                	mov    %edx,%ecx
                  GlobalBasicGraphicInfo.horizentalResolution, 
 4008bc7:	8b 15 53 66 80 00    	mov    0x806653(%rip),%edx        # 480f220 <GlobalBasicGraphicInfo>
    FillRectangle(0, 0, 
 4008bcd:	41 89 c0             	mov    %eax,%r8d
 4008bd0:	be 00 00 00 00       	mov    $0x0,%esi
 4008bd5:	bf 00 00 00 00       	mov    $0x0,%edi
 4008bda:	e8 57 ff ff ff       	call   4008b36 <FillRectangle(unsigned int, unsigned int, int, int, unsigned int)>
                  KernelShellController.UnrenderedSpaceColor);
    KernelShellController.CharacterBeginX = 0;
 4008bdf:	66 c7 05 98 66 80 00 	movw   $0x0,0x806698(%rip)        # 480f280 <KernelShellController+0x40>
 4008be6:	00 00 
    KernelShellController.CharacterBeginY = 0;
 4008be8:	66 c7 05 91 66 80 00 	movw   $0x0,0x806691(%rip)        # 480f282 <KernelShellController+0x42>
 4008bef:	00 00 
    KernelShellController.ScreenModeFlag &= 0xFFFFFFFE;
 4008bf1:	8b 05 79 66 80 00    	mov    0x806679(%rip),%eax        # 480f270 <KernelShellController+0x30>
 4008bf7:	83 e0 fe             	and    $0xfffffffe,%eax
 4008bfa:	89 05 70 66 80 00    	mov    %eax,0x806670(%rip)        # 480f270 <KernelShellController+0x30>
}
 4008c00:	90                   	nop
 4008c01:	5d                   	pop    %rbp
 4008c02:	c3                   	ret

0000000004008c03 <drawKernelShellBorderInternal()>:

// 2. 渲染边框内部接口
static inline void drawKernelShellBorderInternal()
{
 4008c03:	55                   	push   %rbp
 4008c04:	48 89 e5             	mov    %rsp,%rbp
 4008c07:	48 83 ec 10          	sub    $0x10,%rsp
    // 解包边距值
    UINT16 topMargin = KernelShellController.TopMargin;
 4008c0b:	0f b7 05 36 66 80 00 	movzwl 0x806636(%rip),%eax        # 480f248 <KernelShellController+0x8>
 4008c12:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
    UINT16 bottomMargin = KernelShellController.BottomMargin;
 4008c16:	0f b7 05 2d 66 80 00 	movzwl 0x80662d(%rip),%eax        # 480f24a <KernelShellController+0xa>
 4008c1d:	66 89 45 fc          	mov    %ax,-0x4(%rbp)
    UINT16 leftMargin = KernelShellController.LeftMargin;
 4008c21:	0f b7 05 24 66 80 00 	movzwl 0x806624(%rip),%eax        # 480f24c <KernelShellController+0xc>
 4008c28:	66 89 45 fa          	mov    %ax,-0x6(%rbp)
    UINT16 rightMargin = KernelShellController.RightMargin;
 4008c2c:	0f b7 05 1b 66 80 00 	movzwl 0x80661b(%rip),%eax        # 480f24e <KernelShellController+0xe>
 4008c33:	66 89 45 f8          	mov    %ax,-0x8(%rbp)
    
    // 绘制上边框
    FillRectangle(KernelShellController.WindowBeginX,
 4008c37:	8b 3d 37 66 80 00    	mov    0x806637(%rip),%edi        # 480f274 <KernelShellController+0x34>
 4008c3d:	0f b7 4d fe          	movzwl -0x2(%rbp),%ecx
                  KernelShellController.WindowBeginY,
                  KernelShellController.WindowWidth,
 4008c41:	0f b7 05 fa 65 80 00 	movzwl 0x8065fa(%rip),%eax        # 480f242 <KernelShellController+0x2>
    FillRectangle(KernelShellController.WindowBeginX,
 4008c48:	0f b7 d0             	movzwl %ax,%edx
                  KernelShellController.WindowBeginY,
 4008c4b:	0f b7 05 2c 66 80 00 	movzwl 0x80662c(%rip),%eax        # 480f27e <KernelShellController+0x3e>
    FillRectangle(KernelShellController.WindowBeginX,
 4008c52:	0f b7 f0             	movzwl %ax,%esi
 4008c55:	0f b7 05 20 66 80 00 	movzwl 0x806620(%rip),%eax        # 480f27c <KernelShellController+0x3c>
 4008c5c:	0f b7 c0             	movzwl %ax,%eax
 4008c5f:	41 89 f8             	mov    %edi,%r8d
 4008c62:	89 c7                	mov    %eax,%edi
 4008c64:	e8 cd fe ff ff       	call   4008b36 <FillRectangle(unsigned int, unsigned int, int, int, unsigned int)>
                  topMargin,
                  KernelShellController.MarginColor);
    
    // 绘制下边框
    FillRectangle(KernelShellController.WindowBeginX,
 4008c69:	8b 3d 05 66 80 00    	mov    0x806605(%rip),%edi        # 480f274 <KernelShellController+0x34>
 4008c6f:	0f b7 4d fc          	movzwl -0x4(%rbp),%ecx
                  KernelShellController.WindowBeginY + KernelShellController.WindowHeight - bottomMargin,
                  KernelShellController.WindowWidth,
 4008c73:	0f b7 05 c8 65 80 00 	movzwl 0x8065c8(%rip),%eax        # 480f242 <KernelShellController+0x2>
    FillRectangle(KernelShellController.WindowBeginX,
 4008c7a:	0f b7 d0             	movzwl %ax,%edx
                  KernelShellController.WindowBeginY + KernelShellController.WindowHeight - bottomMargin,
 4008c7d:	0f b7 05 fa 65 80 00 	movzwl 0x8065fa(%rip),%eax        # 480f27e <KernelShellController+0x3e>
 4008c84:	0f b7 f0             	movzwl %ax,%esi
 4008c87:	0f b7 05 b2 65 80 00 	movzwl 0x8065b2(%rip),%eax        # 480f240 <KernelShellController>
 4008c8e:	0f b7 c0             	movzwl %ax,%eax
 4008c91:	01 c6                	add    %eax,%esi
 4008c93:	0f b7 45 fc          	movzwl -0x4(%rbp),%eax
 4008c97:	29 c6                	sub    %eax,%esi
    FillRectangle(KernelShellController.WindowBeginX,
 4008c99:	0f b7 05 dc 65 80 00 	movzwl 0x8065dc(%rip),%eax        # 480f27c <KernelShellController+0x3c>
 4008ca0:	0f b7 c0             	movzwl %ax,%eax
 4008ca3:	41 89 f8             	mov    %edi,%r8d
 4008ca6:	89 c7                	mov    %eax,%edi
 4008ca8:	e8 89 fe ff ff       	call   4008b36 <FillRectangle(unsigned int, unsigned int, int, int, unsigned int)>
                  bottomMargin,
                  KernelShellController.MarginColor);
    
    // 绘制左边框
    FillRectangle(KernelShellController.WindowBeginX,
 4008cad:	8b 3d c1 65 80 00    	mov    0x8065c1(%rip),%edi        # 480f274 <KernelShellController+0x34>
                  KernelShellController.WindowBeginY + topMargin,
                  leftMargin,
                  KernelShellController.WindowHeight - topMargin - bottomMargin,
 4008cb3:	0f b7 05 86 65 80 00 	movzwl 0x806586(%rip),%eax        # 480f240 <KernelShellController>
 4008cba:	0f b7 d0             	movzwl %ax,%edx
 4008cbd:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
 4008cc1:	29 c2                	sub    %eax,%edx
 4008cc3:	0f b7 45 fc          	movzwl -0x4(%rbp),%eax
    FillRectangle(KernelShellController.WindowBeginX,
 4008cc7:	29 c2                	sub    %eax,%edx
 4008cc9:	89 d1                	mov    %edx,%ecx
 4008ccb:	0f b7 55 fa          	movzwl -0x6(%rbp),%edx
                  KernelShellController.WindowBeginY + topMargin,
 4008ccf:	0f b7 05 a8 65 80 00 	movzwl 0x8065a8(%rip),%eax        # 480f27e <KernelShellController+0x3e>
 4008cd6:	0f b7 f0             	movzwl %ax,%esi
 4008cd9:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
 4008cdd:	01 f0                	add    %esi,%eax
    FillRectangle(KernelShellController.WindowBeginX,
 4008cdf:	89 c6                	mov    %eax,%esi
 4008ce1:	0f b7 05 94 65 80 00 	movzwl 0x806594(%rip),%eax        # 480f27c <KernelShellController+0x3c>
 4008ce8:	0f b7 c0             	movzwl %ax,%eax
 4008ceb:	41 89 f8             	mov    %edi,%r8d
 4008cee:	89 c7                	mov    %eax,%edi
 4008cf0:	e8 41 fe ff ff       	call   4008b36 <FillRectangle(unsigned int, unsigned int, int, int, unsigned int)>
                  KernelShellController.MarginColor);
    
    // 绘制右边框
    FillRectangle(KernelShellController.WindowBeginX + KernelShellController.WindowWidth - rightMargin,
 4008cf5:	8b 3d 79 65 80 00    	mov    0x806579(%rip),%edi        # 480f274 <KernelShellController+0x34>
                  KernelShellController.WindowBeginY + topMargin,
                  rightMargin,
                  KernelShellController.WindowHeight - topMargin - bottomMargin,
 4008cfb:	0f b7 05 3e 65 80 00 	movzwl 0x80653e(%rip),%eax        # 480f240 <KernelShellController>
 4008d02:	0f b7 d0             	movzwl %ax,%edx
 4008d05:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
 4008d09:	29 c2                	sub    %eax,%edx
 4008d0b:	0f b7 45 fc          	movzwl -0x4(%rbp),%eax
    FillRectangle(KernelShellController.WindowBeginX + KernelShellController.WindowWidth - rightMargin,
 4008d0f:	29 c2                	sub    %eax,%edx
 4008d11:	0f b7 45 f8          	movzwl -0x8(%rbp),%eax
                  KernelShellController.WindowBeginY + topMargin,
 4008d15:	0f b7 0d 62 65 80 00 	movzwl 0x806562(%rip),%ecx        # 480f27e <KernelShellController+0x3e>
 4008d1c:	0f b7 f1             	movzwl %cx,%esi
 4008d1f:	0f b7 4d fe          	movzwl -0x2(%rbp),%ecx
 4008d23:	01 f1                	add    %esi,%ecx
    FillRectangle(KernelShellController.WindowBeginX + KernelShellController.WindowWidth - rightMargin,
 4008d25:	41 89 ca             	mov    %ecx,%r10d
 4008d28:	0f b7 0d 4d 65 80 00 	movzwl 0x80654d(%rip),%ecx        # 480f27c <KernelShellController+0x3c>
 4008d2f:	0f b7 f1             	movzwl %cx,%esi
 4008d32:	0f b7 0d 09 65 80 00 	movzwl 0x806509(%rip),%ecx        # 480f242 <KernelShellController+0x2>
 4008d39:	0f b7 c9             	movzwl %cx,%ecx
 4008d3c:	01 ce                	add    %ecx,%esi
 4008d3e:	0f b7 4d f8          	movzwl -0x8(%rbp),%ecx
 4008d42:	29 ce                	sub    %ecx,%esi
 4008d44:	41 89 f1             	mov    %esi,%r9d
 4008d47:	41 89 f8             	mov    %edi,%r8d
 4008d4a:	89 d1                	mov    %edx,%ecx
 4008d4c:	89 c2                	mov    %eax,%edx
 4008d4e:	44 89 d6             	mov    %r10d,%esi
 4008d51:	44 89 cf             	mov    %r9d,%edi
 4008d54:	e8 dd fd ff ff       	call   4008b36 <FillRectangle(unsigned int, unsigned int, int, int, unsigned int)>
                  KernelShellController.MarginColor);
}
 4008d59:	90                   	nop
 4008d5a:	c9                   	leave
 4008d5b:	c3                   	ret

0000000004008d5c <DrawPicture(int, int, BGRR32bitsRawPictureType*)>:
(  
     int start_vector_x,
      int start_vector_y,
      BGRR32bitsRawPictureType* picture
)
{ 
 4008d5c:	55                   	push   %rbp
 4008d5d:	48 89 e5             	mov    %rsp,%rbp
 4008d60:	48 83 ec 20          	sub    $0x20,%rsp
 4008d64:	89 7d ec             	mov    %edi,-0x14(%rbp)
 4008d67:	89 75 e8             	mov    %esi,-0x18(%rbp)
 4008d6a:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
    for (UINT32 i = 0; i < picture->height; i++)
 4008d6e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
 4008d75:	eb 5f                	jmp    4008dd6 <DrawPicture(int, int, BGRR32bitsRawPictureType*)+0x7a>
    {
        for (UINT32 j = 0; j < picture->width; j++)
 4008d77:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
 4008d7e:	eb 46                	jmp    4008dc6 <DrawPicture(int, int, BGRR32bitsRawPictureType*)+0x6a>
        {
            drawpixel(start_vector_x + j, start_vector_y + i, picture->pixelDataBase[i * picture->width + j]);
 4008d80:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4008d84:	48 8b 50 08          	mov    0x8(%rax),%rdx
 4008d88:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4008d8c:	8b 40 04             	mov    0x4(%rax),%eax
 4008d8f:	0f af 45 fc          	imul   -0x4(%rbp),%eax
 4008d93:	89 c1                	mov    %eax,%ecx
 4008d95:	8b 45 f8             	mov    -0x8(%rbp),%eax
 4008d98:	01 c8                	add    %ecx,%eax
 4008d9a:	89 c0                	mov    %eax,%eax
 4008d9c:	48 c1 e0 02          	shl    $0x2,%rax
 4008da0:	48 01 d0             	add    %rdx,%rax
 4008da3:	8b 00                	mov    (%rax),%eax
 4008da5:	8b 4d e8             	mov    -0x18(%rbp),%ecx
 4008da8:	8b 55 fc             	mov    -0x4(%rbp),%edx
 4008dab:	01 ca                	add    %ecx,%edx
 4008dad:	89 d6                	mov    %edx,%esi
 4008daf:	8b 4d ec             	mov    -0x14(%rbp),%ecx
 4008db2:	8b 55 f8             	mov    -0x8(%rbp),%edx
 4008db5:	01 ca                	add    %ecx,%edx
 4008db7:	89 d1                	mov    %edx,%ecx
 4008db9:	89 c2                	mov    %eax,%edx
 4008dbb:	89 cf                	mov    %ecx,%edi
 4008dbd:	e8 74 fc ff ff       	call   4008a36 <drawpixel(int, int, unsigned int)>
        for (UINT32 j = 0; j < picture->width; j++)
 4008dc2:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
 4008dc6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4008dca:	8b 40 04             	mov    0x4(%rax),%eax
 4008dcd:	39 45 f8             	cmp    %eax,-0x8(%rbp)
 4008dd0:	72 ae                	jb     4008d80 <DrawPicture(int, int, BGRR32bitsRawPictureType*)+0x24>
    for (UINT32 i = 0; i < picture->height; i++)
 4008dd2:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
 4008dd6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4008dda:	8b 00                	mov    (%rax),%eax
 4008ddc:	39 45 fc             	cmp    %eax,-0x4(%rbp)
 4008ddf:	72 96                	jb     4008d77 <DrawPicture(int, int, BGRR32bitsRawPictureType*)+0x1b>
        }
        
    }
    
}
 4008de1:	90                   	nop
 4008de2:	90                   	nop
 4008de3:	c9                   	leave
 4008de4:	c3                   	ret

0000000004008de5 <drawCharacterWithoutRendered(int, int, wchar_t)>:

static inline int drawCharacterWithoutRendered(int start_x, int start_y, CHAR16 ch)
{
 4008de5:	55                   	push   %rbp
 4008de6:	48 89 e5             	mov    %rsp,%rbp
 4008de9:	48 83 ec 50          	sub    $0x50,%rsp
 4008ded:	89 7d bc             	mov    %edi,-0x44(%rbp)
 4008df0:	89 75 b8             	mov    %esi,-0x48(%rbp)
 4008df3:	89 55 b4             	mov    %edx,-0x4c(%rbp)
     UINT8 ascii = (UINT8)ch;
 4008df6:	8b 45 b4             	mov    -0x4c(%rbp),%eax
 4008df9:	88 45 d3             	mov    %al,-0x2d(%rbp)
    UINT32 chheight = GlobalCharacterSetBitmapControler.CharacterHeight;
 4008dfc:	8b 05 e2 63 80 00    	mov    0x8063e2(%rip),%eax        # 480f1e4 <GlobalCharacterSetBitmapControler+0x4>
 4008e02:	89 45 cc             	mov    %eax,-0x34(%rbp)
    UINT32 chwidth = GlobalCharacterSetBitmapControler.CharacterWidth;
 4008e05:	8b 05 d5 63 80 00    	mov    0x8063d5(%rip),%eax        # 480f1e0 <GlobalCharacterSetBitmapControler>
 4008e0b:	89 45 c8             	mov    %eax,-0x38(%rbp)
    UINT8 last_bit_index = chwidth % 8;
 4008e0e:	8b 45 c8             	mov    -0x38(%rbp),%eax
 4008e11:	83 e0 07             	and    $0x7,%eax
 4008e14:	88 45 c7             	mov    %al,-0x39(%rbp)
    UINT32 widthInByte=(chwidth+8-1)/8;
 4008e17:	8b 45 c8             	mov    -0x38(%rbp),%eax
 4008e1a:	83 c0 07             	add    $0x7,%eax
 4008e1d:	c1 e8 03             	shr    $0x3,%eax
 4008e20:	89 45 c0             	mov    %eax,-0x40(%rbp)
    UINT8 *WillBeFilttedBytePtr = GlobalCharacterSetBitmapControler.BitMapBase+ascii*chheight*widthInByte;
 4008e23:	48 8b 15 ce 63 80 00 	mov    0x8063ce(%rip),%rdx        # 480f1f8 <GlobalCharacterSetBitmapControler+0x18>
 4008e2a:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
 4008e2e:	0f af 45 cc          	imul   -0x34(%rbp),%eax
 4008e32:	0f af 45 c0          	imul   -0x40(%rbp),%eax
 4008e36:	89 c0                	mov    %eax,%eax
 4008e38:	48 01 d0             	add    %rdx,%rax
 4008e3b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    static const UINT8 Filterbitmasks[8] = {0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01};
    switch (KernelShellController.CharacterSetType)
 4008e3f:	8b 05 ff 63 80 00    	mov    0x8063ff(%rip),%eax        # 480f244 <KernelShellController+0x4>
 4008e45:	85 c0                	test   %eax,%eax
 4008e47:	74 0e                	je     4008e57 <drawCharacterWithoutRendered(int, int, wchar_t)+0x72>
 4008e49:	83 f8 01             	cmp    $0x1,%eax
 4008e4c:	0f 84 df 01 00 00    	je     4009031 <drawCharacterWithoutRendered(int, int, wchar_t)+0x24c>
 4008e52:	e9 e1 01 00 00       	jmp    4009038 <drawCharacterWithoutRendered(int, int, wchar_t)+0x253>
    {
    case ASCII:
       
    
    for (UINT32 i = 0; i < chheight; i++)
 4008e57:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
 4008e5e:	e9 bb 01 00 00       	jmp    400901e <drawCharacterWithoutRendered(int, int, wchar_t)+0x239>
    {
       if (last_bit_index != 0)
 4008e63:	80 7d c7 00          	cmpb   $0x0,-0x39(%rbp)
 4008e67:	0f 84 25 01 00 00    	je     4008f92 <drawCharacterWithoutRendered(int, int, wchar_t)+0x1ad>
       {
        for (UINT32 j = 0; j < widthInByte; j++)
 4008e6d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
 4008e74:	e9 08 01 00 00       	jmp    4008f81 <drawCharacterWithoutRendered(int, int, wchar_t)+0x19c>
        {   
            if (j==widthInByte-1)
 4008e79:	8b 45 c0             	mov    -0x40(%rbp),%eax
 4008e7c:	83 e8 01             	sub    $0x1,%eax
 4008e7f:	39 45 f0             	cmp    %eax,-0x10(%rbp)
 4008e82:	0f 85 82 00 00 00    	jne    4008f0a <drawCharacterWithoutRendered(int, int, wchar_t)+0x125>
            {
                for (UINT8 k = 0; k < last_bit_index; k++)
 4008e88:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
 4008e8c:	eb 69                	jmp    4008ef7 <drawCharacterWithoutRendered(int, int, wchar_t)+0x112>
                {
                    UINT32 pixelColor=*WillBeFilttedBytePtr& Filterbitmasks[k]?GlobalCharacterSetBitmapControler.CharacterColor:GlobalCharacterSetBitmapControler.BackGroundColor;
 4008e8e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4008e92:	0f b6 08             	movzbl (%rax),%ecx
 4008e95:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
 4008e99:	48 98                	cltq
 4008e9b:	48 8d 15 36 80 00 00 	lea    0x8036(%rip),%rdx        # 4010ed8 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks>
 4008ea2:	0f b6 04 10          	movzbl (%rax,%rdx,1),%eax
 4008ea6:	21 c8                	and    %ecx,%eax
 4008ea8:	84 c0                	test   %al,%al
 4008eaa:	74 0b                	je     4008eb7 <drawCharacterWithoutRendered(int, int, wchar_t)+0xd2>
 4008eac:	8b 05 42 63 80 00    	mov    0x806342(%rip),%eax        # 480f1f4 <GlobalCharacterSetBitmapControler+0x14>
 4008eb2:	89 45 e8             	mov    %eax,-0x18(%rbp)
 4008eb5:	eb 09                	jmp    4008ec0 <drawCharacterWithoutRendered(int, int, wchar_t)+0xdb>
 4008eb7:	8b 05 33 63 80 00    	mov    0x806333(%rip),%eax        # 480f1f0 <GlobalCharacterSetBitmapControler+0x10>
 4008ebd:	89 45 e8             	mov    %eax,-0x18(%rbp)
                    drawpixel(start_x + j * 8 + k, start_y + i, pixelColor);
 4008ec0:	8b 55 b8             	mov    -0x48(%rbp),%edx
 4008ec3:	8b 45 f4             	mov    -0xc(%rbp),%eax
 4008ec6:	01 d0                	add    %edx,%eax
 4008ec8:	89 c6                	mov    %eax,%esi
 4008eca:	8b 45 f0             	mov    -0x10(%rbp),%eax
 4008ecd:	8d 14 c5 00 00 00 00 	lea    0x0(,%rax,8),%edx
 4008ed4:	8b 45 bc             	mov    -0x44(%rbp),%eax
 4008ed7:	01 c2                	add    %eax,%edx
 4008ed9:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
 4008edd:	01 d0                	add    %edx,%eax
 4008edf:	89 c1                	mov    %eax,%ecx
 4008ee1:	8b 45 e8             	mov    -0x18(%rbp),%eax
 4008ee4:	89 c2                	mov    %eax,%edx
 4008ee6:	89 cf                	mov    %ecx,%edi
 4008ee8:	e8 49 fb ff ff       	call   4008a36 <drawpixel(int, int, unsigned int)>
                for (UINT8 k = 0; k < last_bit_index; k++)
 4008eed:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
 4008ef1:	83 c0 01             	add    $0x1,%eax
 4008ef4:	88 45 ef             	mov    %al,-0x11(%rbp)
 4008ef7:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
 4008efb:	3a 45 c7             	cmp    -0x39(%rbp),%al
 4008efe:	72 8e                	jb     4008e8e <drawCharacterWithoutRendered(int, int, wchar_t)+0xa9>
                }
                WillBeFilttedBytePtr++;
 4008f00:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
                break;
 4008f05:	e9 10 01 00 00       	jmp    400901a <drawCharacterWithoutRendered(int, int, wchar_t)+0x235>
            }
            
            for (UINT32 k = 0; k < 8; k++)
 4008f0a:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%rbp)
 4008f11:	eb 5f                	jmp    4008f72 <drawCharacterWithoutRendered(int, int, wchar_t)+0x18d>
            {
               UINT32 pixelColor=*WillBeFilttedBytePtr& Filterbitmasks[k]?GlobalCharacterSetBitmapControler.CharacterColor:GlobalCharacterSetBitmapControler.BackGroundColor;
 4008f13:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4008f17:	0f b6 08             	movzbl (%rax),%ecx
 4008f1a:	8b 45 e4             	mov    -0x1c(%rbp),%eax
 4008f1d:	48 8d 15 b4 7f 00 00 	lea    0x7fb4(%rip),%rdx        # 4010ed8 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks>
 4008f24:	0f b6 04 10          	movzbl (%rax,%rdx,1),%eax
 4008f28:	21 c8                	and    %ecx,%eax
 4008f2a:	84 c0                	test   %al,%al
 4008f2c:	74 0b                	je     4008f39 <drawCharacterWithoutRendered(int, int, wchar_t)+0x154>
 4008f2e:	8b 05 c0 62 80 00    	mov    0x8062c0(%rip),%eax        # 480f1f4 <GlobalCharacterSetBitmapControler+0x14>
 4008f34:	89 45 e0             	mov    %eax,-0x20(%rbp)
 4008f37:	eb 09                	jmp    4008f42 <drawCharacterWithoutRendered(int, int, wchar_t)+0x15d>
 4008f39:	8b 05 b1 62 80 00    	mov    0x8062b1(%rip),%eax        # 480f1f0 <GlobalCharacterSetBitmapControler+0x10>
 4008f3f:	89 45 e0             	mov    %eax,-0x20(%rbp)
                    drawpixel(start_x + j * 8 + k, start_y + i, pixelColor);
 4008f42:	8b 55 b8             	mov    -0x48(%rbp),%edx
 4008f45:	8b 45 f4             	mov    -0xc(%rbp),%eax
 4008f48:	01 d0                	add    %edx,%eax
 4008f4a:	89 c6                	mov    %eax,%esi
 4008f4c:	8b 45 f0             	mov    -0x10(%rbp),%eax
 4008f4f:	8d 14 c5 00 00 00 00 	lea    0x0(,%rax,8),%edx
 4008f56:	8b 45 bc             	mov    -0x44(%rbp),%eax
 4008f59:	01 c2                	add    %eax,%edx
 4008f5b:	8b 45 e4             	mov    -0x1c(%rbp),%eax
 4008f5e:	01 d0                	add    %edx,%eax
 4008f60:	89 c1                	mov    %eax,%ecx
 4008f62:	8b 45 e0             	mov    -0x20(%rbp),%eax
 4008f65:	89 c2                	mov    %eax,%edx
 4008f67:	89 cf                	mov    %ecx,%edi
 4008f69:	e8 c8 fa ff ff       	call   4008a36 <drawpixel(int, int, unsigned int)>
            for (UINT32 k = 0; k < 8; k++)
 4008f6e:	83 45 e4 01          	addl   $0x1,-0x1c(%rbp)
 4008f72:	83 7d e4 07          	cmpl   $0x7,-0x1c(%rbp)
 4008f76:	76 9b                	jbe    4008f13 <drawCharacterWithoutRendered(int, int, wchar_t)+0x12e>
            }WillBeFilttedBytePtr++;
 4008f78:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
        for (UINT32 j = 0; j < widthInByte; j++)
 4008f7d:	83 45 f0 01          	addl   $0x1,-0x10(%rbp)
 4008f81:	8b 45 f0             	mov    -0x10(%rbp),%eax
 4008f84:	3b 45 c0             	cmp    -0x40(%rbp),%eax
 4008f87:	0f 82 ec fe ff ff    	jb     4008e79 <drawCharacterWithoutRendered(int, int, wchar_t)+0x94>
 4008f8d:	e9 88 00 00 00       	jmp    400901a <drawCharacterWithoutRendered(int, int, wchar_t)+0x235>
        }
       }else{ 
        for (UINT32 j = 0; j < widthInByte; j++)
 4008f92:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%rbp)
 4008f99:	eb 77                	jmp    4009012 <drawCharacterWithoutRendered(int, int, wchar_t)+0x22d>
        {   
            for (UINT32 k = 0; k < 8; k++)
 4008f9b:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
 4008fa2:	eb 5f                	jmp    4009003 <drawCharacterWithoutRendered(int, int, wchar_t)+0x21e>
            {
               UINT32 pixelColor=*WillBeFilttedBytePtr& Filterbitmasks[k]?GlobalCharacterSetBitmapControler.CharacterColor:GlobalCharacterSetBitmapControler.BackGroundColor;
 4008fa4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 4008fa8:	0f b6 08             	movzbl (%rax),%ecx
 4008fab:	8b 45 d8             	mov    -0x28(%rbp),%eax
 4008fae:	48 8d 15 23 7f 00 00 	lea    0x7f23(%rip),%rdx        # 4010ed8 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks>
 4008fb5:	0f b6 04 10          	movzbl (%rax,%rdx,1),%eax
 4008fb9:	21 c8                	and    %ecx,%eax
 4008fbb:	84 c0                	test   %al,%al
 4008fbd:	74 0b                	je     4008fca <drawCharacterWithoutRendered(int, int, wchar_t)+0x1e5>
 4008fbf:	8b 05 2f 62 80 00    	mov    0x80622f(%rip),%eax        # 480f1f4 <GlobalCharacterSetBitmapControler+0x14>
 4008fc5:	89 45 d4             	mov    %eax,-0x2c(%rbp)
 4008fc8:	eb 09                	jmp    4008fd3 <drawCharacterWithoutRendered(int, int, wchar_t)+0x1ee>
 4008fca:	8b 05 20 62 80 00    	mov    0x806220(%rip),%eax        # 480f1f0 <GlobalCharacterSetBitmapControler+0x10>
 4008fd0:	89 45 d4             	mov    %eax,-0x2c(%rbp)
                    drawpixel(start_x + j * 8 + k, start_y + i, pixelColor);
 4008fd3:	8b 55 b8             	mov    -0x48(%rbp),%edx
 4008fd6:	8b 45 f4             	mov    -0xc(%rbp),%eax
 4008fd9:	01 d0                	add    %edx,%eax
 4008fdb:	89 c6                	mov    %eax,%esi
 4008fdd:	8b 45 dc             	mov    -0x24(%rbp),%eax
 4008fe0:	8d 14 c5 00 00 00 00 	lea    0x0(,%rax,8),%edx
 4008fe7:	8b 45 bc             	mov    -0x44(%rbp),%eax
 4008fea:	01 c2                	add    %eax,%edx
 4008fec:	8b 45 d8             	mov    -0x28(%rbp),%eax
 4008fef:	01 d0                	add    %edx,%eax
 4008ff1:	89 c1                	mov    %eax,%ecx
 4008ff3:	8b 45 d4             	mov    -0x2c(%rbp),%eax
 4008ff6:	89 c2                	mov    %eax,%edx
 4008ff8:	89 cf                	mov    %ecx,%edi
 4008ffa:	e8 37 fa ff ff       	call   4008a36 <drawpixel(int, int, unsigned int)>
            for (UINT32 k = 0; k < 8; k++)
 4008fff:	83 45 d8 01          	addl   $0x1,-0x28(%rbp)
 4009003:	83 7d d8 07          	cmpl   $0x7,-0x28(%rbp)
 4009007:	76 9b                	jbe    4008fa4 <drawCharacterWithoutRendered(int, int, wchar_t)+0x1bf>
            }WillBeFilttedBytePtr++;
 4009009:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
        for (UINT32 j = 0; j < widthInByte; j++)
 400900e:	83 45 dc 01          	addl   $0x1,-0x24(%rbp)
 4009012:	8b 45 dc             	mov    -0x24(%rbp),%eax
 4009015:	3b 45 c0             	cmp    -0x40(%rbp),%eax
 4009018:	72 81                	jb     4008f9b <drawCharacterWithoutRendered(int, int, wchar_t)+0x1b6>
    for (UINT32 i = 0; i < chheight; i++)
 400901a:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
 400901e:	8b 45 f4             	mov    -0xc(%rbp),%eax
 4009021:	3b 45 cc             	cmp    -0x34(%rbp),%eax
 4009024:	0f 82 39 fe ff ff    	jb     4008e63 <drawCharacterWithoutRendered(int, int, wchar_t)+0x7e>
        }
    }
       
    }
    return OS_SUCCESS;
 400902a:	b8 00 00 00 00       	mov    $0x0,%eax
 400902f:	eb 0c                	jmp    400903d <drawCharacterWithoutRendered(int, int, wchar_t)+0x258>
    case 1:
        return EOPNOTSUPP;
 4009031:	b8 5f 00 00 00       	mov    $0x5f,%eax
 4009036:	eb 05                	jmp    400903d <drawCharacterWithoutRendered(int, int, wchar_t)+0x258>
        break;
    default:
        return EFI_BMP_INVALID;
 4009038:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    }
    
}
 400903d:	c9                   	leave
 400903e:	c3                   	ret

000000000400903f <ValidateDrawingParameters(int, int)>:

static inline int ValidateDrawingParameters(int x, int y)
{
 400903f:	55                   	push   %rbp
 4009040:	48 89 e5             	mov    %rsp,%rbp
 4009043:	48 83 ec 10          	sub    $0x10,%rsp
 4009047:	89 7d fc             	mov    %edi,-0x4(%rbp)
 400904a:	89 75 f8             	mov    %esi,-0x8(%rbp)
    DRAW_DEBUG_PRINT("ValidateDrawingParameters: x=%d, y=%d\n");
 400904d:	48 8d 05 8c 7e 00 00 	lea    0x7e8c(%rip),%rax        # 4010ee0 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0x8>
 4009054:	48 89 c7             	mov    %rax,%rdi
 4009057:	e8 f3 17 00 00       	call   400a84f <serial_puts>
    
    // 帧缓冲区基础状态检查
    if (GlobalBasicGraphicInfo.FrameBufferBase == 0 || 
 400905c:	48 8b 05 cd 61 80 00 	mov    0x8061cd(%rip),%rax        # 480f230 <GlobalBasicGraphicInfo+0x10>
 4009063:	48 85 c0             	test   %rax,%rax
 4009066:	74 0a                	je     4009072 <ValidateDrawingParameters(int, int)+0x33>
        GlobalBasicGraphicInfo.FrameBufferSize == 0)
 4009068:	8b 05 ca 61 80 00    	mov    0x8061ca(%rip),%eax        # 480f238 <GlobalBasicGraphicInfo+0x18>
    if (GlobalBasicGraphicInfo.FrameBufferBase == 0 || 
 400906e:	85 c0                	test   %eax,%eax
 4009070:	75 19                	jne    400908b <ValidateDrawingParameters(int, int)+0x4c>
    {
        DRAW_DEBUG_PRINT("ValidateDrawingParameters: Invalid frame buffer\n");
 4009072:	48 8d 05 8f 7e 00 00 	lea    0x7e8f(%rip),%rax        # 4010f08 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0x30>
 4009079:	48 89 c7             	mov    %rax,%rdi
 400907c:	e8 ce 17 00 00       	call   400a84f <serial_puts>
        return EFAULT; // 原为OS_INVALID_ADDRESS
 4009081:	b8 0e 00 00 00       	mov    $0xe,%eax
 4009086:	e9 87 00 00 00       	jmp    4009112 <ValidateDrawingParameters(int, int)+0xd3>
    }

    // 坐标边界检查（单次判断提高效率）
    if ((unsigned int)x >= GlobalBasicGraphicInfo.horizentalResolution || 
 400908b:	8b 05 8f 61 80 00    	mov    0x80618f(%rip),%eax        # 480f220 <GlobalBasicGraphicInfo>
 4009091:	8b 55 fc             	mov    -0x4(%rbp),%edx
 4009094:	39 c2                	cmp    %eax,%edx
 4009096:	73 0d                	jae    40090a5 <ValidateDrawingParameters(int, int)+0x66>
        (unsigned int)y >= GlobalBasicGraphicInfo.verticalResolution)
 4009098:	8b 05 86 61 80 00    	mov    0x806186(%rip),%eax        # 480f224 <GlobalBasicGraphicInfo+0x4>
 400909e:	8b 55 f8             	mov    -0x8(%rbp),%edx
    if ((unsigned int)x >= GlobalBasicGraphicInfo.horizentalResolution || 
 40090a1:	39 c2                	cmp    %eax,%edx
 40090a3:	72 16                	jb     40090bb <ValidateDrawingParameters(int, int)+0x7c>
    {
        DRAW_DEBUG_PRINT("ValidateDrawingParameters: Coordinate out of range\n");
 40090a5:	48 8d 05 94 7e 00 00 	lea    0x7e94(%rip),%rax        # 4010f40 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0x68>
 40090ac:	48 89 c7             	mov    %rax,%rdi
 40090af:	e8 9b 17 00 00       	call   400a84f <serial_puts>
        return ERANGE; // 原为OS_COORDINATE_OUT_OF_RANGE
 40090b4:	b8 22 00 00 00       	mov    $0x22,%eax
 40090b9:	eb 57                	jmp    4009112 <ValidateDrawingParameters(int, int)+0xd3>
    }
    
    if (x < 0 || y < 0) {
 40090bb:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
 40090bf:	78 06                	js     40090c7 <ValidateDrawingParameters(int, int)+0x88>
 40090c1:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
 40090c5:	79 16                	jns    40090dd <ValidateDrawingParameters(int, int)+0x9e>
        DRAW_DEBUG_PRINT("ValidateDrawingParameters: Negative coordinates\n");
 40090c7:	48 8d 05 aa 7e 00 00 	lea    0x7eaa(%rip),%rax        # 4010f78 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0xa0>
 40090ce:	48 89 c7             	mov    %rax,%rdi
 40090d1:	e8 79 17 00 00       	call   400a84f <serial_puts>
        return EINVAL; // 原为OS_INVALID_ARGUMENT
 40090d6:	b8 16 00 00 00       	mov    $0x16,%eax
 40090db:	eb 35                	jmp    4009112 <ValidateDrawingParameters(int, int)+0xd3>
    }

    // 像素格式检查
   if (GlobalBasicGraphicInfo.pixelFormat != PixelBlueGreenRedReserved8BitPerColor) 
 40090dd:	8b 05 45 61 80 00    	mov    0x806145(%rip),%eax        # 480f228 <GlobalBasicGraphicInfo+0x8>
 40090e3:	83 f8 01             	cmp    $0x1,%eax
 40090e6:	74 16                	je     40090fe <ValidateDrawingParameters(int, int)+0xbf>
    {
        DRAW_DEBUG_PRINT("ValidateDrawingParameters: Invalid pixel format\n");
 40090e8:	48 8d 05 c1 7e 00 00 	lea    0x7ec1(%rip),%rax        # 4010fb0 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0xd8>
 40090ef:	48 89 c7             	mov    %rax,%rdi
 40090f2:	e8 58 17 00 00       	call   400a84f <serial_puts>
        return EINVAL; // 原为OS_INVALID_ARGUMENT
 40090f7:	b8 16 00 00 00       	mov    $0x16,%eax
 40090fc:	eb 14                	jmp    4009112 <ValidateDrawingParameters(int, int)+0xd3>
    }

    DRAW_DEBUG_PRINT("ValidateDrawingParameters: Success\n");
 40090fe:	48 8d 05 e3 7e 00 00 	lea    0x7ee3(%rip),%rax        # 4010fe8 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0x110>
 4009105:	48 89 c7             	mov    %rax,%rdi
 4009108:	e8 42 17 00 00       	call   400a84f <serial_puts>
    return OS_SUCCESS;
 400910d:	b8 00 00 00 00       	mov    $0x0,%eax
}
 4009112:	c9                   	leave
 4009113:	c3                   	ret

0000000004009114 <InitialKernelShellControler>:
    UINT32 InputTextBufferSize,
    GlobalBitmapControlerType *GlobalBitmapControler,
    UINT32 OutputTextBufferSize,
    UINT16 WindowBeginX,
    UINT16 WindowBeginY
){
 4009114:	55                   	push   %rbp
 4009115:	48 89 e5             	mov    %rsp,%rbp
 4009118:	48 83 ec 50          	sub    $0x50,%rsp
 400911c:	89 55 d4             	mov    %edx,-0x2c(%rbp)
 400911f:	89 c8                	mov    %ecx,%eax
 4009121:	45 89 c2             	mov    %r8d,%r10d
 4009124:	44 8b 45 10          	mov    0x10(%rbp),%r8d
 4009128:	8b 4d 40             	mov    0x40(%rbp),%ecx
 400912b:	8b 55 48             	mov    0x48(%rbp),%edx
 400912e:	66 89 7d dc          	mov    %di,-0x24(%rbp)
 4009132:	66 89 75 d8          	mov    %si,-0x28(%rbp)
 4009136:	66 89 45 d0          	mov    %ax,-0x30(%rbp)
 400913a:	44 89 d0             	mov    %r10d,%eax
 400913d:	66 89 45 cc          	mov    %ax,-0x34(%rbp)
 4009141:	44 89 c8             	mov    %r9d,%eax
 4009144:	66 89 45 c8          	mov    %ax,-0x38(%rbp)
 4009148:	44 89 c0             	mov    %r8d,%eax
 400914b:	66 89 45 c4          	mov    %ax,-0x3c(%rbp)
 400914f:	89 c8                	mov    %ecx,%eax
 4009151:	66 89 45 c0          	mov    %ax,-0x40(%rbp)
 4009155:	89 d0                	mov    %edx,%eax
 4009157:	66 89 45 bc          	mov    %ax,-0x44(%rbp)
    // 1. 检查窗口尺寸
    if(WindowHeight == 0 || WindowWidth == 0) {
 400915b:	66 83 7d dc 00       	cmpw   $0x0,-0x24(%rbp)
 4009160:	74 07                	je     4009169 <InitialKernelShellControler+0x55>
 4009162:	66 83 7d d8 00       	cmpw   $0x0,-0x28(%rbp)
 4009167:	75 19                	jne    4009182 <InitialKernelShellControler+0x6e>
        DRAW_DEBUG_PRINT("Window dimensions cannot be zero\n");
 4009169:	48 8d 05 a0 7e 00 00 	lea    0x7ea0(%rip),%rax        # 4011010 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0x138>
 4009170:	48 89 c7             	mov    %rax,%rdi
 4009173:	e8 d7 16 00 00       	call   400a84f <serial_puts>
        return EINVAL; // 原为OS_INVALID_ARGUMENT
 4009178:	b8 16 00 00 00       	mov    $0x16,%eax
 400917d:	e9 2a 03 00 00       	jmp    40094ac <InitialKernelShellControler+0x398>
    }

    // 2. 检查边距有效性

    
    if (topMargin + bottomMargin >= WindowHeight || 
 4009182:	0f b7 55 d0          	movzwl -0x30(%rbp),%edx
 4009186:	0f b7 45 cc          	movzwl -0x34(%rbp),%eax
 400918a:	01 c2                	add    %eax,%edx
 400918c:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
 4009190:	39 c2                	cmp    %eax,%edx
 4009192:	7d 12                	jge    40091a6 <InitialKernelShellControler+0x92>
        leftMargin + rightMargin >= WindowWidth) {
 4009194:	0f b7 55 c8          	movzwl -0x38(%rbp),%edx
 4009198:	0f b7 45 c4          	movzwl -0x3c(%rbp),%eax
 400919c:	01 c2                	add    %eax,%edx
 400919e:	0f b7 45 d8          	movzwl -0x28(%rbp),%eax
    if (topMargin + bottomMargin >= WindowHeight || 
 40091a2:	39 c2                	cmp    %eax,%edx
 40091a4:	7c 19                	jl     40091bf <InitialKernelShellControler+0xab>
        DRAW_DEBUG_PRINT("InnerMargins exceed window dimensions\n");
 40091a6:	48 8d 05 8b 7e 00 00 	lea    0x7e8b(%rip),%rax        # 4011038 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0x160>
 40091ad:	48 89 c7             	mov    %rax,%rdi
 40091b0:	e8 9a 16 00 00       	call   400a84f <serial_puts>
        return EINVAL; // 原为OS_INVALID_ARGUMENT
 40091b5:	b8 16 00 00 00       	mov    $0x16,%eax
 40091ba:	e9 ed 02 00 00       	jmp    40094ac <InitialKernelShellControler+0x398>
    }

    // 3. 检查全局图形信息
    if(GlobalBasicGraphicInfo.FrameBufferBase == 0 || 
 40091bf:	48 8b 05 6a 60 80 00 	mov    0x80606a(%rip),%rax        # 480f230 <GlobalBasicGraphicInfo+0x10>
 40091c6:	48 85 c0             	test   %rax,%rax
 40091c9:	74 0a                	je     40091d5 <InitialKernelShellControler+0xc1>
       GlobalBasicGraphicInfo.FrameBufferSize == 0) {
 40091cb:	8b 05 67 60 80 00    	mov    0x806067(%rip),%eax        # 480f238 <GlobalBasicGraphicInfo+0x18>
    if(GlobalBasicGraphicInfo.FrameBufferBase == 0 || 
 40091d1:	85 c0                	test   %eax,%eax
 40091d3:	75 19                	jne    40091ee <InitialKernelShellControler+0xda>
        DRAW_DEBUG_PRINT("GlobalBasicGraphicInfo not initialized\n");
 40091d5:	48 8d 05 84 7e 00 00 	lea    0x7e84(%rip),%rax        # 4011060 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0x188>
 40091dc:	48 89 c7             	mov    %rax,%rdi
 40091df:	e8 6b 16 00 00       	call   400a84f <serial_puts>
        return ENODEV; // 原为OS_UNINITIALIZED
 40091e4:	b8 13 00 00 00       	mov    $0x13,%eax
 40091e9:	e9 be 02 00 00       	jmp    40094ac <InitialKernelShellControler+0x398>
    }
    
    // 4. 检查屏幕边界
    if(WindowBeginX + WindowWidth > GlobalBasicGraphicInfo.horizentalResolution ||
 40091ee:	0f b7 55 c0          	movzwl -0x40(%rbp),%edx
 40091f2:	0f b7 45 d8          	movzwl -0x28(%rbp),%eax
 40091f6:	01 d0                	add    %edx,%eax
 40091f8:	89 c2                	mov    %eax,%edx
 40091fa:	8b 05 20 60 80 00    	mov    0x806020(%rip),%eax        # 480f220 <GlobalBasicGraphicInfo>
 4009200:	39 d0                	cmp    %edx,%eax
 4009202:	72 16                	jb     400921a <InitialKernelShellControler+0x106>
       WindowBeginY + WindowHeight > GlobalBasicGraphicInfo.verticalResolution) {
 4009204:	0f b7 55 bc          	movzwl -0x44(%rbp),%edx
 4009208:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
 400920c:	01 d0                	add    %edx,%eax
 400920e:	89 c2                	mov    %eax,%edx
 4009210:	8b 05 0e 60 80 00    	mov    0x80600e(%rip),%eax        # 480f224 <GlobalBasicGraphicInfo+0x4>
    if(WindowBeginX + WindowWidth > GlobalBasicGraphicInfo.horizentalResolution ||
 4009216:	39 d0                	cmp    %edx,%eax
 4009218:	73 19                	jae    4009233 <InitialKernelShellControler+0x11f>
        DRAW_DEBUG_PRINT("Window exceeds screen: %dx%d vs %dx%d\n");
 400921a:	48 8d 05 67 7e 00 00 	lea    0x7e67(%rip),%rax        # 4011088 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0x1b0>
 4009221:	48 89 c7             	mov    %rax,%rdi
 4009224:	e8 26 16 00 00       	call   400a84f <serial_puts>
        return ERANGE; // 原为OS_COORDINATE_OUT_OF_RANGE
 4009229:	b8 22 00 00 00       	mov    $0x22,%eax
 400922e:	e9 79 02 00 00       	jmp    40094ac <InitialKernelShellControler+0x398>
    }
    
    // 5. 校验缓冲区
    if(InputTextBuffer == NULL || OutputTextBuffer == NULL) {
 4009233:	48 83 7d 18 00       	cmpq   $0x0,0x18(%rbp)
 4009238:	74 07                	je     4009241 <InitialKernelShellControler+0x12d>
 400923a:	48 83 7d 20 00       	cmpq   $0x0,0x20(%rbp)
 400923f:	75 19                	jne    400925a <InitialKernelShellControler+0x146>
        DRAW_DEBUG_PRINT("Text buffer pointers cannot be NULL\n");
 4009241:	48 8d 05 68 7e 00 00 	lea    0x7e68(%rip),%rax        # 40110b0 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0x1d8>
 4009248:	48 89 c7             	mov    %rax,%rdi
 400924b:	e8 ff 15 00 00       	call   400a84f <serial_puts>
        return EFAULT; // 原为OS_INVALID_ADDRESS
 4009250:	b8 0e 00 00 00       	mov    $0xe,%eax
 4009255:	e9 52 02 00 00       	jmp    40094ac <InitialKernelShellControler+0x398>
    }
    
    if(InputTextBufferSize < 16 || OutputTextBufferSize < 16) { // 最小合理值
 400925a:	83 7d 28 0f          	cmpl   $0xf,0x28(%rbp)
 400925e:	76 06                	jbe    4009266 <InitialKernelShellControler+0x152>
 4009260:	83 7d 38 0f          	cmpl   $0xf,0x38(%rbp)
 4009264:	77 19                	ja     400927f <InitialKernelShellControler+0x16b>
        DRAW_DEBUG_PRINT("Text buffer size too small\n");
 4009266:	48 8d 05 68 7e 00 00 	lea    0x7e68(%rip),%rax        # 40110d5 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0x1fd>
 400926d:	48 89 c7             	mov    %rax,%rdi
 4009270:	e8 da 15 00 00       	call   400a84f <serial_puts>
        return ENOBUFS; // 原为OS_INSUFFICIENT_BUFFER
 4009275:	b8 69 00 00 00       	mov    $0x69,%eax
 400927a:	e9 2d 02 00 00       	jmp    40094ac <InitialKernelShellControler+0x398>
    }
    
    // 6. 检测缓冲区重叠
    UINT8* inputEnd = InputTextBuffer + InputTextBufferSize;
 400927f:	8b 55 28             	mov    0x28(%rbp),%edx
 4009282:	48 8b 45 18          	mov    0x18(%rbp),%rax
 4009286:	48 01 d0             	add    %rdx,%rax
 4009289:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    UINT8* outputEnd = OutputTextBuffer + OutputTextBufferSize;
 400928d:	8b 55 38             	mov    0x38(%rbp),%edx
 4009290:	48 8b 45 20          	mov    0x20(%rbp),%rax
 4009294:	48 01 d0             	add    %rdx,%rax
 4009297:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    if((InputTextBuffer >= OutputTextBuffer && InputTextBuffer < outputEnd) ||
 400929b:	48 8b 45 18          	mov    0x18(%rbp),%rax
 400929f:	48 3b 45 20          	cmp    0x20(%rbp),%rax
 40092a3:	72 0a                	jb     40092af <InitialKernelShellControler+0x19b>
 40092a5:	48 8b 45 18          	mov    0x18(%rbp),%rax
 40092a9:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
 40092ad:	72 14                	jb     40092c3 <InitialKernelShellControler+0x1af>
 40092af:	48 8b 45 20          	mov    0x20(%rbp),%rax
 40092b3:	48 3b 45 18          	cmp    0x18(%rbp),%rax
 40092b7:	72 23                	jb     40092dc <InitialKernelShellControler+0x1c8>
       (OutputTextBuffer >= InputTextBuffer && OutputTextBuffer < inputEnd)) {
 40092b9:	48 8b 45 20          	mov    0x20(%rbp),%rax
 40092bd:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
 40092c1:	73 19                	jae    40092dc <InitialKernelShellControler+0x1c8>
        DRAW_DEBUG_PRINT("Input and output buffers overlap\n");
 40092c3:	48 8d 05 2e 7e 00 00 	lea    0x7e2e(%rip),%rax        # 40110f8 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0x220>
 40092ca:	48 89 c7             	mov    %rax,%rdi
 40092cd:	e8 7d 15 00 00       	call   400a84f <serial_puts>
        return EFAULT; // 原为OS_BUFFER_OVERLAP
 40092d2:	b8 0e 00 00 00       	mov    $0xe,%eax
 40092d7:	e9 d0 01 00 00       	jmp    40094ac <InitialKernelShellControler+0x398>
    }
    
    // 7. 字符集支持
    if(CharacterSetType != ASCII && CharacterSetType != UTF_8) {
 40092dc:	83 7d d4 00          	cmpl   $0x0,-0x2c(%rbp)
 40092e0:	74 1f                	je     4009301 <InitialKernelShellControler+0x1ed>
 40092e2:	83 7d d4 01          	cmpl   $0x1,-0x2c(%rbp)
 40092e6:	74 19                	je     4009301 <InitialKernelShellControler+0x1ed>
        DRAW_DEBUG_PRINT("Unsupported charset: %d\n");
 40092e8:	48 8d 05 2b 7e 00 00 	lea    0x7e2b(%rip),%rax        # 401111a <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0x242>
 40092ef:	48 89 c7             	mov    %rax,%rdi
 40092f2:	e8 58 15 00 00       	call   400a84f <serial_puts>
        return EPROTONOSUPPORT; // 原为OS_UNSUPPORTED_FORMAT
 40092f7:	b8 5d 00 00 00       	mov    $0x5d,%eax
 40092fc:	e9 ab 01 00 00       	jmp    40094ac <InitialKernelShellControler+0x398>
    }
    
    // 8. 位图控制器验证
    if(GlobalBitmapControler == NULL) {
 4009301:	48 83 7d 30 00       	cmpq   $0x0,0x30(%rbp)
 4009306:	75 19                	jne    4009321 <InitialKernelShellControler+0x20d>
        DRAW_DEBUG_PRINT("Bitmap controller pointer cannot be NULL\n");
 4009308:	48 8d 05 29 7e 00 00 	lea    0x7e29(%rip),%rax        # 4011138 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0x260>
 400930f:	48 89 c7             	mov    %rax,%rdi
 4009312:	e8 38 15 00 00       	call   400a84f <serial_puts>
        return EFAULT; // 原为OS_INVALID_ADDRESS
 4009317:	b8 0e 00 00 00       	mov    $0xe,%eax
 400931c:	e9 8b 01 00 00       	jmp    40094ac <InitialKernelShellControler+0x398>
    }
    
    if(GlobalBitmapControler->CharacterHeight == 0 ||
 4009321:	48 8b 45 30          	mov    0x30(%rbp),%rax
 4009325:	8b 40 04             	mov    0x4(%rax),%eax
 4009328:	85 c0                	test   %eax,%eax
 400932a:	74 28                	je     4009354 <InitialKernelShellControler+0x240>
       GlobalBitmapControler->CharacterWidth == 0 ||
 400932c:	48 8b 45 30          	mov    0x30(%rbp),%rax
 4009330:	8b 00                	mov    (%rax),%eax
    if(GlobalBitmapControler->CharacterHeight == 0 ||
 4009332:	85 c0                	test   %eax,%eax
 4009334:	74 1e                	je     4009354 <InitialKernelShellControler+0x240>
       GlobalBitmapControler->BitMapBase == NULL||
 4009336:	48 8b 45 30          	mov    0x30(%rbp),%rax
 400933a:	48 8b 40 18          	mov    0x18(%rax),%rax
       GlobalBitmapControler->CharacterWidth == 0 ||
 400933e:	48 85 c0             	test   %rax,%rax
 4009341:	74 11                	je     4009354 <InitialKernelShellControler+0x240>
       GlobalBitmapControler->CharacterSetType!=KernelShellController.CharacterSetType) {
 4009343:	48 8b 45 30          	mov    0x30(%rbp),%rax
 4009347:	8b 50 0c             	mov    0xc(%rax),%edx
 400934a:	8b 05 f4 5e 80 00    	mov    0x805ef4(%rip),%eax        # 480f244 <KernelShellController+0x4>
       GlobalBitmapControler->BitMapBase == NULL||
 4009350:	39 c2                	cmp    %eax,%edx
 4009352:	74 19                	je     400936d <InitialKernelShellControler+0x259>
        DRAW_DEBUG_PRINT("BitmapControler not properly initialized\n");
 4009354:	48 8d 05 0d 7e 00 00 	lea    0x7e0d(%rip),%rax        # 4011168 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0x290>
 400935b:	48 89 c7             	mov    %rax,%rdi
 400935e:	e8 ec 14 00 00       	call   400a84f <serial_puts>
        return ENODEV; // 原为OS_UNINITIALIZED
 4009363:	b8 13 00 00 00       	mov    $0x13,%eax
 4009368:	e9 3f 01 00 00       	jmp    40094ac <InitialKernelShellControler+0x398>
    }
    
    // 9. 字符尺寸兼容性检查
    UINT32 contentWidth = WindowWidth - leftMargin - rightMargin;
 400936d:	0f b7 55 d8          	movzwl -0x28(%rbp),%edx
 4009371:	0f b7 45 c8          	movzwl -0x38(%rbp),%eax
 4009375:	29 c2                	sub    %eax,%edx
 4009377:	0f b7 45 c4          	movzwl -0x3c(%rbp),%eax
 400937b:	29 c2                	sub    %eax,%edx
 400937d:	89 55 ec             	mov    %edx,-0x14(%rbp)
    UINT32 contentHeight = WindowHeight - topMargin - bottomMargin;
 4009380:	0f b7 55 dc          	movzwl -0x24(%rbp),%edx
 4009384:	0f b7 45 d0          	movzwl -0x30(%rbp),%eax
 4009388:	29 c2                	sub    %eax,%edx
 400938a:	0f b7 45 cc          	movzwl -0x34(%rbp),%eax
 400938e:	29 c2                	sub    %eax,%edx
 4009390:	89 55 e8             	mov    %edx,-0x18(%rbp)
    UINT32 charWidth = GlobalBitmapControler->CharacterWidth;
 4009393:	48 8b 45 30          	mov    0x30(%rbp),%rax
 4009397:	8b 00                	mov    (%rax),%eax
 4009399:	89 45 e4             	mov    %eax,-0x1c(%rbp)
    UINT32 charHeight = GlobalBitmapControler->CharacterHeight;
 400939c:	48 8b 45 30          	mov    0x30(%rbp),%rax
 40093a0:	8b 40 04             	mov    0x4(%rax),%eax
 40093a3:	89 45 e0             	mov    %eax,-0x20(%rbp)
    
    if(contentWidth < charWidth || contentHeight < charHeight) {
 40093a6:	8b 45 ec             	mov    -0x14(%rbp),%eax
 40093a9:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
 40093ac:	72 08                	jb     40093b6 <InitialKernelShellControler+0x2a2>
 40093ae:	8b 45 e8             	mov    -0x18(%rbp),%eax
 40093b1:	3b 45 e0             	cmp    -0x20(%rbp),%eax
 40093b4:	73 19                	jae    40093cf <InitialKernelShellControler+0x2bb>
        DRAW_DEBUG_PRINT("Window too small for characters\n");
 40093b6:	48 8d 05 db 7d 00 00 	lea    0x7ddb(%rip),%rax        # 4011198 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0x2c0>
 40093bd:	48 89 c7             	mov    %rax,%rdi
 40093c0:	e8 8a 14 00 00       	call   400a84f <serial_puts>
        return EDOM; // 原为OS_DIMENSION_MISMATCH
 40093c5:	b8 21 00 00 00       	mov    $0x21,%eax
 40093ca:	e9 dd 00 00 00       	jmp    40094ac <InitialKernelShellControler+0x398>
    }
    
    // === 初始化逻辑 ===
    KernelShellController.WindowHeight = WindowHeight;
 40093cf:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
 40093d3:	66 89 05 66 5e 80 00 	mov    %ax,0x805e66(%rip)        # 480f240 <KernelShellController>
    KernelShellController.WindowWidth = WindowWidth;
 40093da:	0f b7 45 d8          	movzwl -0x28(%rbp),%eax
 40093de:	66 89 05 5d 5e 80 00 	mov    %ax,0x805e5d(%rip)        # 480f242 <KernelShellController+0x2>
    KernelShellController.CharacterSetType = CharacterSetType;
 40093e5:	8b 45 d4             	mov    -0x2c(%rbp),%eax
 40093e8:	89 05 56 5e 80 00    	mov    %eax,0x805e56(%rip)        # 480f244 <KernelShellController+0x4>
    KernelShellController.TopMargin = topMargin;
 40093ee:	0f b7 45 d0          	movzwl -0x30(%rbp),%eax
 40093f2:	66 89 05 4f 5e 80 00 	mov    %ax,0x805e4f(%rip)        # 480f248 <KernelShellController+0x8>
    KernelShellController.BottomMargin = bottomMargin;
 40093f9:	0f b7 45 cc          	movzwl -0x34(%rbp),%eax
 40093fd:	66 89 05 46 5e 80 00 	mov    %ax,0x805e46(%rip)        # 480f24a <KernelShellController+0xa>
    KernelShellController.LeftMargin = leftMargin;
 4009404:	0f b7 45 c8          	movzwl -0x38(%rbp),%eax
 4009408:	66 89 05 3d 5e 80 00 	mov    %ax,0x805e3d(%rip)        # 480f24c <KernelShellController+0xc>
    KernelShellController.RightMargin = rightMargin;
 400940f:	0f b7 45 c4          	movzwl -0x3c(%rbp),%eax
 4009413:	66 89 05 34 5e 80 00 	mov    %ax,0x805e34(%rip)        # 480f24e <KernelShellController+0xe>
    KernelShellController.InputTextBuffer = InputTextBuffer;
 400941a:	48 8b 45 18          	mov    0x18(%rbp),%rax
 400941e:	48 89 05 2b 5e 80 00 	mov    %rax,0x805e2b(%rip)        # 480f250 <KernelShellController+0x10>
    KernelShellController.OutputTextBuffer = OutputTextBuffer;
 4009425:	48 8b 45 20          	mov    0x20(%rbp),%rax
 4009429:	48 89 05 28 5e 80 00 	mov    %rax,0x805e28(%rip)        # 480f258 <KernelShellController+0x18>
    KernelShellController.InputTextBufferSize = InputTextBufferSize;
 4009430:	8b 45 28             	mov    0x28(%rbp),%eax
 4009433:	89 05 2f 5e 80 00    	mov    %eax,0x805e2f(%rip)        # 480f268 <KernelShellController+0x28>
    KernelShellController.OutputTextBufferSize = OutputTextBufferSize;
 4009439:	8b 45 38             	mov    0x38(%rbp),%eax
 400943c:	89 05 2a 5e 80 00    	mov    %eax,0x805e2a(%rip)        # 480f26c <KernelShellController+0x2c>
    KernelShellController.ScreenModeFlag = 0;
 4009442:	c7 05 24 5e 80 00 00 	movl   $0x0,0x805e24(%rip)        # 480f270 <KernelShellController+0x30>
 4009449:	00 00 00 
    KernelShellController.UnrenderedSpaceColor = 0x000000;
 400944c:	c7 05 22 5e 80 00 00 	movl   $0x0,0x805e22(%rip)        # 480f278 <KernelShellController+0x38>
 4009453:	00 00 00 
    KernelShellController.MarginColor = 0x000000FF;
 4009456:	c7 05 14 5e 80 00 ff 	movl   $0xff,0x805e14(%rip)        # 480f274 <KernelShellController+0x34>
 400945d:	00 00 00 
    KernelShellController.CharacterBeginX = KernelShellController.LeftMargin;
 4009460:	0f b7 05 e5 5d 80 00 	movzwl 0x805de5(%rip),%eax        # 480f24c <KernelShellController+0xc>
 4009467:	66 89 05 12 5e 80 00 	mov    %ax,0x805e12(%rip)        # 480f280 <KernelShellController+0x40>
    KernelShellController.CharacterBeginY = KernelShellController.TopMargin;
 400946e:	0f b7 05 d3 5d 80 00 	movzwl 0x805dd3(%rip),%eax        # 480f248 <KernelShellController+0x8>
 4009475:	66 89 05 06 5e 80 00 	mov    %ax,0x805e06(%rip)        # 480f282 <KernelShellController+0x42>
    KernelShellController.WindowBeginX = WindowBeginX;
 400947c:	0f b7 45 c0          	movzwl -0x40(%rbp),%eax
 4009480:	66 89 05 f5 5d 80 00 	mov    %ax,0x805df5(%rip)        # 480f27c <KernelShellController+0x3c>
    KernelShellController.WindowBeginY = WindowBeginY;
 4009487:	0f b7 45 bc          	movzwl -0x44(%rbp),%eax
 400948b:	66 89 05 ec 5d 80 00 	mov    %ax,0x805dec(%rip)        # 480f27e <KernelShellController+0x3e>
    KernelShellController.BitmapControler = GlobalBitmapControler;
 4009492:	48 8b 45 30          	mov    0x30(%rbp),%rax
 4009496:	48 89 05 c3 5d 80 00 	mov    %rax,0x805dc3(%rip)        # 480f260 <KernelShellController+0x20>
    kernelshellclearScreenInternal();   
 400949d:	e8 13 f7 ff ff       	call   4008bb5 <kernelshellclearScreenInternal()>
    drawKernelShellBorderInternal();
 40094a2:	e8 5c f7 ff ff       	call   4008c03 <drawKernelShellBorderInternal()>
    return OS_SUCCESS;
 40094a7:	b8 00 00 00 00       	mov    $0x0,%eax
}
 40094ac:	c9                   	leave
 40094ad:	c3                   	ret

00000000040094ae <InitialGlobalBasicGraphicInfo>:
    UINT32 verticalResolution,
    EFI_GRAPHICS_PIXEL_FORMAT pixelFormat,
    UINT32 PixelsPerScanLine,
    EFI_PHYSICAL_ADDRESS FrameBufferBase,
    UINT32 FrameBufferSize
){
 40094ae:	55                   	push   %rbp
 40094af:	48 89 e5             	mov    %rsp,%rbp
 40094b2:	48 83 ec 20          	sub    $0x20,%rsp
 40094b6:	89 7d fc             	mov    %edi,-0x4(%rbp)
 40094b9:	89 75 f8             	mov    %esi,-0x8(%rbp)
 40094bc:	89 55 f4             	mov    %edx,-0xc(%rbp)
 40094bf:	89 4d f0             	mov    %ecx,-0x10(%rbp)
 40094c2:	4c 89 45 e8          	mov    %r8,-0x18(%rbp)
 40094c6:	44 89 4d e4          	mov    %r9d,-0x1c(%rbp)
    // === 新增参数校验 ===
    if(horizentalResolution == 0 || verticalResolution == 0) {
 40094ca:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
 40094ce:	74 06                	je     40094d6 <InitialGlobalBasicGraphicInfo+0x28>
 40094d0:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
 40094d4:	75 16                	jne    40094ec <InitialGlobalBasicGraphicInfo+0x3e>
        DRAW_DEBUG_PRINT("InitialGlobalBasicGraphicInfo: Invalid resolution\n");
 40094d6:	48 8d 05 e3 7c 00 00 	lea    0x7ce3(%rip),%rax        # 40111c0 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0x2e8>
 40094dd:	48 89 c7             	mov    %rax,%rdi
 40094e0:	e8 6a 13 00 00       	call   400a84f <serial_puts>
        return EINVAL; // 原为OS_INVALID_ARGUMENT
 40094e5:	b8 16 00 00 00       	mov    $0x16,%eax
 40094ea:	eb 7c                	jmp    4009568 <InitialGlobalBasicGraphicInfo+0xba>
    }
    
    if(FrameBufferBase == 0 || FrameBufferSize == 0) {
 40094ec:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
 40094f1:	74 06                	je     40094f9 <InitialGlobalBasicGraphicInfo+0x4b>
 40094f3:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
 40094f7:	75 16                	jne    400950f <InitialGlobalBasicGraphicInfo+0x61>
        DRAW_DEBUG_PRINT("InitialGlobalBasicGraphicInfo: Invalid frame buffer\n");
 40094f9:	48 8d 05 f8 7c 00 00 	lea    0x7cf8(%rip),%rax        # 40111f8 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0x320>
 4009500:	48 89 c7             	mov    %rax,%rdi
 4009503:	e8 47 13 00 00       	call   400a84f <serial_puts>
        return EFAULT; // 原为OS_INVALID_ADDRESS
 4009508:	b8 0e 00 00 00       	mov    $0xe,%eax
 400950d:	eb 59                	jmp    4009568 <InitialGlobalBasicGraphicInfo+0xba>
    }
    
    if(pixelFormat != PixelBlueGreenRedReserved8BitPerColor) {
 400950f:	83 7d f4 01          	cmpl   $0x1,-0xc(%rbp)
 4009513:	74 16                	je     400952b <InitialGlobalBasicGraphicInfo+0x7d>
        DRAW_DEBUG_PRINT("InitialGlobalBasicGraphicInfo: Unsupported pixel format\n");
 4009515:	48 8d 05 14 7d 00 00 	lea    0x7d14(%rip),%rax        # 4011230 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0x358>
 400951c:	48 89 c7             	mov    %rax,%rdi
 400951f:	e8 2b 13 00 00       	call   400a84f <serial_puts>
        return EPROTONOSUPPORT; // 原为OS_UNSUPPORTED_FORMAT
 4009524:	b8 5d 00 00 00       	mov    $0x5d,%eax
 4009529:	eb 3d                	jmp    4009568 <InitialGlobalBasicGraphicInfo+0xba>
    }
    // === 校验结束 ===
    GlobalBasicGraphicInfo.horizentalResolution=horizentalResolution;
 400952b:	8b 45 fc             	mov    -0x4(%rbp),%eax
 400952e:	89 05 ec 5c 80 00    	mov    %eax,0x805cec(%rip)        # 480f220 <GlobalBasicGraphicInfo>
    GlobalBasicGraphicInfo.verticalResolution=verticalResolution;
 4009534:	8b 45 f8             	mov    -0x8(%rbp),%eax
 4009537:	89 05 e7 5c 80 00    	mov    %eax,0x805ce7(%rip)        # 480f224 <GlobalBasicGraphicInfo+0x4>
    GlobalBasicGraphicInfo.pixelFormat=pixelFormat;
 400953d:	8b 45 f4             	mov    -0xc(%rbp),%eax
 4009540:	89 05 e2 5c 80 00    	mov    %eax,0x805ce2(%rip)        # 480f228 <GlobalBasicGraphicInfo+0x8>
    GlobalBasicGraphicInfo.PixelsPerScanLine=PixelsPerScanLine;
 4009546:	8b 45 f0             	mov    -0x10(%rbp),%eax
 4009549:	89 05 dd 5c 80 00    	mov    %eax,0x805cdd(%rip)        # 480f22c <GlobalBasicGraphicInfo+0xc>
    GlobalBasicGraphicInfo.FrameBufferBase=FrameBufferBase;
 400954f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4009553:	48 89 05 d6 5c 80 00 	mov    %rax,0x805cd6(%rip)        # 480f230 <GlobalBasicGraphicInfo+0x10>
    GlobalBasicGraphicInfo.FrameBufferSize=FrameBufferSize;
 400955a:	8b 45 e4             	mov    -0x1c(%rbp),%eax
 400955d:	89 05 d5 5c 80 00    	mov    %eax,0x805cd5(%rip)        # 480f238 <GlobalBasicGraphicInfo+0x18>
    return OS_SUCCESS;
 4009563:	b8 00 00 00 00       	mov    $0x0,%eax
}
 4009568:	c9                   	leave
 4009569:	c3                   	ret

000000000400956a <InitialGlobalCharacterSetBitmapControler>:
    UINT32 CharacterColor,
    UINT8* BitMapBase,
    BOOLEAN isPreRendered,
    UINT32* ReanderedCharactersBase
)
{
 400956a:	55                   	push   %rbp
 400956b:	48 89 e5             	mov    %rsp,%rbp
 400956e:	48 83 ec 20          	sub    $0x20,%rsp
 4009572:	89 7d fc             	mov    %edi,-0x4(%rbp)
 4009575:	89 75 f8             	mov    %esi,-0x8(%rbp)
 4009578:	89 55 f4             	mov    %edx,-0xc(%rbp)
 400957b:	89 4d f0             	mov    %ecx,-0x10(%rbp)
 400957e:	4c 89 45 e8          	mov    %r8,-0x18(%rbp)
 4009582:	44 89 c8             	mov    %r9d,%eax
 4009585:	88 45 e4             	mov    %al,-0x1c(%rbp)
    // === 新增参数校验 ===
    if(CharacterHeight == 0 || CharacterWidth == 0) {
 4009588:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
 400958c:	74 06                	je     4009594 <InitialGlobalCharacterSetBitmapControler+0x2a>
 400958e:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
 4009592:	75 19                	jne    40095ad <InitialGlobalCharacterSetBitmapControler+0x43>
        DRAW_DEBUG_PRINT("InitialGlobalCharacterSetBitmapControler: Invalid character size\n");
 4009594:	48 8d 05 d5 7c 00 00 	lea    0x7cd5(%rip),%rax        # 4011270 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0x398>
 400959b:	48 89 c7             	mov    %rax,%rdi
 400959e:	e8 ac 12 00 00       	call   400a84f <serial_puts>
        return EINVAL; // 原为OS_INVALID_ARGUMENT
 40095a3:	b8 16 00 00 00       	mov    $0x16,%eax
 40095a8:	e9 ae 00 00 00       	jmp    400965b <InitialGlobalCharacterSetBitmapControler+0xf1>
    }
    
    if(BitMapBase == NULL) {
 40095ad:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
 40095b2:	75 19                	jne    40095cd <InitialGlobalCharacterSetBitmapControler+0x63>
        DRAW_DEBUG_PRINT("InitialGlobalCharacterSetBitmapControler: NULL bitmap base\n");
 40095b4:	48 8d 05 fd 7c 00 00 	lea    0x7cfd(%rip),%rax        # 40112b8 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0x3e0>
 40095bb:	48 89 c7             	mov    %rax,%rdi
 40095be:	e8 8c 12 00 00       	call   400a84f <serial_puts>
        return EFAULT; // 原为OS_INVALID_ADDRESS
 40095c3:	b8 0e 00 00 00       	mov    $0xe,%eax
 40095c8:	e9 8e 00 00 00       	jmp    400965b <InitialGlobalCharacterSetBitmapControler+0xf1>
    }
    
    if(isPreRendered && ReanderedCharactersBase == NULL) {
 40095cd:	80 7d e4 00          	cmpb   $0x0,-0x1c(%rbp)
 40095d1:	74 1d                	je     40095f0 <InitialGlobalCharacterSetBitmapControler+0x86>
 40095d3:	48 83 7d 10 00       	cmpq   $0x0,0x10(%rbp)
 40095d8:	75 16                	jne    40095f0 <InitialGlobalCharacterSetBitmapControler+0x86>
        DRAW_DEBUG_PRINT("InitialGlobalAsciiBitmapControler: Pre-rendered requires valid render base\n");
 40095da:	48 8d 05 17 7d 00 00 	lea    0x7d17(%rip),%rax        # 40112f8 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0x420>
 40095e1:	48 89 c7             	mov    %rax,%rdi
 40095e4:	e8 66 12 00 00       	call   400a84f <serial_puts>
        return EFAULT; // 原为OS_INVALID_ADDRESS
 40095e9:	b8 0e 00 00 00       	mov    $0xe,%eax
 40095ee:	eb 6b                	jmp    400965b <InitialGlobalCharacterSetBitmapControler+0xf1>
    }
    
    if(CharacterHeight > MAX_CHAR_HEIGHT || CharacterWidth > MAX_CHAR_WIDTH) {
 40095f0:	83 7d fc 40          	cmpl   $0x40,-0x4(%rbp)
 40095f4:	77 06                	ja     40095fc <InitialGlobalCharacterSetBitmapControler+0x92>
 40095f6:	83 7d f8 20          	cmpl   $0x20,-0x8(%rbp)
 40095fa:	76 16                	jbe    4009612 <InitialGlobalCharacterSetBitmapControler+0xa8>
        DRAW_DEBUG_PRINT("Character size exceeds limit (H:%d W:%d)\n");
 40095fc:	48 8d 05 45 7d 00 00 	lea    0x7d45(%rip),%rax        # 4011348 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0x470>
 4009603:	48 89 c7             	mov    %rax,%rdi
 4009606:	e8 44 12 00 00       	call   400a84f <serial_puts>
        return EDOM; // 原为OS_DIMENSION_EXCEEDED
 400960b:	b8 21 00 00 00       	mov    $0x21,%eax
 4009610:	eb 49                	jmp    400965b <InitialGlobalCharacterSetBitmapControler+0xf1>
    }
    GlobalCharacterSetBitmapControler.CharacterHeight=CharacterHeight;
 4009612:	8b 45 fc             	mov    -0x4(%rbp),%eax
 4009615:	89 05 c9 5b 80 00    	mov    %eax,0x805bc9(%rip)        # 480f1e4 <GlobalCharacterSetBitmapControler+0x4>
    GlobalCharacterSetBitmapControler.CharacterWidth=CharacterWidth;
 400961b:	8b 45 f8             	mov    -0x8(%rbp),%eax
 400961e:	89 05 bc 5b 80 00    	mov    %eax,0x805bbc(%rip)        # 480f1e0 <GlobalCharacterSetBitmapControler>
    GlobalCharacterSetBitmapControler.BackGroundColor=BackGroundColor;
 4009624:	8b 45 f4             	mov    -0xc(%rbp),%eax
 4009627:	89 05 c3 5b 80 00    	mov    %eax,0x805bc3(%rip)        # 480f1f0 <GlobalCharacterSetBitmapControler+0x10>
    GlobalCharacterSetBitmapControler.CharacterColor=CharacterColor;
 400962d:	8b 45 f0             	mov    -0x10(%rbp),%eax
 4009630:	89 05 be 5b 80 00    	mov    %eax,0x805bbe(%rip)        # 480f1f4 <GlobalCharacterSetBitmapControler+0x14>
    GlobalCharacterSetBitmapControler.BitMapBase=BitMapBase;
 4009636:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 400963a:	48 89 05 b7 5b 80 00 	mov    %rax,0x805bb7(%rip)        # 480f1f8 <GlobalCharacterSetBitmapControler+0x18>
    GlobalCharacterSetBitmapControler.isPreRendered=isPreRendered;
 4009641:	0f b6 45 e4          	movzbl -0x1c(%rbp),%eax
 4009645:	88 05 9d 5b 80 00    	mov    %al,0x805b9d(%rip)        # 480f1e8 <GlobalCharacterSetBitmapControler+0x8>
    GlobalCharacterSetBitmapControler.ReanderedCharactersBase=ReanderedCharactersBase;
 400964b:	48 8b 45 10          	mov    0x10(%rbp),%rax
 400964f:	48 89 05 aa 5b 80 00 	mov    %rax,0x805baa(%rip)        # 480f200 <GlobalCharacterSetBitmapControler+0x20>
    return OS_SUCCESS;
 4009656:	b8 00 00 00 00       	mov    $0x0,%eax
}
 400965b:	c9                   	leave
 400965c:	c3                   	ret

000000000400965d <DrawHorizentalLineSecure>:
    UINT32 length,
    UINT32 PixelData
)
/*Secure 版本是外部调用接口，会进行安全检查
*/
{
 400965d:	55                   	push   %rbp
 400965e:	48 89 e5             	mov    %rsp,%rbp
 4009661:	48 83 ec 10          	sub    $0x10,%rsp
 4009665:	89 7d fc             	mov    %edi,-0x4(%rbp)
 4009668:	89 75 f8             	mov    %esi,-0x8(%rbp)
 400966b:	89 55 f4             	mov    %edx,-0xc(%rbp)
 400966e:	89 4d f0             	mov    %ecx,-0x10(%rbp)
    DRAW_DEBUG_PRINT("DrawHorizentalLineSecure: x=%d, y=%d, length=%d\n");
 4009671:	48 8d 05 00 7d 00 00 	lea    0x7d00(%rip),%rax        # 4011378 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0x4a0>
 4009678:	48 89 c7             	mov    %rax,%rdi
 400967b:	e8 cf 11 00 00       	call   400a84f <serial_puts>
    
    if (ValidateDrawingParameters(start_vector_x, start_vector_y) != OS_SUCCESS)
 4009680:	8b 55 f8             	mov    -0x8(%rbp),%edx
 4009683:	8b 45 fc             	mov    -0x4(%rbp),%eax
 4009686:	89 d6                	mov    %edx,%esi
 4009688:	89 c7                	mov    %eax,%edi
 400968a:	e8 b0 f9 ff ff       	call   400903f <ValidateDrawingParameters(int, int)>
 400968f:	85 c0                	test   %eax,%eax
 4009691:	0f 95 c0             	setne  %al
 4009694:	84 c0                	test   %al,%al
 4009696:	74 16                	je     40096ae <DrawHorizentalLineSecure+0x51>
    {
        DRAW_DEBUG_PRINT("DrawHorizentalLineSecure: Invalid parameters\n");
 4009698:	48 8d 05 11 7d 00 00 	lea    0x7d11(%rip),%rax        # 40113b0 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0x4d8>
 400969f:	48 89 c7             	mov    %rax,%rdi
 40096a2:	e8 a8 11 00 00       	call   400a84f <serial_puts>
        return EINVAL; // 原为OS_INVALID_ARGUMENT
 40096a7:	b8 16 00 00 00       	mov    $0x16,%eax
 40096ac:	eb 4f                	jmp    40096fd <DrawHorizentalLineSecure+0xa0>
    }
    if(start_vector_x+length    >=GlobalBasicGraphicInfo.horizentalResolution) {
 40096ae:	8b 55 fc             	mov    -0x4(%rbp),%edx
 40096b1:	8b 45 f4             	mov    -0xc(%rbp),%eax
 40096b4:	01 c2                	add    %eax,%edx
 40096b6:	8b 05 64 5b 80 00    	mov    0x805b64(%rip),%eax        # 480f220 <GlobalBasicGraphicInfo>
 40096bc:	39 c2                	cmp    %eax,%edx
 40096be:	72 16                	jb     40096d6 <DrawHorizentalLineSecure+0x79>
        DRAW_DEBUG_PRINT("DrawHorizentalLineSecure: Coordinate out of range\n");
 40096c0:	48 8d 05 19 7d 00 00 	lea    0x7d19(%rip),%rax        # 40113e0 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0x508>
 40096c7:	48 89 c7             	mov    %rax,%rdi
 40096ca:	e8 80 11 00 00       	call   400a84f <serial_puts>
        return ERANGE; // 原为OS_COORDINATE_OUT_OF_RANGE
 40096cf:	b8 22 00 00 00       	mov    $0x22,%eax
 40096d4:	eb 27                	jmp    40096fd <DrawHorizentalLineSecure+0xa0>
    }
     
    DrawHorizentalLine(start_vector_x, start_vector_y, length, PixelData);
 40096d6:	8b 55 f4             	mov    -0xc(%rbp),%edx
 40096d9:	8b 4d f0             	mov    -0x10(%rbp),%ecx
 40096dc:	8b 75 f8             	mov    -0x8(%rbp),%esi
 40096df:	8b 45 fc             	mov    -0x4(%rbp),%eax
 40096e2:	89 c7                	mov    %eax,%edi
 40096e4:	e8 d2 f3 ff ff       	call   4008abb <DrawHorizentalLine(unsigned int, unsigned int, int, unsigned int)>
    DRAW_DEBUG_PRINT("DrawHorizentalLineSecure: Success\n");
 40096e9:	48 8d 05 28 7d 00 00 	lea    0x7d28(%rip),%rax        # 4011418 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0x540>
 40096f0:	48 89 c7             	mov    %rax,%rdi
 40096f3:	e8 57 11 00 00       	call   400a84f <serial_puts>
    return OS_SUCCESS;
 40096f8:	b8 00 00 00 00       	mov    $0x0,%eax
}
 40096fd:	c9                   	leave
 40096fe:	c3                   	ret

00000000040096ff <FillRectangleSecure>:

int FillRectangleSecure(int x, int y, int width, int height, UINT32 PixelData)
{
 40096ff:	55                   	push   %rbp
 4009700:	48 89 e5             	mov    %rsp,%rbp
 4009703:	48 83 ec 30          	sub    $0x30,%rsp
 4009707:	89 7d ec             	mov    %edi,-0x14(%rbp)
 400970a:	89 75 e8             	mov    %esi,-0x18(%rbp)
 400970d:	89 55 e4             	mov    %edx,-0x1c(%rbp)
 4009710:	89 4d e0             	mov    %ecx,-0x20(%rbp)
 4009713:	44 89 45 dc          	mov    %r8d,-0x24(%rbp)
    DRAW_DEBUG_PRINT("FillRectangleSecure: x=%d, y=%d, width=%d, height=%d\n");
 4009717:	48 8d 05 22 7d 00 00 	lea    0x7d22(%rip),%rax        # 4011440 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0x568>
 400971e:	48 89 c7             	mov    %rax,%rdi
 4009721:	e8 29 11 00 00       	call   400a84f <serial_puts>
    
    // 参数校验
    int status = ValidateDrawingParameters(x, y);
 4009726:	8b 55 e8             	mov    -0x18(%rbp),%edx
 4009729:	8b 45 ec             	mov    -0x14(%rbp),%eax
 400972c:	89 d6                	mov    %edx,%esi
 400972e:	89 c7                	mov    %eax,%edi
 4009730:	e8 0a f9 ff ff       	call   400903f <ValidateDrawingParameters(int, int)>
 4009735:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if(status != OS_SUCCESS) {
 4009738:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
 400973c:	74 14                	je     4009752 <FillRectangleSecure+0x53>
        DRAW_DEBUG_PRINT("FillRectangleSecure: Invalid parameters\n");
 400973e:	48 8d 05 33 7d 00 00 	lea    0x7d33(%rip),%rax        # 4011478 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0x5a0>
 4009745:	48 89 c7             	mov    %rax,%rdi
 4009748:	e8 02 11 00 00       	call   400a84f <serial_puts>
        return status;
 400974d:	8b 45 fc             	mov    -0x4(%rbp),%eax
 4009750:	eb 67                	jmp    40097b9 <FillRectangleSecure+0xba>
    }
    if (x+width>(int)GlobalBasicGraphicInfo.horizentalResolution||y+height>(int)GlobalBasicGraphicInfo.verticalResolution)
 4009752:	8b 55 ec             	mov    -0x14(%rbp),%edx
 4009755:	8b 45 e4             	mov    -0x1c(%rbp),%eax
 4009758:	01 d0                	add    %edx,%eax
 400975a:	8b 15 c0 5a 80 00    	mov    0x805ac0(%rip),%edx        # 480f220 <GlobalBasicGraphicInfo>
 4009760:	39 d0                	cmp    %edx,%eax
 4009762:	7f 12                	jg     4009776 <FillRectangleSecure+0x77>
 4009764:	8b 55 e8             	mov    -0x18(%rbp),%edx
 4009767:	8b 45 e0             	mov    -0x20(%rbp),%eax
 400976a:	01 d0                	add    %edx,%eax
 400976c:	8b 15 b2 5a 80 00    	mov    0x805ab2(%rip),%edx        # 480f224 <GlobalBasicGraphicInfo+0x4>
 4009772:	39 d0                	cmp    %edx,%eax
 4009774:	7e 16                	jle    400978c <FillRectangleSecure+0x8d>
    {
        DRAW_DEBUG_PRINT("FillRectangleSecure: Coordinate out of range\n");
 4009776:	48 8d 05 2b 7d 00 00 	lea    0x7d2b(%rip),%rax        # 40114a8 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0x5d0>
 400977d:	48 89 c7             	mov    %rax,%rdi
 4009780:	e8 ca 10 00 00       	call   400a84f <serial_puts>
        return ERANGE; // 原为OS_COORDINATE_OUT_OF_RANGE
 4009785:	b8 22 00 00 00       	mov    $0x22,%eax
 400978a:	eb 2d                	jmp    40097b9 <FillRectangleSecure+0xba>
    }
    
    // 调用内部高效实现
    FillRectangle(x, y, width, height, PixelData);
 400978c:	8b 75 e8             	mov    -0x18(%rbp),%esi
 400978f:	8b 45 ec             	mov    -0x14(%rbp),%eax
 4009792:	8b 7d dc             	mov    -0x24(%rbp),%edi
 4009795:	8b 4d e0             	mov    -0x20(%rbp),%ecx
 4009798:	8b 55 e4             	mov    -0x1c(%rbp),%edx
 400979b:	41 89 f8             	mov    %edi,%r8d
 400979e:	89 c7                	mov    %eax,%edi
 40097a0:	e8 91 f3 ff ff       	call   4008b36 <FillRectangle(unsigned int, unsigned int, int, int, unsigned int)>
    DRAW_DEBUG_PRINT("FillRectangleSecure: Success\n");
 40097a5:	48 8d 05 2a 7d 00 00 	lea    0x7d2a(%rip),%rax        # 40114d6 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0x5fe>
 40097ac:	48 89 c7             	mov    %rax,%rdi
 40097af:	e8 9b 10 00 00       	call   400a84f <serial_puts>
    return OS_SUCCESS;
 40097b4:	b8 00 00 00 00       	mov    $0x0,%eax
}
 40097b9:	c9                   	leave
 40097ba:	c3                   	ret

00000000040097bb <DrawPictureSecure>:

int DrawPictureSecure(int start_vec_x, int start_vec_y, BGRR32bitsRawPictureType* picture)
{
 40097bb:	55                   	push   %rbp
 40097bc:	48 89 e5             	mov    %rsp,%rbp
 40097bf:	48 83 ec 20          	sub    $0x20,%rsp
 40097c3:	89 7d ec             	mov    %edi,-0x14(%rbp)
 40097c6:	89 75 e8             	mov    %esi,-0x18(%rbp)
 40097c9:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
    DRAW_DEBUG_PRINT("DrawPictureSecure: x=%d, y=%d\n");
 40097cd:	48 8d 05 24 7d 00 00 	lea    0x7d24(%rip),%rax        # 40114f8 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0x620>
 40097d4:	48 89 c7             	mov    %rax,%rdi
 40097d7:	e8 73 10 00 00       	call   400a84f <serial_puts>
    
    // 参数校验
    if(picture == NULL) {
 40097dc:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
 40097e1:	75 19                	jne    40097fc <DrawPictureSecure+0x41>
        DRAW_DEBUG_PRINT("DrawPictureSecure: NULL picture pointer\n");
 40097e3:	48 8d 05 2e 7d 00 00 	lea    0x7d2e(%rip),%rax        # 4011518 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0x640>
 40097ea:	48 89 c7             	mov    %rax,%rdi
 40097ed:	e8 5d 10 00 00       	call   400a84f <serial_puts>
        return EFAULT; // 原为OS_INVALID_ADDRESS
 40097f2:	b8 0e 00 00 00       	mov    $0xe,%eax
 40097f7:	e9 cf 00 00 00       	jmp    40098cb <DrawPictureSecure+0x110>
    }
    
    int status = ValidateDrawingParameters(start_vec_x, start_vec_y);
 40097fc:	8b 55 e8             	mov    -0x18(%rbp),%edx
 40097ff:	8b 45 ec             	mov    -0x14(%rbp),%eax
 4009802:	89 d6                	mov    %edx,%esi
 4009804:	89 c7                	mov    %eax,%edi
 4009806:	e8 34 f8 ff ff       	call   400903f <ValidateDrawingParameters(int, int)>
 400980b:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if(status != OS_SUCCESS) {
 400980e:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
 4009812:	74 17                	je     400982b <DrawPictureSecure+0x70>
        DRAW_DEBUG_PRINT("DrawPictureSecure: Invalid parameters\n");
 4009814:	48 8d 05 2d 7d 00 00 	lea    0x7d2d(%rip),%rax        # 4011548 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0x670>
 400981b:	48 89 c7             	mov    %rax,%rdi
 400981e:	e8 2c 10 00 00       	call   400a84f <serial_puts>
        return status;
 4009823:	8b 45 fc             	mov    -0x4(%rbp),%eax
 4009826:	e9 a0 00 00 00       	jmp    40098cb <DrawPictureSecure+0x110>
    }
    
    // 图片数据校验
    if(picture->pixelDataBase == NULL) {
 400982b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 400982f:	48 8b 40 08          	mov    0x8(%rax),%rax
 4009833:	48 85 c0             	test   %rax,%rax
 4009836:	75 16                	jne    400984e <DrawPictureSecure+0x93>
        DRAW_DEBUG_PRINT("DrawPictureSecure: NULL pixel data\n");
 4009838:	48 8d 05 31 7d 00 00 	lea    0x7d31(%rip),%rax        # 4011570 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0x698>
 400983f:	48 89 c7             	mov    %rax,%rdi
 4009842:	e8 08 10 00 00       	call   400a84f <serial_puts>
        return EFAULT; // 原为OS_INVALID_ADDRESS
 4009847:	b8 0e 00 00 00       	mov    $0xe,%eax
 400984c:	eb 7d                	jmp    40098cb <DrawPictureSecure+0x110>
    }
    if (start_vec_x+picture->width>=GlobalBasicGraphicInfo.horizentalResolution||start_vec_y+picture->height>=GlobalBasicGraphicInfo.verticalResolution
 400984e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4009852:	8b 50 04             	mov    0x4(%rax),%edx
 4009855:	8b 45 ec             	mov    -0x14(%rbp),%eax
 4009858:	01 c2                	add    %eax,%edx
 400985a:	8b 05 c0 59 80 00    	mov    0x8059c0(%rip),%eax        # 480f220 <GlobalBasicGraphicInfo>
 4009860:	39 c2                	cmp    %eax,%edx
 4009862:	73 2a                	jae    400988e <DrawPictureSecure+0xd3>
 4009864:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 4009868:	8b 10                	mov    (%rax),%edx
 400986a:	8b 45 e8             	mov    -0x18(%rbp),%eax
 400986d:	01 c2                	add    %eax,%edx
 400986f:	8b 05 af 59 80 00    	mov    0x8059af(%rip),%eax        # 480f224 <GlobalBasicGraphicInfo+0x4>
 4009875:	39 c2                	cmp    %eax,%edx
 4009877:	73 15                	jae    400988e <DrawPictureSecure+0xd3>
    ||start_vec_y+picture->height>=GlobalBasicGraphicInfo.verticalResolution
 4009879:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
 400987d:	8b 10                	mov    (%rax),%edx
 400987f:	8b 45 e8             	mov    -0x18(%rbp),%eax
 4009882:	01 c2                	add    %eax,%edx
 4009884:	8b 05 9a 59 80 00    	mov    0x80599a(%rip),%eax        # 480f224 <GlobalBasicGraphicInfo+0x4>
 400988a:	39 c2                	cmp    %eax,%edx
 400988c:	72 16                	jb     40098a4 <DrawPictureSecure+0xe9>
    )
    {
        DRAW_DEBUG_PRINT("DrawPictureSecure: Coordinate out of range\n");
 400988e:	48 8d 05 03 7d 00 00 	lea    0x7d03(%rip),%rax        # 4011598 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0x6c0>
 4009895:	48 89 c7             	mov    %rax,%rdi
 4009898:	e8 b2 0f 00 00       	call   400a84f <serial_puts>
        return ERANGE; // 原为OS_COORDINATE_OUT_OF_RANGE
 400989d:	b8 22 00 00 00       	mov    $0x22,%eax
 40098a2:	eb 27                	jmp    40098cb <DrawPictureSecure+0x110>
    }
    
    
    // 调用内部高效实现
    DrawPicture(start_vec_x, start_vec_y, picture);
 40098a4:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
 40098a8:	8b 4d e8             	mov    -0x18(%rbp),%ecx
 40098ab:	8b 45 ec             	mov    -0x14(%rbp),%eax
 40098ae:	89 ce                	mov    %ecx,%esi
 40098b0:	89 c7                	mov    %eax,%edi
 40098b2:	e8 a5 f4 ff ff       	call   4008d5c <DrawPicture(int, int, BGRR32bitsRawPictureType*)>
    DRAW_DEBUG_PRINT("DrawPictureSecure: Success\n");
 40098b7:	48 8d 05 06 7d 00 00 	lea    0x7d06(%rip),%rax        # 40115c4 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0x6ec>
 40098be:	48 89 c7             	mov    %rax,%rdi
 40098c1:	e8 89 0f 00 00       	call   400a84f <serial_puts>
    return OS_SUCCESS;
 40098c6:	b8 00 00 00 00       	mov    $0x0,%eax
}
 40098cb:	c9                   	leave
 40098cc:	c3                   	ret

00000000040098cd <DrawVerticalLineSecure>:

int DrawVerticalLineSecure(int x, int y, int length, UINT32 PixelData)
{
 40098cd:	55                   	push   %rbp
 40098ce:	48 89 e5             	mov    %rsp,%rbp
 40098d1:	48 83 ec 20          	sub    $0x20,%rsp
 40098d5:	89 7d ec             	mov    %edi,-0x14(%rbp)
 40098d8:	89 75 e8             	mov    %esi,-0x18(%rbp)
 40098db:	89 55 e4             	mov    %edx,-0x1c(%rbp)
 40098de:	89 4d e0             	mov    %ecx,-0x20(%rbp)
    DRAW_DEBUG_PRINT("DrawVerticalLineSecure: x=%d, y=%d, length=%d\n");
 40098e1:	48 8d 05 f8 7c 00 00 	lea    0x7cf8(%rip),%rax        # 40115e0 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0x708>
 40098e8:	48 89 c7             	mov    %rax,%rdi
 40098eb:	e8 5f 0f 00 00       	call   400a84f <serial_puts>
    
    // 参数校验
    int status = ValidateDrawingParameters(x, y);
 40098f0:	8b 55 e8             	mov    -0x18(%rbp),%edx
 40098f3:	8b 45 ec             	mov    -0x14(%rbp),%eax
 40098f6:	89 d6                	mov    %edx,%esi
 40098f8:	89 c7                	mov    %eax,%edi
 40098fa:	e8 40 f7 ff ff       	call   400903f <ValidateDrawingParameters(int, int)>
 40098ff:	89 45 f8             	mov    %eax,-0x8(%rbp)
    if(status != OS_SUCCESS) {
 4009902:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
 4009906:	74 14                	je     400991c <DrawVerticalLineSecure+0x4f>
        DRAW_DEBUG_PRINT("DrawVerticalLineSecure: Invalid parameters\n");
 4009908:	48 8d 05 01 7d 00 00 	lea    0x7d01(%rip),%rax        # 4011610 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0x738>
 400990f:	48 89 c7             	mov    %rax,%rdi
 4009912:	e8 38 0f 00 00       	call   400a84f <serial_puts>
        return status;
 4009917:	8b 45 f8             	mov    -0x8(%rbp),%eax
 400991a:	eb 6b                	jmp    4009987 <DrawVerticalLineSecure+0xba>
    }
    if(y+length>=GlobalBasicGraphicInfo.verticalResolution) {
 400991c:	8b 55 e8             	mov    -0x18(%rbp),%edx
 400991f:	8b 45 e4             	mov    -0x1c(%rbp),%eax
 4009922:	01 d0                	add    %edx,%eax
 4009924:	89 c2                	mov    %eax,%edx
 4009926:	8b 05 f8 58 80 00    	mov    0x8058f8(%rip),%eax        # 480f224 <GlobalBasicGraphicInfo+0x4>
 400992c:	39 c2                	cmp    %eax,%edx
 400992e:	72 16                	jb     4009946 <DrawVerticalLineSecure+0x79>
        DRAW_DEBUG_PRINT("DrawVerticalLineSecure: Coordinate out of range\n");
 4009930:	48 8d 05 09 7d 00 00 	lea    0x7d09(%rip),%rax        # 4011640 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0x768>
 4009937:	48 89 c7             	mov    %rax,%rdi
 400993a:	e8 10 0f 00 00       	call   400a84f <serial_puts>
        return ERANGE; // 原为OS_COORDINATE_OUT_OF_RANGE
 400993f:	b8 22 00 00 00       	mov    $0x22,%eax
 4009944:	eb 41                	jmp    4009987 <DrawVerticalLineSecure+0xba>
    }
    // 内部高效实现
    for(int i = 0; i < length; i++) {
 4009946:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
 400994d:	eb 1c                	jmp    400996b <DrawVerticalLineSecure+0x9e>
        drawpixel(x, y + i, PixelData);
 400994f:	8b 55 e8             	mov    -0x18(%rbp),%edx
 4009952:	8b 45 fc             	mov    -0x4(%rbp),%eax
 4009955:	8d 0c 02             	lea    (%rdx,%rax,1),%ecx
 4009958:	8b 55 e0             	mov    -0x20(%rbp),%edx
 400995b:	8b 45 ec             	mov    -0x14(%rbp),%eax
 400995e:	89 ce                	mov    %ecx,%esi
 4009960:	89 c7                	mov    %eax,%edi
 4009962:	e8 cf f0 ff ff       	call   4008a36 <drawpixel(int, int, unsigned int)>
    for(int i = 0; i < length; i++) {
 4009967:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
 400996b:	8b 45 fc             	mov    -0x4(%rbp),%eax
 400996e:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
 4009971:	7c dc                	jl     400994f <DrawVerticalLineSecure+0x82>
    }
    
    DRAW_DEBUG_PRINT("DrawVerticalLineSecure: Success\n");
 4009973:	48 8d 05 fe 7c 00 00 	lea    0x7cfe(%rip),%rax        # 4011678 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0x7a0>
 400997a:	48 89 c7             	mov    %rax,%rdi
 400997d:	e8 cd 0e 00 00       	call   400a84f <serial_puts>
    return OS_SUCCESS;
 4009982:	b8 00 00 00 00       	mov    $0x0,%eax
}
 4009987:	c9                   	leave
 4009988:	c3                   	ret

0000000004009989 <KernelShellClearScreenSecure()>:

int KernelShellClearScreenSecure()
{
 4009989:	55                   	push   %rbp
 400998a:	48 89 e5             	mov    %rsp,%rbp
    // 检查帧缓冲区是否初始化
    if (GlobalBasicGraphicInfo.FrameBufferBase == 0 || 
 400998d:	48 8b 05 9c 58 80 00 	mov    0x80589c(%rip),%rax        # 480f230 <GlobalBasicGraphicInfo+0x10>
 4009994:	48 85 c0             	test   %rax,%rax
 4009997:	74 0a                	je     40099a3 <KernelShellClearScreenSecure()+0x1a>
        GlobalBasicGraphicInfo.FrameBufferSize == 0) {
 4009999:	8b 05 99 58 80 00    	mov    0x805899(%rip),%eax        # 480f238 <GlobalBasicGraphicInfo+0x18>
    if (GlobalBasicGraphicInfo.FrameBufferBase == 0 || 
 400999f:	85 c0                	test   %eax,%eax
 40099a1:	75 16                	jne    40099b9 <KernelShellClearScreenSecure()+0x30>
        DRAW_DEBUG_PRINT("KernelShellClearScreenSecure: Frame buffer not initialized\n");
 40099a3:	48 8d 05 f6 7c 00 00 	lea    0x7cf6(%rip),%rax        # 40116a0 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0x7c8>
 40099aa:	48 89 c7             	mov    %rax,%rdi
 40099ad:	e8 9d 0e 00 00       	call   400a84f <serial_puts>
        return ENODEV; // 原为OS_UNINITIALIZED
 40099b2:	b8 13 00 00 00       	mov    $0x13,%eax
 40099b7:	eb 38                	jmp    40099f1 <KernelShellClearScreenSecure()+0x68>
    }
    
    // 检查Shell控制器是否初始化
    if (KernelShellController.WindowWidth == 0 || 
 40099b9:	0f b7 05 82 58 80 00 	movzwl 0x805882(%rip),%eax        # 480f242 <KernelShellController+0x2>
 40099c0:	66 85 c0             	test   %ax,%ax
 40099c3:	74 0c                	je     40099d1 <KernelShellClearScreenSecure()+0x48>
        KernelShellController.WindowHeight == 0) {
 40099c5:	0f b7 05 74 58 80 00 	movzwl 0x805874(%rip),%eax        # 480f240 <KernelShellController>
    if (KernelShellController.WindowWidth == 0 || 
 40099cc:	66 85 c0             	test   %ax,%ax
 40099cf:	75 16                	jne    40099e7 <KernelShellClearScreenSecure()+0x5e>
        DRAW_DEBUG_PRINT("KernelShellClearScreenSecure: Shell controller not initialized\n");
 40099d1:	48 8d 05 08 7d 00 00 	lea    0x7d08(%rip),%rax        # 40116e0 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0x808>
 40099d8:	48 89 c7             	mov    %rax,%rdi
 40099db:	e8 6f 0e 00 00       	call   400a84f <serial_puts>
        return ENODEV; // 原为OS_UNINITIALIZED
 40099e0:	b8 13 00 00 00       	mov    $0x13,%eax
 40099e5:	eb 0a                	jmp    40099f1 <KernelShellClearScreenSecure()+0x68>
    }
    
    // 调用内部实现
    kernelshellclearScreenInternal();
 40099e7:	e8 c9 f1 ff ff       	call   4008bb5 <kernelshellclearScreenInternal()>
    return OS_SUCCESS;
 40099ec:	b8 00 00 00 00       	mov    $0x0,%eax
}
 40099f1:	5d                   	pop    %rbp
 40099f2:	c3                   	ret

00000000040099f3 <DrawKernelShellBorderSecure()>:

// 2. 渲染边框安全接口
int DrawKernelShellBorderSecure()
{
 40099f3:	55                   	push   %rbp
 40099f4:	48 89 e5             	mov    %rsp,%rbp
 40099f7:	48 83 ec 10          	sub    $0x10,%rsp
    // 检查Shell控制器是否初始化
    if (KernelShellController.WindowWidth == 0 || 
 40099fb:	0f b7 05 40 58 80 00 	movzwl 0x805840(%rip),%eax        # 480f242 <KernelShellController+0x2>
 4009a02:	66 85 c0             	test   %ax,%ax
 4009a05:	74 0c                	je     4009a13 <DrawKernelShellBorderSecure()+0x20>
        KernelShellController.WindowHeight == 0) {
 4009a07:	0f b7 05 32 58 80 00 	movzwl 0x805832(%rip),%eax        # 480f240 <KernelShellController>
    if (KernelShellController.WindowWidth == 0 || 
 4009a0e:	66 85 c0             	test   %ax,%ax
 4009a11:	75 19                	jne    4009a2c <DrawKernelShellBorderSecure()+0x39>
        DRAW_DEBUG_PRINT("DrawKernelShellBorderSecure: Shell controller not initialized\n");
 4009a13:	48 8d 05 06 7d 00 00 	lea    0x7d06(%rip),%rax        # 4011720 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0x848>
 4009a1a:	48 89 c7             	mov    %rax,%rdi
 4009a1d:	e8 2d 0e 00 00       	call   400a84f <serial_puts>
        return ENODEV; // 原为OS_UNINITIALIZED
 4009a22:	b8 13 00 00 00       	mov    $0x13,%eax
 4009a27:	e9 d6 00 00 00       	jmp    4009b02 <DrawKernelShellBorderSecure()+0x10f>
    }
    
    // 解包边距值
    UINT16 topMargin = KernelShellController.TopMargin;
 4009a2c:	0f b7 05 15 58 80 00 	movzwl 0x805815(%rip),%eax        # 480f248 <KernelShellController+0x8>
 4009a33:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
    UINT16 bottomMargin = KernelShellController.BottomMargin;
 4009a37:	0f b7 05 0c 58 80 00 	movzwl 0x80580c(%rip),%eax        # 480f24a <KernelShellController+0xa>
 4009a3e:	66 89 45 fc          	mov    %ax,-0x4(%rbp)
    UINT16 leftMargin = KernelShellController.LeftMargin;
 4009a42:	0f b7 05 03 58 80 00 	movzwl 0x805803(%rip),%eax        # 480f24c <KernelShellController+0xc>
 4009a49:	66 89 45 fa          	mov    %ax,-0x6(%rbp)
    UINT16 rightMargin = KernelShellController.RightMargin;
 4009a4d:	0f b7 05 fa 57 80 00 	movzwl 0x8057fa(%rip),%eax        # 480f24e <KernelShellController+0xe>
 4009a54:	66 89 45 f8          	mov    %ax,-0x8(%rbp)
    
    // 验证边距有效性
    if (topMargin + bottomMargin >= KernelShellController.WindowHeight ||
 4009a58:	0f b7 55 fe          	movzwl -0x2(%rbp),%edx
 4009a5c:	0f b7 45 fc          	movzwl -0x4(%rbp),%eax
 4009a60:	01 c2                	add    %eax,%edx
 4009a62:	0f b7 05 d7 57 80 00 	movzwl 0x8057d7(%rip),%eax        # 480f240 <KernelShellController>
 4009a69:	0f b7 c0             	movzwl %ax,%eax
 4009a6c:	39 c2                	cmp    %eax,%edx
 4009a6e:	7d 18                	jge    4009a88 <DrawKernelShellBorderSecure()+0x95>
        leftMargin + rightMargin >= KernelShellController.WindowWidth) {
 4009a70:	0f b7 55 fa          	movzwl -0x6(%rbp),%edx
 4009a74:	0f b7 45 f8          	movzwl -0x8(%rbp),%eax
 4009a78:	01 c2                	add    %eax,%edx
 4009a7a:	0f b7 05 c1 57 80 00 	movzwl 0x8057c1(%rip),%eax        # 480f242 <KernelShellController+0x2>
 4009a81:	0f b7 c0             	movzwl %ax,%eax
    if (topMargin + bottomMargin >= KernelShellController.WindowHeight ||
 4009a84:	39 c2                	cmp    %eax,%edx
 4009a86:	7c 16                	jl     4009a9e <DrawKernelShellBorderSecure()+0xab>
        DRAW_DEBUG_PRINT("DrawKernelShellBorderSecure: Invalid margins\n");
 4009a88:	48 8d 05 d1 7c 00 00 	lea    0x7cd1(%rip),%rax        # 4011760 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0x888>
 4009a8f:	48 89 c7             	mov    %rax,%rdi
 4009a92:	e8 b8 0d 00 00       	call   400a84f <serial_puts>
        return EINVAL; // 原为OS_INVALID_ARGUMENT
 4009a97:	b8 16 00 00 00       	mov    $0x16,%eax
 4009a9c:	eb 64                	jmp    4009b02 <DrawKernelShellBorderSecure()+0x10f>
    }
    
    // 验证窗口位置
    if (KernelShellController.WindowBeginX + KernelShellController.WindowWidth > 
 4009a9e:	0f b7 05 d7 57 80 00 	movzwl 0x8057d7(%rip),%eax        # 480f27c <KernelShellController+0x3c>
 4009aa5:	0f b7 d0             	movzwl %ax,%edx
 4009aa8:	0f b7 05 93 57 80 00 	movzwl 0x805793(%rip),%eax        # 480f242 <KernelShellController+0x2>
 4009aaf:	0f b7 c0             	movzwl %ax,%eax
 4009ab2:	01 d0                	add    %edx,%eax
 4009ab4:	89 c2                	mov    %eax,%edx
            GlobalBasicGraphicInfo.horizentalResolution ||
 4009ab6:	8b 05 64 57 80 00    	mov    0x805764(%rip),%eax        # 480f220 <GlobalBasicGraphicInfo>
    if (KernelShellController.WindowBeginX + KernelShellController.WindowWidth > 
 4009abc:	39 d0                	cmp    %edx,%eax
 4009abe:	72 22                	jb     4009ae2 <DrawKernelShellBorderSecure()+0xef>
        KernelShellController.WindowBeginY + KernelShellController.WindowHeight > 
 4009ac0:	0f b7 05 b7 57 80 00 	movzwl 0x8057b7(%rip),%eax        # 480f27e <KernelShellController+0x3e>
 4009ac7:	0f b7 d0             	movzwl %ax,%edx
 4009aca:	0f b7 05 6f 57 80 00 	movzwl 0x80576f(%rip),%eax        # 480f240 <KernelShellController>
 4009ad1:	0f b7 c0             	movzwl %ax,%eax
 4009ad4:	01 d0                	add    %edx,%eax
 4009ad6:	89 c2                	mov    %eax,%edx
            GlobalBasicGraphicInfo.verticalResolution) {
 4009ad8:	8b 05 46 57 80 00    	mov    0x805746(%rip),%eax        # 480f224 <GlobalBasicGraphicInfo+0x4>
            GlobalBasicGraphicInfo.horizentalResolution ||
 4009ade:	39 d0                	cmp    %edx,%eax
 4009ae0:	73 16                	jae    4009af8 <DrawKernelShellBorderSecure()+0x105>
        DRAW_DEBUG_PRINT("DrawKernelShellBorderSecure: Window out of bounds\n");
 4009ae2:	48 8d 05 a7 7c 00 00 	lea    0x7ca7(%rip),%rax        # 4011790 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0x8b8>
 4009ae9:	48 89 c7             	mov    %rax,%rdi
 4009aec:	e8 5e 0d 00 00       	call   400a84f <serial_puts>
        return ERANGE; // 原为OS_COORDINATE_OUT_OF_RANGE
 4009af1:	b8 22 00 00 00       	mov    $0x22,%eax
 4009af6:	eb 0a                	jmp    4009b02 <DrawKernelShellBorderSecure()+0x10f>
    }
    
    // 调用内部实现
    drawKernelShellBorderInternal();
 4009af8:	e8 06 f1 ff ff       	call   4008c03 <drawKernelShellBorderInternal()>
    return OS_SUCCESS;
 4009afd:	b8 00 00 00 00       	mov    $0x0,%eax
}
 4009b02:	c9                   	leave
 4009b03:	c3                   	ret

0000000004009b04 <DrawCharacterWithoutRenderSecure>:

int DrawCharacterWithoutRenderSecure(int start_x, int start_y, CHAR16 ch)
{
 4009b04:	55                   	push   %rbp
 4009b05:	48 89 e5             	mov    %rsp,%rbp
 4009b08:	48 83 ec 30          	sub    $0x30,%rsp
 4009b0c:	89 7d dc             	mov    %edi,-0x24(%rbp)
 4009b0f:	89 75 d8             	mov    %esi,-0x28(%rbp)
 4009b12:	89 55 d4             	mov    %edx,-0x2c(%rbp)
    DRAW_DEBUG_PRINT("DrawCharacterSecure: x=%d, y=%d, ch=0x%X\n");
 4009b15:	48 8d 05 ac 7c 00 00 	lea    0x7cac(%rip),%rax        # 40117c8 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0x8f0>
 4009b1c:	48 89 c7             	mov    %rax,%rdi
 4009b1f:	e8 2b 0d 00 00       	call   400a84f <serial_puts>

    // 检查全局位图控制器状态
    if (GlobalCharacterSetBitmapControler.BitMapBase == NULL) {
 4009b24:	48 8b 05 cd 56 80 00 	mov    0x8056cd(%rip),%rax        # 480f1f8 <GlobalCharacterSetBitmapControler+0x18>
 4009b2b:	48 85 c0             	test   %rax,%rax
 4009b2e:	75 19                	jne    4009b49 <DrawCharacterWithoutRenderSecure+0x45>
        DRAW_DEBUG_PRINT("DrawCharacterSecure: Uninitialized bitmap controller\n");
 4009b30:	48 8d 05 c1 7c 00 00 	lea    0x7cc1(%rip),%rax        # 40117f8 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0x920>
 4009b37:	48 89 c7             	mov    %rax,%rdi
 4009b3a:	e8 10 0d 00 00       	call   400a84f <serial_puts>
        return EFAULT; // 原为OS_INVALID_ADDRESS
 4009b3f:	b8 0e 00 00 00       	mov    $0xe,%eax
 4009b44:	e9 f9 00 00 00       	jmp    4009c42 <DrawCharacterWithoutRenderSecure+0x13e>
    }
    if (GlobalCharacterSetBitmapControler.CharacterWidth == 0 || 
 4009b49:	8b 05 91 56 80 00    	mov    0x805691(%rip),%eax        # 480f1e0 <GlobalCharacterSetBitmapControler>
 4009b4f:	85 c0                	test   %eax,%eax
 4009b51:	74 0a                	je     4009b5d <DrawCharacterWithoutRenderSecure+0x59>
        GlobalCharacterSetBitmapControler.CharacterHeight == 0) {
 4009b53:	8b 05 8b 56 80 00    	mov    0x80568b(%rip),%eax        # 480f1e4 <GlobalCharacterSetBitmapControler+0x4>
    if (GlobalCharacterSetBitmapControler.CharacterWidth == 0 || 
 4009b59:	85 c0                	test   %eax,%eax
 4009b5b:	75 19                	jne    4009b76 <DrawCharacterWithoutRenderSecure+0x72>
        DRAW_DEBUG_PRINT("DrawCharacterSecure: Invalid character dimensions\n");
 4009b5d:	48 8d 05 cc 7c 00 00 	lea    0x7ccc(%rip),%rax        # 4011830 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0x958>
 4009b64:	48 89 c7             	mov    %rax,%rdi
 4009b67:	e8 e3 0c 00 00       	call   400a84f <serial_puts>
        return EINVAL; // 原为OS_INVALID_ARGUMENT
 4009b6c:	b8 16 00 00 00       	mov    $0x16,%eax
 4009b71:	e9 cc 00 00 00       	jmp    4009c42 <DrawCharacterWithoutRenderSecure+0x13e>
    }

    // 验证基础坐标
    int status = ValidateDrawingParameters(start_x, start_y);
 4009b76:	8b 55 d8             	mov    -0x28(%rbp),%edx
 4009b79:	8b 45 dc             	mov    -0x24(%rbp),%eax
 4009b7c:	89 d6                	mov    %edx,%esi
 4009b7e:	89 c7                	mov    %eax,%edi
 4009b80:	e8 ba f4 ff ff       	call   400903f <ValidateDrawingParameters(int, int)>
 4009b85:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if (status != OS_SUCCESS) {
 4009b88:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
 4009b8c:	74 17                	je     4009ba5 <DrawCharacterWithoutRenderSecure+0xa1>
        DRAW_DEBUG_PRINT("DrawCharacterSecure: Invalid start coordinates\n");
 4009b8e:	48 8d 05 d3 7c 00 00 	lea    0x7cd3(%rip),%rax        # 4011868 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0x990>
 4009b95:	48 89 c7             	mov    %rax,%rdi
 4009b98:	e8 b2 0c 00 00       	call   400a84f <serial_puts>
        return status;
 4009b9d:	8b 45 fc             	mov    -0x4(%rbp),%eax
 4009ba0:	e9 9d 00 00 00       	jmp    4009c42 <DrawCharacterWithoutRenderSecure+0x13e>
    }

    // 计算字符边界
    UINT32 charWidth = GlobalCharacterSetBitmapControler.CharacterWidth;
 4009ba5:	8b 05 35 56 80 00    	mov    0x805635(%rip),%eax        # 480f1e0 <GlobalCharacterSetBitmapControler>
 4009bab:	89 45 f8             	mov    %eax,-0x8(%rbp)
    UINT32 charHeight = GlobalCharacterSetBitmapControler.CharacterHeight;
 4009bae:	8b 05 30 56 80 00    	mov    0x805630(%rip),%eax        # 480f1e4 <GlobalCharacterSetBitmapControler+0x4>
 4009bb4:	89 45 f4             	mov    %eax,-0xc(%rbp)
    UINT32 end_x = start_x + charWidth - 1;
 4009bb7:	8b 55 dc             	mov    -0x24(%rbp),%edx
 4009bba:	8b 45 f8             	mov    -0x8(%rbp),%eax
 4009bbd:	01 d0                	add    %edx,%eax
 4009bbf:	83 e8 01             	sub    $0x1,%eax
 4009bc2:	89 45 f0             	mov    %eax,-0x10(%rbp)
    UINT32 end_y = start_y + charHeight - 1;
 4009bc5:	8b 55 d8             	mov    -0x28(%rbp),%edx
 4009bc8:	8b 45 f4             	mov    -0xc(%rbp),%eax
 4009bcb:	01 d0                	add    %edx,%eax
 4009bcd:	83 e8 01             	sub    $0x1,%eax
 4009bd0:	89 45 ec             	mov    %eax,-0x14(%rbp)

    // 验证字符绘制区域
    if (end_x >= GlobalBasicGraphicInfo.horizentalResolution || 
 4009bd3:	8b 05 47 56 80 00    	mov    0x805647(%rip),%eax        # 480f220 <GlobalBasicGraphicInfo>
 4009bd9:	39 45 f0             	cmp    %eax,-0x10(%rbp)
 4009bdc:	73 0b                	jae    4009be9 <DrawCharacterWithoutRenderSecure+0xe5>
        end_y >= GlobalBasicGraphicInfo.verticalResolution) {
 4009bde:	8b 05 40 56 80 00    	mov    0x805640(%rip),%eax        # 480f224 <GlobalBasicGraphicInfo+0x4>
    if (end_x >= GlobalBasicGraphicInfo.horizentalResolution || 
 4009be4:	39 45 ec             	cmp    %eax,-0x14(%rbp)
 4009be7:	72 16                	jb     4009bff <DrawCharacterWithoutRenderSecure+0xfb>
        DRAW_DEBUG_PRINT("DrawCharacterSecure: Character out of bounds (end_x=%d, end_y=%d)\n");
 4009be9:	48 8d 05 a8 7c 00 00 	lea    0x7ca8(%rip),%rax        # 4011898 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0x9c0>
 4009bf0:	48 89 c7             	mov    %rax,%rdi
 4009bf3:	e8 57 0c 00 00       	call   400a84f <serial_puts>
        return ERANGE; // 原为OS_COORDINATE_OUT_OF_RANGE
 4009bf8:	b8 22 00 00 00       	mov    $0x22,%eax
 4009bfd:	eb 43                	jmp    4009c42 <DrawCharacterWithoutRenderSecure+0x13e>
    }

    // 调用内部绘制函数
    status = drawCharacterWithoutRendered(start_x, start_y, ch);
 4009bff:	8b 55 d4             	mov    -0x2c(%rbp),%edx
 4009c02:	8b 4d d8             	mov    -0x28(%rbp),%ecx
 4009c05:	8b 45 dc             	mov    -0x24(%rbp),%eax
 4009c08:	89 ce                	mov    %ecx,%esi
 4009c0a:	89 c7                	mov    %eax,%edi
 4009c0c:	e8 d4 f1 ff ff       	call   4008de5 <drawCharacterWithoutRendered(int, int, wchar_t)>
 4009c11:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if (status != OS_SUCCESS) {
 4009c14:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
 4009c18:	74 14                	je     4009c2e <DrawCharacterWithoutRenderSecure+0x12a>
        DRAW_DEBUG_PRINT("DrawCharacterSecure: Internal draw failed (status=%d)\n");
 4009c1a:	48 8d 05 bf 7c 00 00 	lea    0x7cbf(%rip),%rax        # 40118e0 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0xa08>
 4009c21:	48 89 c7             	mov    %rax,%rdi
 4009c24:	e8 26 0c 00 00       	call   400a84f <serial_puts>
        return status;
 4009c29:	8b 45 fc             	mov    -0x4(%rbp),%eax
 4009c2c:	eb 14                	jmp    4009c42 <DrawCharacterWithoutRenderSecure+0x13e>
    }

    DRAW_DEBUG_PRINT("DrawCharacterSecure: Character drawn successfully\n");
 4009c2e:	48 8d 05 e3 7c 00 00 	lea    0x7ce3(%rip),%rax        # 4011918 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0xa40>
 4009c35:	48 89 c7             	mov    %rax,%rdi
 4009c38:	e8 12 0c 00 00       	call   400a84f <serial_puts>
    return OS_SUCCESS;
 4009c3d:	b8 00 00 00 00       	mov    $0x0,%eax
}
 4009c42:	c9                   	leave
 4009c43:	c3                   	ret

0000000004009c44 <kernelshellmoveup(unsigned short, unsigned short, unsigned short, unsigned short, unsigned short)>:
    UINT16 yMovement,
    UINT16 ContentStartX,
    UINT16 ContentStartY,
    UINT16 ContentWidth,
    UINT16 ContentHeight
){ //此函数用lcd绝对坐标系
 4009c44:	55                   	push   %rbp
 4009c45:	48 89 e5             	mov    %rsp,%rbp
 4009c48:	48 83 ec 28          	sub    $0x28,%rsp
 4009c4c:	89 c8                	mov    %ecx,%eax
 4009c4e:	89 f9                	mov    %edi,%ecx
 4009c50:	66 89 4d ec          	mov    %cx,-0x14(%rbp)
 4009c54:	89 f1                	mov    %esi,%ecx
 4009c56:	66 89 4d e8          	mov    %cx,-0x18(%rbp)
 4009c5a:	66 89 55 e4          	mov    %dx,-0x1c(%rbp)
 4009c5e:	66 89 45 e0          	mov    %ax,-0x20(%rbp)
 4009c62:	44 89 c0             	mov    %r8d,%eax
 4009c65:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
    
    UINT32 pixel=0;
 4009c69:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
    for (int y=ContentStartY+yMovement;y<ContentStartY+ContentHeight;y++)//列移动
 4009c70:	0f b7 55 e4          	movzwl -0x1c(%rbp),%edx
 4009c74:	0f b7 45 ec          	movzwl -0x14(%rbp),%eax
 4009c78:	01 d0                	add    %edx,%eax
 4009c7a:	89 45 fc             	mov    %eax,-0x4(%rbp)
 4009c7d:	eb 4c                	jmp    4009ccb <kernelshellmoveup(unsigned short, unsigned short, unsigned short, unsigned short, unsigned short)+0x87>
    {
        for (int x=ContentStartX;x<ContentStartX+ContentWidth;x++)
 4009c7f:	0f b7 45 e8          	movzwl -0x18(%rbp),%eax
 4009c83:	89 45 f8             	mov    %eax,-0x8(%rbp)
 4009c86:	eb 30                	jmp    4009cb8 <kernelshellmoveup(unsigned short, unsigned short, unsigned short, unsigned short, unsigned short)+0x74>
        {
            pixel=getpixel(x,y);
 4009c88:	8b 55 fc             	mov    -0x4(%rbp),%edx
 4009c8b:	8b 45 f8             	mov    -0x8(%rbp),%eax
 4009c8e:	89 d6                	mov    %edx,%esi
 4009c90:	89 c7                	mov    %eax,%edi
 4009c92:	e8 e5 ed ff ff       	call   4008a7c <getpixel(int, int)>
 4009c97:	89 45 f4             	mov    %eax,-0xc(%rbp)
            drawpixel(x,y-yMovement,pixel);
 4009c9a:	0f b7 45 ec          	movzwl -0x14(%rbp),%eax
 4009c9e:	8b 55 fc             	mov    -0x4(%rbp),%edx
 4009ca1:	89 d1                	mov    %edx,%ecx
 4009ca3:	29 c1                	sub    %eax,%ecx
 4009ca5:	8b 55 f4             	mov    -0xc(%rbp),%edx
 4009ca8:	8b 45 f8             	mov    -0x8(%rbp),%eax
 4009cab:	89 ce                	mov    %ecx,%esi
 4009cad:	89 c7                	mov    %eax,%edi
 4009caf:	e8 82 ed ff ff       	call   4008a36 <drawpixel(int, int, unsigned int)>
        for (int x=ContentStartX;x<ContentStartX+ContentWidth;x++)
 4009cb4:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
 4009cb8:	0f b7 55 e8          	movzwl -0x18(%rbp),%edx
 4009cbc:	0f b7 45 e0          	movzwl -0x20(%rbp),%eax
 4009cc0:	01 d0                	add    %edx,%eax
 4009cc2:	39 45 f8             	cmp    %eax,-0x8(%rbp)
 4009cc5:	7c c1                	jl     4009c88 <kernelshellmoveup(unsigned short, unsigned short, unsigned short, unsigned short, unsigned short)+0x44>
    for (int y=ContentStartY+yMovement;y<ContentStartY+ContentHeight;y++)//列移动
 4009cc7:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
 4009ccb:	0f b7 55 e4          	movzwl -0x1c(%rbp),%edx
 4009ccf:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
 4009cd3:	01 d0                	add    %edx,%eax
 4009cd5:	39 45 fc             	cmp    %eax,-0x4(%rbp)
 4009cd8:	7c a5                	jl     4009c7f <kernelshellmoveup(unsigned short, unsigned short, unsigned short, unsigned short, unsigned short)+0x3b>
        }
    }
    FillRectangle(
 4009cda:	8b 3d 98 55 80 00    	mov    0x805598(%rip),%edi        # 480f278 <KernelShellController+0x38>
 4009ce0:	0f b7 4d ec          	movzwl -0x14(%rbp),%ecx
 4009ce4:	0f b7 55 e0          	movzwl -0x20(%rbp),%edx
        ContentStartX,
        ContentStartY+ContentHeight-yMovement,
 4009ce8:	0f b7 75 e4          	movzwl -0x1c(%rbp),%esi
 4009cec:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
 4009cf0:	01 c6                	add    %eax,%esi
 4009cf2:	0f b7 45 ec          	movzwl -0x14(%rbp),%eax
 4009cf6:	29 c6                	sub    %eax,%esi
    FillRectangle(
 4009cf8:	0f b7 45 e8          	movzwl -0x18(%rbp),%eax
 4009cfc:	41 89 f8             	mov    %edi,%r8d
 4009cff:	89 c7                	mov    %eax,%edi
 4009d01:	e8 30 ee ff ff       	call   4008b36 <FillRectangle(unsigned int, unsigned int, int, int, unsigned int)>
        ContentWidth,
        yMovement,
        KernelShellController.UnrenderedSpaceColor
    );
}
 4009d06:	90                   	nop
 4009d07:	c9                   	leave
 4009d08:	c3                   	ret

0000000004009d09 <kernelshellmoveupSecure>:
 int kernelshellmoveupSecure(int yMovement)
{ 
 4009d09:	55                   	push   %rbp
 4009d0a:	48 89 e5             	mov    %rsp,%rbp
 4009d0d:	48 83 ec 20          	sub    $0x20,%rsp
 4009d11:	89 7d ec             	mov    %edi,-0x14(%rbp)
    UINT16 ContentStartX=
    KernelShellController.WindowBeginX+
 4009d14:	0f b7 15 61 55 80 00 	movzwl 0x805561(%rip),%edx        # 480f27c <KernelShellController+0x3c>
    KernelShellController.LeftMargin;
 4009d1b:	0f b7 05 2a 55 80 00 	movzwl 0x80552a(%rip),%eax        # 480f24c <KernelShellController+0xc>
    UINT16 ContentStartX=
 4009d22:	01 d0                	add    %edx,%eax
 4009d24:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
    UINT16 ContentStartY=
    +KernelShellController.WindowBeginY+
 4009d28:	0f b7 15 4f 55 80 00 	movzwl 0x80554f(%rip),%edx        # 480f27e <KernelShellController+0x3e>
    +KernelShellController.TopMargin;
 4009d2f:	0f b7 05 12 55 80 00 	movzwl 0x805512(%rip),%eax        # 480f248 <KernelShellController+0x8>
    UINT16 ContentStartY=
 4009d36:	01 d0                	add    %edx,%eax
 4009d38:	66 89 45 fc          	mov    %ax,-0x4(%rbp)
    UINT16 ContentWidth=
    KernelShellController.WindowWidth-
 4009d3c:	0f b7 05 ff 54 80 00 	movzwl 0x8054ff(%rip),%eax        # 480f242 <KernelShellController+0x2>
    KernelShellController.LeftMargin-
 4009d43:	0f b7 15 02 55 80 00 	movzwl 0x805502(%rip),%edx        # 480f24c <KernelShellController+0xc>
    KernelShellController.WindowWidth-
 4009d4a:	29 d0                	sub    %edx,%eax
    KernelShellController.RightMargin;
 4009d4c:	0f b7 15 fb 54 80 00 	movzwl 0x8054fb(%rip),%edx        # 480f24e <KernelShellController+0xe>
    UINT16 ContentWidth=
 4009d53:	29 d0                	sub    %edx,%eax
 4009d55:	66 89 45 fa          	mov    %ax,-0x6(%rbp)
    UINT16 ContentHeight=
    KernelShellController.WindowHeight-
 4009d59:	0f b7 05 e0 54 80 00 	movzwl 0x8054e0(%rip),%eax        # 480f240 <KernelShellController>
    KernelShellController.TopMargin-
 4009d60:	0f b7 15 e1 54 80 00 	movzwl 0x8054e1(%rip),%edx        # 480f248 <KernelShellController+0x8>
    KernelShellController.WindowHeight-
 4009d67:	29 d0                	sub    %edx,%eax
    KernelShellController.BottomMargin;
 4009d69:	0f b7 15 da 54 80 00 	movzwl 0x8054da(%rip),%edx        # 480f24a <KernelShellController+0xa>
    UINT16 ContentHeight=
 4009d70:	29 d0                	sub    %edx,%eax
 4009d72:	66 89 45 f8          	mov    %ax,-0x8(%rbp)
    if (ContentStartX+ContentWidth>GlobalBasicGraphicInfo.horizentalResolution||
 4009d76:	0f b7 55 fe          	movzwl -0x2(%rbp),%edx
 4009d7a:	0f b7 45 fa          	movzwl -0x6(%rbp),%eax
 4009d7e:	01 d0                	add    %edx,%eax
 4009d80:	89 c2                	mov    %eax,%edx
 4009d82:	8b 05 98 54 80 00    	mov    0x805498(%rip),%eax        # 480f220 <GlobalBasicGraphicInfo>
 4009d88:	39 d0                	cmp    %edx,%eax
 4009d8a:	72 16                	jb     4009da2 <kernelshellmoveupSecure+0x99>
    ContentStartY+ContentHeight>GlobalBasicGraphicInfo.verticalResolution)
 4009d8c:	0f b7 55 fc          	movzwl -0x4(%rbp),%edx
 4009d90:	0f b7 45 f8          	movzwl -0x8(%rbp),%eax
 4009d94:	01 d0                	add    %edx,%eax
 4009d96:	89 c2                	mov    %eax,%edx
 4009d98:	8b 05 86 54 80 00    	mov    0x805486(%rip),%eax        # 480f224 <GlobalBasicGraphicInfo+0x4>
    if (ContentStartX+ContentWidth>GlobalBasicGraphicInfo.horizentalResolution||
 4009d9e:	39 d0                	cmp    %edx,%eax
 4009da0:	73 16                	jae    4009db8 <kernelshellmoveupSecure+0xaf>
    {
        DRAW_DEBUG_PRINT("kernelshellmoveupSecure: Window out of bounds\n");
 4009da2:	48 8d 05 a7 7b 00 00 	lea    0x7ba7(%rip),%rax        # 4011950 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0xa78>
 4009da9:	48 89 c7             	mov    %rax,%rdi
 4009dac:	e8 9e 0a 00 00       	call   400a84f <serial_puts>
        return ERANGE;
 4009db1:	b8 22 00 00 00       	mov    $0x22,%eax
 4009db6:	eb 25                	jmp    4009ddd <kernelshellmoveupSecure+0xd4>
    }
    kernelshellmoveup(yMovement,ContentStartX,ContentStartY,ContentWidth,ContentHeight);
 4009db8:	0f b7 7d f8          	movzwl -0x8(%rbp),%edi
 4009dbc:	0f b7 4d fa          	movzwl -0x6(%rbp),%ecx
 4009dc0:	0f b7 55 fc          	movzwl -0x4(%rbp),%edx
 4009dc4:	0f b7 75 fe          	movzwl -0x2(%rbp),%esi
 4009dc8:	8b 45 ec             	mov    -0x14(%rbp),%eax
 4009dcb:	0f b7 c0             	movzwl %ax,%eax
 4009dce:	41 89 f8             	mov    %edi,%r8d
 4009dd1:	89 c7                	mov    %eax,%edi
 4009dd3:	e8 6c fe ff ff       	call   4009c44 <kernelshellmoveup(unsigned short, unsigned short, unsigned short, unsigned short, unsigned short)>
    return OS_SUCCESS;
 4009dd8:	b8 00 00 00 00       	mov    $0x0,%eax
}   
 4009ddd:	c9                   	leave
 4009dde:	c3                   	ret

0000000004009ddf <kputchar(char)>:
static inline int kputchar(char ch) {
 4009ddf:	55                   	push   %rbp
 4009de0:	48 89 e5             	mov    %rsp,%rbp
 4009de3:	48 83 ec 30          	sub    $0x30,%rsp
 4009de7:	89 f8                	mov    %edi,%eax
 4009de9:	88 45 dc             	mov    %al,-0x24(%rbp)
    // 1. 获取字符尺寸
    UINT32 charWidth = KernelShellController.BitmapControler->CharacterWidth;
 4009dec:	48 8b 05 6d 54 80 00 	mov    0x80546d(%rip),%rax        # 480f260 <KernelShellController+0x20>
 4009df3:	8b 00                	mov    (%rax),%eax
 4009df5:	89 45 fc             	mov    %eax,-0x4(%rbp)
    UINT32 charHeight = KernelShellController.BitmapControler->CharacterHeight;
 4009df8:	48 8b 05 61 54 80 00 	mov    0x805461(%rip),%rax        # 480f260 <KernelShellController+0x20>
 4009dff:	8b 40 04             	mov    0x4(%rax),%eax
 4009e02:	89 45 f8             	mov    %eax,-0x8(%rbp)
    
    // 2. 计算内容区域尺寸（相对坐标）
    UINT32 contentWidth = KernelShellController.WindowWidth - 
 4009e05:	0f b7 05 36 54 80 00 	movzwl 0x805436(%rip),%eax        # 480f242 <KernelShellController+0x2>
 4009e0c:	0f b7 d0             	movzwl %ax,%edx
                          KernelShellController.LeftMargin - 
 4009e0f:	0f b7 05 36 54 80 00 	movzwl 0x805436(%rip),%eax        # 480f24c <KernelShellController+0xc>
 4009e16:	0f b7 c0             	movzwl %ax,%eax
    UINT32 contentWidth = KernelShellController.WindowWidth - 
 4009e19:	29 c2                	sub    %eax,%edx
                          KernelShellController.RightMargin;
 4009e1b:	0f b7 05 2c 54 80 00 	movzwl 0x80542c(%rip),%eax        # 480f24e <KernelShellController+0xe>
 4009e22:	0f b7 c0             	movzwl %ax,%eax
                          KernelShellController.LeftMargin - 
 4009e25:	29 c2                	sub    %eax,%edx
    UINT32 contentWidth = KernelShellController.WindowWidth - 
 4009e27:	89 55 f4             	mov    %edx,-0xc(%rbp)
    
    UINT32 contentHeight = KernelShellController.WindowHeight - 
 4009e2a:	0f b7 05 0f 54 80 00 	movzwl 0x80540f(%rip),%eax        # 480f240 <KernelShellController>
 4009e31:	0f b7 d0             	movzwl %ax,%edx
                           KernelShellController.TopMargin - 
 4009e34:	0f b7 05 0d 54 80 00 	movzwl 0x80540d(%rip),%eax        # 480f248 <KernelShellController+0x8>
 4009e3b:	0f b7 c0             	movzwl %ax,%eax
    UINT32 contentHeight = KernelShellController.WindowHeight - 
 4009e3e:	29 c2                	sub    %eax,%edx
                           KernelShellController.BottomMargin;
 4009e40:	0f b7 05 03 54 80 00 	movzwl 0x805403(%rip),%eax        # 480f24a <KernelShellController+0xa>
 4009e47:	0f b7 c0             	movzwl %ax,%eax
                           KernelShellController.TopMargin - 
 4009e4a:	29 c2                	sub    %eax,%edx
    UINT32 contentHeight = KernelShellController.WindowHeight - 
 4009e4c:	89 55 f0             	mov    %edx,-0x10(%rbp)
    //2.5 特殊字符处理
    switch (ch)
 4009e4f:	0f be 45 dc          	movsbl -0x24(%rbp),%eax
 4009e53:	83 f8 0a             	cmp    $0xa,%eax
 4009e56:	74 17                	je     4009e6f <kputchar(char)+0x90>
    {//退格符的处理交给puts使用栈数据结构处理
        case '\n':goto linebreak;

    default:
        break;
 4009e58:	90                   	nop
    }
    // 3. 检查是否需要换行（使用相对坐标）
    if((KernelShellController.CharacterBeginX + charWidth) > contentWidth) {
 4009e59:	0f b7 05 20 54 80 00 	movzwl 0x805420(%rip),%eax        # 480f280 <KernelShellController+0x40>
 4009e60:	0f b7 d0             	movzwl %ax,%edx
 4009e63:	8b 45 fc             	mov    -0x4(%rbp),%eax
 4009e66:	01 d0                	add    %edx,%eax
 4009e68:	39 45 f4             	cmp    %eax,-0xc(%rbp)
 4009e6b:	73 79                	jae    4009ee6 <kputchar(char)+0x107>
linebreak:
 4009e6d:	eb 01                	jmp    4009e70 <kputchar(char)+0x91>
        case '\n':goto linebreak;
 4009e6f:	90                   	nop
        // 换行处理
        KernelShellController.CharacterBeginX = 0; // 不是LeftMargin!
 4009e70:	66 c7 05 07 54 80 00 	movw   $0x0,0x805407(%rip)        # 480f280 <KernelShellController+0x40>
 4009e77:	00 00 
        KernelShellController.CharacterBeginY += charHeight;
 4009e79:	0f b7 05 02 54 80 00 	movzwl 0x805402(%rip),%eax        # 480f282 <KernelShellController+0x42>
 4009e80:	8b 55 f8             	mov    -0x8(%rbp),%edx
 4009e83:	01 d0                	add    %edx,%eax
 4009e85:	66 89 05 f6 53 80 00 	mov    %ax,0x8053f6(%rip)        # 480f282 <KernelShellController+0x42>
        
        // 检查是否需要滚屏
        if((KernelShellController.CharacterBeginY + charHeight) > contentHeight) {
 4009e8c:	0f b7 05 ef 53 80 00 	movzwl 0x8053ef(%rip),%eax        # 480f282 <KernelShellController+0x42>
 4009e93:	0f b7 d0             	movzwl %ax,%edx
 4009e96:	8b 45 f8             	mov    -0x8(%rbp),%eax
 4009e99:	01 d0                	add    %edx,%eax
 4009e9b:	39 45 f0             	cmp    %eax,-0x10(%rbp)
 4009e9e:	73 46                	jae    4009ee6 <kputchar(char)+0x107>
            // 记录当前Y位置（滚屏前）
            UINT16 prevY = KernelShellController.CharacterBeginY;
 4009ea0:	0f b7 05 db 53 80 00 	movzwl 0x8053db(%rip),%eax        # 480f282 <KernelShellController+0x42>
 4009ea7:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
            
            // 尝试滚屏
            int status = kernelshellmoveupSecure(charHeight);
 4009eab:	8b 45 f8             	mov    -0x8(%rbp),%eax
 4009eae:	89 c7                	mov    %eax,%edi
 4009eb0:	e8 54 fe ff ff       	call   4009d09 <kernelshellmoveupSecure>
 4009eb5:	89 45 e8             	mov    %eax,-0x18(%rbp)
            if(status != OS_SUCCESS) {
 4009eb8:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
 4009ebc:	74 13                	je     4009ed1 <kputchar(char)+0xf2>
                // 滚屏失败时恢复Y位置
                KernelShellController.CharacterBeginY = prevY;
 4009ebe:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
 4009ec2:	66 89 05 b9 53 80 00 	mov    %ax,0x8053b9(%rip)        # 480f282 <KernelShellController+0x42>
                return status;
 4009ec9:	8b 45 e8             	mov    -0x18(%rbp),%eax
 4009ecc:	e9 8a 00 00 00       	jmp    4009f5b <kputchar(char)+0x17c>
            }
            
            // 滚屏后光标定位在最后一行
            KernelShellController.CharacterBeginY = contentHeight - charHeight;
 4009ed1:	8b 45 f0             	mov    -0x10(%rbp),%eax
 4009ed4:	89 c2                	mov    %eax,%edx
 4009ed6:	8b 45 f8             	mov    -0x8(%rbp),%eax
 4009ed9:	89 c1                	mov    %eax,%ecx
 4009edb:	89 d0                	mov    %edx,%eax
 4009edd:	29 c8                	sub    %ecx,%eax
 4009edf:	66 89 05 9c 53 80 00 	mov    %ax,0x80539c(%rip)        # 480f282 <KernelShellController+0x42>
        }
    }
    
    // 4. 转换为LCD绝对坐标
    UINT16 screenX = KernelShellController.WindowBeginX + 
 4009ee6:	0f b7 15 8f 53 80 00 	movzwl 0x80538f(%rip),%edx        # 480f27c <KernelShellController+0x3c>
                     KernelShellController.LeftMargin + 
 4009eed:	0f b7 05 58 53 80 00 	movzwl 0x805358(%rip),%eax        # 480f24c <KernelShellController+0xc>
    UINT16 screenX = KernelShellController.WindowBeginX + 
 4009ef4:	01 c2                	add    %eax,%edx
                     KernelShellController.CharacterBeginX;
 4009ef6:	0f b7 05 83 53 80 00 	movzwl 0x805383(%rip),%eax        # 480f280 <KernelShellController+0x40>
    UINT16 screenX = KernelShellController.WindowBeginX + 
 4009efd:	01 d0                	add    %edx,%eax
 4009eff:	66 89 45 e6          	mov    %ax,-0x1a(%rbp)
    
    UINT16 screenY = KernelShellController.WindowBeginY + 
 4009f03:	0f b7 15 74 53 80 00 	movzwl 0x805374(%rip),%edx        # 480f27e <KernelShellController+0x3e>
                     KernelShellController.TopMargin + 
 4009f0a:	0f b7 05 37 53 80 00 	movzwl 0x805337(%rip),%eax        # 480f248 <KernelShellController+0x8>
    UINT16 screenY = KernelShellController.WindowBeginY + 
 4009f11:	01 c2                	add    %eax,%edx
                     KernelShellController.CharacterBeginY;
 4009f13:	0f b7 05 68 53 80 00 	movzwl 0x805368(%rip),%eax        # 480f282 <KernelShellController+0x42>
    UINT16 screenY = KernelShellController.WindowBeginY + 
 4009f1a:	01 d0                	add    %edx,%eax
 4009f1c:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
    
    // 5. 安全渲染
    int status = drawCharacterWithoutRendered(screenX, screenY, (UINT64)ch);
 4009f20:	0f be 55 dc          	movsbl -0x24(%rbp),%edx
 4009f24:	0f b7 4d e4          	movzwl -0x1c(%rbp),%ecx
 4009f28:	0f b7 45 e6          	movzwl -0x1a(%rbp),%eax
 4009f2c:	89 ce                	mov    %ecx,%esi
 4009f2e:	89 c7                	mov    %eax,%edi
 4009f30:	e8 b0 ee ff ff       	call   4008de5 <drawCharacterWithoutRendered(int, int, wchar_t)>
 4009f35:	89 45 e0             	mov    %eax,-0x20(%rbp)
    if(status != OS_SUCCESS) return status;
 4009f38:	83 7d e0 00          	cmpl   $0x0,-0x20(%rbp)
 4009f3c:	74 05                	je     4009f43 <kputchar(char)+0x164>
 4009f3e:	8b 45 e0             	mov    -0x20(%rbp),%eax
 4009f41:	eb 18                	jmp    4009f5b <kputchar(char)+0x17c>
    
    // 6. 更新光标位置（使用相对坐标）
    KernelShellController.CharacterBeginX += charWidth;
 4009f43:	0f b7 05 36 53 80 00 	movzwl 0x805336(%rip),%eax        # 480f280 <KernelShellController+0x40>
 4009f4a:	8b 55 fc             	mov    -0x4(%rbp),%edx
 4009f4d:	01 d0                	add    %edx,%eax
 4009f4f:	66 89 05 2a 53 80 00 	mov    %ax,0x80532a(%rip)        # 480f280 <KernelShellController+0x40>
    
    return OS_SUCCESS;
 4009f56:	b8 00 00 00 00       	mov    $0x0,%eax
}
 4009f5b:	c9                   	leave
 4009f5c:	c3                   	ret

0000000004009f5d <kputcharSecure>:
#ifdef KERNEL_MODE
int kputcharSecure(UINT8 ch)//对于特殊字符只能处理换行符，退格符等其他特殊字符交由puts使用栈数据结构处理
{
 4009f5d:	55                   	push   %rbp
 4009f5e:	48 89 e5             	mov    %rsp,%rbp
 4009f61:	48 83 ec 20          	sub    $0x20,%rsp
 4009f65:	89 f8                	mov    %edi,%eax
 4009f67:	88 45 ec             	mov    %al,-0x14(%rbp)

    // ==================== 1. 全局状态校验 ====================
    // 检查帧缓冲区是否初始化
    if (GlobalBasicGraphicInfo.FrameBufferBase == 0 || 
 4009f6a:	48 8b 05 bf 52 80 00 	mov    0x8052bf(%rip),%rax        # 480f230 <GlobalBasicGraphicInfo+0x10>
 4009f71:	48 85 c0             	test   %rax,%rax
 4009f74:	74 0a                	je     4009f80 <kputcharSecure+0x23>
        GlobalBasicGraphicInfo.FrameBufferSize == 0) {
 4009f76:	8b 05 bc 52 80 00    	mov    0x8052bc(%rip),%eax        # 480f238 <GlobalBasicGraphicInfo+0x18>
    if (GlobalBasicGraphicInfo.FrameBufferBase == 0 || 
 4009f7c:	85 c0                	test   %eax,%eax
 4009f7e:	75 19                	jne    4009f99 <kputcharSecure+0x3c>
        DRAW_DEBUG_PRINT("Frame buffer not initialized\n");
 4009f80:	48 8d 05 f8 79 00 00 	lea    0x79f8(%rip),%rax        # 401197f <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0xaa7>
 4009f87:	48 89 c7             	mov    %rax,%rdi
 4009f8a:	e8 c0 08 00 00       	call   400a84f <serial_puts>
        return ENODEV; // 设备未准备好
 4009f8f:	b8 13 00 00 00       	mov    $0x13,%eax
 4009f94:	e9 35 01 00 00       	jmp    400a0ce <kputcharSecure+0x171>
    }

    // 检查Shell控制器是否初始化
    if (KernelShellController.WindowWidth == 0 || 
 4009f99:	0f b7 05 a2 52 80 00 	movzwl 0x8052a2(%rip),%eax        # 480f242 <KernelShellController+0x2>
 4009fa0:	66 85 c0             	test   %ax,%ax
 4009fa3:	74 0c                	je     4009fb1 <kputcharSecure+0x54>
        KernelShellController.WindowHeight == 0) {
 4009fa5:	0f b7 05 94 52 80 00 	movzwl 0x805294(%rip),%eax        # 480f240 <KernelShellController>
    if (KernelShellController.WindowWidth == 0 || 
 4009fac:	66 85 c0             	test   %ax,%ax
 4009faf:	75 19                	jne    4009fca <kputcharSecure+0x6d>
        DRAW_DEBUG_PRINT("Shell controller not initialized\n");
 4009fb1:	48 8d 05 e8 79 00 00 	lea    0x79e8(%rip),%rax        # 40119a0 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0xac8>
 4009fb8:	48 89 c7             	mov    %rax,%rdi
 4009fbb:	e8 8f 08 00 00       	call   400a84f <serial_puts>
        return ENODEV;
 4009fc0:	b8 13 00 00 00       	mov    $0x13,%eax
 4009fc5:	e9 04 01 00 00       	jmp    400a0ce <kputcharSecure+0x171>
    }

    // 检查位图控制器有效性
    if (KernelShellController.BitmapControler == NULL ||
 4009fca:	48 8b 05 8f 52 80 00 	mov    0x80528f(%rip),%rax        # 480f260 <KernelShellController+0x20>
 4009fd1:	48 85 c0             	test   %rax,%rax
 4009fd4:	74 10                	je     4009fe6 <kputcharSecure+0x89>
        KernelShellController.BitmapControler->BitMapBase == NULL) {
 4009fd6:	48 8b 05 83 52 80 00 	mov    0x805283(%rip),%rax        # 480f260 <KernelShellController+0x20>
 4009fdd:	48 8b 40 18          	mov    0x18(%rax),%rax
    if (KernelShellController.BitmapControler == NULL ||
 4009fe1:	48 85 c0             	test   %rax,%rax
 4009fe4:	75 19                	jne    4009fff <kputcharSecure+0xa2>
        DRAW_DEBUG_PRINT("Invalid bitmap controller\n");
 4009fe6:	48 8d 05 d5 79 00 00 	lea    0x79d5(%rip),%rax        # 40119c2 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0xaea>
 4009fed:	48 89 c7             	mov    %rax,%rdi
 4009ff0:	e8 5a 08 00 00       	call   400a84f <serial_puts>
        return EFAULT; // 错误的内存地址
 4009ff5:	b8 0e 00 00 00       	mov    $0xe,%eax
 4009ffa:	e9 cf 00 00 00       	jmp    400a0ce <kputcharSecure+0x171>
    }

    // ==================== 2. 字符尺寸校验 ====================
    UINT32 charWidth = KernelShellController.BitmapControler->CharacterWidth;
 4009fff:	48 8b 05 5a 52 80 00 	mov    0x80525a(%rip),%rax        # 480f260 <KernelShellController+0x20>
 400a006:	8b 00                	mov    (%rax),%eax
 400a008:	89 45 fc             	mov    %eax,-0x4(%rbp)
    UINT32 charHeight = KernelShellController.BitmapControler->CharacterHeight;
 400a00b:	48 8b 05 4e 52 80 00 	mov    0x80524e(%rip),%rax        # 480f260 <KernelShellController+0x20>
 400a012:	8b 40 04             	mov    0x4(%rax),%eax
 400a015:	89 45 f8             	mov    %eax,-0x8(%rbp)
    
    if (charWidth == 0 || charHeight == 0) {
 400a018:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
 400a01c:	74 06                	je     400a024 <kputcharSecure+0xc7>
 400a01e:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
 400a022:	75 19                	jne    400a03d <kputcharSecure+0xe0>
        DRAW_DEBUG_PRINT("Invalid character dimensions\n");
 400a024:	48 8d 05 b2 79 00 00 	lea    0x79b2(%rip),%rax        # 40119dd <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0xb05>
 400a02b:	48 89 c7             	mov    %rax,%rdi
 400a02e:	e8 1c 08 00 00       	call   400a84f <serial_puts>
        return EINVAL; // 无效参数
 400a033:	b8 16 00 00 00       	mov    $0x16,%eax
 400a038:	e9 91 00 00 00       	jmp    400a0ce <kputcharSecure+0x171>

    

    // ==================== 4. 边界安全检查 ====================
    // 计算内容区域尺寸 (相对坐标)
    UINT32 contentWidth = KernelShellController.WindowWidth - 
 400a03d:	0f b7 05 fe 51 80 00 	movzwl 0x8051fe(%rip),%eax        # 480f242 <KernelShellController+0x2>
 400a044:	0f b7 d0             	movzwl %ax,%edx
                          KernelShellController.LeftMargin - 
 400a047:	0f b7 05 fe 51 80 00 	movzwl 0x8051fe(%rip),%eax        # 480f24c <KernelShellController+0xc>
 400a04e:	0f b7 c0             	movzwl %ax,%eax
    UINT32 contentWidth = KernelShellController.WindowWidth - 
 400a051:	29 c2                	sub    %eax,%edx
                          KernelShellController.RightMargin;
 400a053:	0f b7 05 f4 51 80 00 	movzwl 0x8051f4(%rip),%eax        # 480f24e <KernelShellController+0xe>
 400a05a:	0f b7 c0             	movzwl %ax,%eax
                          KernelShellController.LeftMargin - 
 400a05d:	29 c2                	sub    %eax,%edx
    UINT32 contentWidth = KernelShellController.WindowWidth - 
 400a05f:	89 55 f4             	mov    %edx,-0xc(%rbp)
    
    UINT32 contentHeight = KernelShellController.WindowHeight - 
 400a062:	0f b7 05 d7 51 80 00 	movzwl 0x8051d7(%rip),%eax        # 480f240 <KernelShellController>
 400a069:	0f b7 d0             	movzwl %ax,%edx
                           KernelShellController.TopMargin - 
 400a06c:	0f b7 05 d5 51 80 00 	movzwl 0x8051d5(%rip),%eax        # 480f248 <KernelShellController+0x8>
 400a073:	0f b7 c0             	movzwl %ax,%eax
    UINT32 contentHeight = KernelShellController.WindowHeight - 
 400a076:	29 c2                	sub    %eax,%edx
                           KernelShellController.BottomMargin;
 400a078:	0f b7 05 cb 51 80 00 	movzwl 0x8051cb(%rip),%eax        # 480f24a <KernelShellController+0xa>
 400a07f:	0f b7 c0             	movzwl %ax,%eax
                           KernelShellController.TopMargin - 
 400a082:	29 c2                	sub    %eax,%edx
    UINT32 contentHeight = KernelShellController.WindowHeight - 
 400a084:	89 55 f0             	mov    %edx,-0x10(%rbp)

    // 检查当前光标是否越界
    if (KernelShellController.CharacterBeginX > contentWidth ||
 400a087:	0f b7 05 f2 51 80 00 	movzwl 0x8051f2(%rip),%eax        # 480f280 <KernelShellController+0x40>
 400a08e:	0f b7 c0             	movzwl %ax,%eax
 400a091:	39 45 f4             	cmp    %eax,-0xc(%rbp)
 400a094:	72 0f                	jb     400a0a5 <kputcharSecure+0x148>
        KernelShellController.CharacterBeginY > contentHeight) {
 400a096:	0f b7 05 e5 51 80 00 	movzwl 0x8051e5(%rip),%eax        # 480f282 <KernelShellController+0x42>
 400a09d:	0f b7 c0             	movzwl %ax,%eax
    if (KernelShellController.CharacterBeginX > contentWidth ||
 400a0a0:	39 45 f0             	cmp    %eax,-0x10(%rbp)
 400a0a3:	73 16                	jae    400a0bb <kputcharSecure+0x15e>
        DRAW_DEBUG_PRINT("Cursor out of bounds\n");
 400a0a5:	48 8d 05 4f 79 00 00 	lea    0x794f(%rip),%rax        # 40119fb <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0xb23>
 400a0ac:	48 89 c7             	mov    %rax,%rdi
 400a0af:	e8 9b 07 00 00       	call   400a84f <serial_puts>
        return ERANGE; // 超出范围
 400a0b4:	b8 22 00 00 00       	mov    $0x22,%eax
 400a0b9:	eb 13                	jmp    400a0ce <kputcharSecure+0x171>
    }
    kputchar(ch);
 400a0bb:	0f b6 45 ec          	movzbl -0x14(%rbp),%eax
 400a0bf:	0f be c0             	movsbl %al,%eax
 400a0c2:	89 c7                	mov    %eax,%edi
 400a0c4:	e8 16 fd ff ff       	call   4009ddf <kputchar(char)>
    return OS_SUCCESS; 
 400a0c9:	b8 00 00 00 00       	mov    $0x0,%eax
}
 400a0ce:	c9                   	leave
 400a0cf:	c3                   	ret

000000000400a0d0 <kputsascii(char*)>:
    return OS_SUCCESS;
}
#endif
#define TextBufferMaxCount 4096
static inline void kputsascii(char*strbuff)//只会打印到屏幕，不会打印到串口
{
 400a0d0:	55                   	push   %rbp
 400a0d1:	48 89 e5             	mov    %rsp,%rbp
 400a0d4:	48 83 ec 20          	sub    $0x20,%rsp
 400a0d8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    //缓冲区制作
    char ch=0;
 400a0dc:	c6 45 f3 00          	movb   $0x0,-0xd(%rbp)
    int i1=0;
 400a0e0:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
    for(int i=0;i>=0&&i<TextBufferMaxCount;i++)
 400a0e7:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
 400a0ee:	e9 86 00 00 00       	jmp    400a179 <kputsascii(char*)+0xa9>
    {
        ch=strbuff[i];
 400a0f3:	8b 45 f8             	mov    -0x8(%rbp),%eax
 400a0f6:	48 63 d0             	movslq %eax,%rdx
 400a0f9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 400a0fd:	48 01 d0             	add    %rdx,%rax
 400a100:	0f b6 00             	movzbl (%rax),%eax
 400a103:	88 45 f3             	mov    %al,-0xd(%rbp)
        if(32<=ch&&ch<=126)
 400a106:	80 7d f3 1f          	cmpb   $0x1f,-0xd(%rbp)
 400a10a:	7e 1f                	jle    400a12b <kputsascii(char*)+0x5b>
 400a10c:	80 7d f3 7f          	cmpb   $0x7f,-0xd(%rbp)
 400a110:	74 19                	je     400a12b <kputsascii(char*)+0x5b>
        {GlobalKernelShellOutputBuffer[i1]=ch;
 400a112:	0f b6 55 f3          	movzbl -0xd(%rbp),%edx
 400a116:	8b 45 fc             	mov    -0x4(%rbp),%eax
 400a119:	48 98                	cltq
 400a11b:	48 8d 0d be 40 80 00 	lea    0x8040be(%rip),%rcx        # 480e1e0 <GlobalKernelShellOutputBuffer>
 400a122:	88 14 08             	mov    %dl,(%rax,%rcx,1)
        i1++;}
 400a125:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
 400a129:	eb 4a                	jmp    400a175 <kputsascii(char*)+0xa5>
        else{
            switch (ch)
 400a12b:	0f be 45 f3          	movsbl -0xd(%rbp),%eax
 400a12f:	83 f8 0d             	cmp    $0xd,%eax
 400a132:	74 37                	je     400a16b <kputsascii(char*)+0x9b>
 400a134:	83 f8 0d             	cmp    $0xd,%eax
 400a137:	7f 3b                	jg     400a174 <kputsascii(char*)+0xa4>
 400a139:	83 f8 0a             	cmp    $0xa,%eax
 400a13c:	74 14                	je     400a152 <kputsascii(char*)+0x82>
 400a13e:	83 f8 0a             	cmp    $0xa,%eax
 400a141:	7f 31                	jg     400a174 <kputsascii(char*)+0xa4>
 400a143:	85 c0                	test   %eax,%eax
 400a145:	74 47                	je     400a18e <kputsascii(char*)+0xbe>
 400a147:	83 f8 08             	cmp    $0x8,%eax
 400a14a:	75 28                	jne    400a174 <kputsascii(char*)+0xa4>
            {
            case '\b':
                i1--;
 400a14c:	83 6d fc 01          	subl   $0x1,-0x4(%rbp)
                break;
 400a150:	eb 23                	jmp    400a175 <kputsascii(char*)+0xa5>
            case '\n':
            GlobalKernelShellOutputBuffer[i1]=ch;
 400a152:	0f b6 55 f3          	movzbl -0xd(%rbp),%edx
 400a156:	8b 45 fc             	mov    -0x4(%rbp),%eax
 400a159:	48 98                	cltq
 400a15b:	48 8d 0d 7e 40 80 00 	lea    0x80407e(%rip),%rcx        # 480e1e0 <GlobalKernelShellOutputBuffer>
 400a162:	88 14 08             	mov    %dl,(%rax,%rcx,1)
            i1++;
 400a165:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
            break;
 400a169:	eb 0a                	jmp    400a175 <kputsascii(char*)+0xa5>
            case '\r':
                i1=0;
 400a16b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
                break;
 400a172:	eb 01                	jmp    400a175 <kputsascii(char*)+0xa5>
            case 0:
                goto bufferout;
                
            default:
                break;
 400a174:	90                   	nop
    for(int i=0;i>=0&&i<TextBufferMaxCount;i++)
 400a175:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
 400a179:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
 400a17d:	78 12                	js     400a191 <kputsascii(char*)+0xc1>
 400a17f:	81 7d f8 ff 0f 00 00 	cmpl   $0xfff,-0x8(%rbp)
 400a186:	0f 8e 67 ff ff ff    	jle    400a0f3 <kputsascii(char*)+0x23>
            }
        }
    }
bufferout:    
 400a18c:	eb 03                	jmp    400a191 <kputsascii(char*)+0xc1>
                goto bufferout;
 400a18e:	90                   	nop
 400a18f:	eb 01                	jmp    400a192 <kputsascii(char*)+0xc2>
bufferout:    
 400a191:	90                   	nop
    for(int i2=0;i2<i1;i2++)
 400a192:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
 400a199:	eb 1e                	jmp    400a1b9 <kputsascii(char*)+0xe9>
    {
        kputchar(GlobalKernelShellOutputBuffer[i2]);
 400a19b:	8b 45 f4             	mov    -0xc(%rbp),%eax
 400a19e:	48 98                	cltq
 400a1a0:	48 8d 15 39 40 80 00 	lea    0x804039(%rip),%rdx        # 480e1e0 <GlobalKernelShellOutputBuffer>
 400a1a7:	0f b6 04 10          	movzbl (%rax,%rdx,1),%eax
 400a1ab:	0f be c0             	movsbl %al,%eax
 400a1ae:	89 c7                	mov    %eax,%edi
 400a1b0:	e8 2a fc ff ff       	call   4009ddf <kputchar(char)>
    for(int i2=0;i2<i1;i2++)
 400a1b5:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
 400a1b9:	8b 45 f4             	mov    -0xc(%rbp),%eax
 400a1bc:	3b 45 fc             	cmp    -0x4(%rbp),%eax
 400a1bf:	7c da                	jl     400a19b <kputsascii(char*)+0xcb>
    }

}
 400a1c1:	90                   	nop
 400a1c2:	90                   	nop
 400a1c3:	c9                   	leave
 400a1c4:	c3                   	ret

000000000400a1c5 <kputsSecure>:
#ifdef KERNEL_MODE
int kputsSecure(char*strbuff)
{
 400a1c5:	55                   	push   %rbp
 400a1c6:	48 89 e5             	mov    %rsp,%rbp
 400a1c9:	48 83 ec 20          	sub    $0x20,%rsp
 400a1cd:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    // 检查帧缓冲区是否初始化
    if (GlobalBasicGraphicInfo.FrameBufferBase == 0 || 
 400a1d1:	48 8b 05 58 50 80 00 	mov    0x805058(%rip),%rax        # 480f230 <GlobalBasicGraphicInfo+0x10>
 400a1d8:	48 85 c0             	test   %rax,%rax
 400a1db:	74 0a                	je     400a1e7 <kputsSecure+0x22>
        GlobalBasicGraphicInfo.FrameBufferSize == 0) {
 400a1dd:	8b 05 55 50 80 00    	mov    0x805055(%rip),%eax        # 480f238 <GlobalBasicGraphicInfo+0x18>
    if (GlobalBasicGraphicInfo.FrameBufferBase == 0 || 
 400a1e3:	85 c0                	test   %eax,%eax
 400a1e5:	75 19                	jne    400a200 <kputsSecure+0x3b>
        DRAW_DEBUG_PRINT("Frame buffer not initialized\n");
 400a1e7:	48 8d 05 91 77 00 00 	lea    0x7791(%rip),%rax        # 401197f <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0xaa7>
 400a1ee:	48 89 c7             	mov    %rax,%rdi
 400a1f1:	e8 59 06 00 00       	call   400a84f <serial_puts>
        return ENODEV; // 设备未准备好
 400a1f6:	b8 13 00 00 00       	mov    $0x13,%eax
 400a1fb:	e9 04 01 00 00       	jmp    400a304 <kputsSecure+0x13f>
    }

    // 检查Shell控制器是否初始化
    if (KernelShellController.WindowWidth == 0 || 
 400a200:	0f b7 05 3b 50 80 00 	movzwl 0x80503b(%rip),%eax        # 480f242 <KernelShellController+0x2>
 400a207:	66 85 c0             	test   %ax,%ax
 400a20a:	74 0c                	je     400a218 <kputsSecure+0x53>
        KernelShellController.WindowHeight == 0) {
 400a20c:	0f b7 05 2d 50 80 00 	movzwl 0x80502d(%rip),%eax        # 480f240 <KernelShellController>
    if (KernelShellController.WindowWidth == 0 || 
 400a213:	66 85 c0             	test   %ax,%ax
 400a216:	75 19                	jne    400a231 <kputsSecure+0x6c>
        DRAW_DEBUG_PRINT("Shell controller not initialized\n");
 400a218:	48 8d 05 81 77 00 00 	lea    0x7781(%rip),%rax        # 40119a0 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0xac8>
 400a21f:	48 89 c7             	mov    %rax,%rdi
 400a222:	e8 28 06 00 00       	call   400a84f <serial_puts>
        return ENODEV;
 400a227:	b8 13 00 00 00       	mov    $0x13,%eax
 400a22c:	e9 d3 00 00 00       	jmp    400a304 <kputsSecure+0x13f>
    }

    // 检查位图控制器有效性
    if (KernelShellController.BitmapControler == NULL ||
 400a231:	48 8b 05 28 50 80 00 	mov    0x805028(%rip),%rax        # 480f260 <KernelShellController+0x20>
 400a238:	48 85 c0             	test   %rax,%rax
 400a23b:	74 10                	je     400a24d <kputsSecure+0x88>
        KernelShellController.BitmapControler->BitMapBase == NULL) {
 400a23d:	48 8b 05 1c 50 80 00 	mov    0x80501c(%rip),%rax        # 480f260 <KernelShellController+0x20>
 400a244:	48 8b 40 18          	mov    0x18(%rax),%rax
    if (KernelShellController.BitmapControler == NULL ||
 400a248:	48 85 c0             	test   %rax,%rax
 400a24b:	75 19                	jne    400a266 <kputsSecure+0xa1>
        DRAW_DEBUG_PRINT("Invalid bitmap controller\n");
 400a24d:	48 8d 05 6e 77 00 00 	lea    0x776e(%rip),%rax        # 40119c2 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0xaea>
 400a254:	48 89 c7             	mov    %rax,%rdi
 400a257:	e8 f3 05 00 00       	call   400a84f <serial_puts>
        return EFAULT; // 错误的内存地址
 400a25c:	b8 0e 00 00 00       	mov    $0xe,%eax
 400a261:	e9 9e 00 00 00       	jmp    400a304 <kputsSecure+0x13f>
    }

    // ==================== 2. 字符尺寸校验 ====================
    UINT32 charWidth = KernelShellController.BitmapControler->CharacterWidth;
 400a266:	48 8b 05 f3 4f 80 00 	mov    0x804ff3(%rip),%rax        # 480f260 <KernelShellController+0x20>
 400a26d:	8b 00                	mov    (%rax),%eax
 400a26f:	89 45 fc             	mov    %eax,-0x4(%rbp)
    UINT32 charHeight = KernelShellController.BitmapControler->CharacterHeight;
 400a272:	48 8b 05 e7 4f 80 00 	mov    0x804fe7(%rip),%rax        # 480f260 <KernelShellController+0x20>
 400a279:	8b 40 04             	mov    0x4(%rax),%eax
 400a27c:	89 45 f8             	mov    %eax,-0x8(%rbp)
    
    if (charWidth == 0 || charHeight == 0) {
 400a27f:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
 400a283:	74 06                	je     400a28b <kputsSecure+0xc6>
 400a285:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
 400a289:	75 16                	jne    400a2a1 <kputsSecure+0xdc>
        DRAW_DEBUG_PRINT("Invalid character dimensions\n");
 400a28b:	48 8d 05 4b 77 00 00 	lea    0x774b(%rip),%rax        # 40119dd <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0xb05>
 400a292:	48 89 c7             	mov    %rax,%rdi
 400a295:	e8 b5 05 00 00       	call   400a84f <serial_puts>
        return EINVAL; // 无效参数
 400a29a:	b8 16 00 00 00       	mov    $0x16,%eax
 400a29f:	eb 63                	jmp    400a304 <kputsSecure+0x13f>
    }
    switch (KernelShellController.CharacterSetType)
 400a2a1:	8b 05 9d 4f 80 00    	mov    0x804f9d(%rip),%eax        # 480f244 <KernelShellController+0x4>
 400a2a7:	85 c0                	test   %eax,%eax
 400a2a9:	74 1b                	je     400a2c6 <kputsSecure+0x101>
 400a2ab:	83 f8 01             	cmp    $0x1,%eax
 400a2ae:	75 40                	jne    400a2f0 <kputsSecure+0x12b>
    {
    case UTF_8:
        DRAW_DEBUG_PRINT("UTF-8 is not supported\n");
 400a2b0:	48 8d 05 5a 77 00 00 	lea    0x775a(%rip),%rax        # 4011a11 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0xb39>
 400a2b7:	48 89 c7             	mov    %rax,%rdi
 400a2ba:	e8 90 05 00 00       	call   400a84f <serial_puts>
        return EOPNOTSUPP;
 400a2bf:	b8 5f 00 00 00       	mov    $0x5f,%eax
 400a2c4:	eb 3e                	jmp    400a304 <kputsSecure+0x13f>
    case ASCII:
#ifdef PRINT_OUT
    kputsascii(strbuff);
    
#endif
        SERIAL_PUTS(strbuff);
 400a2c6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 400a2ca:	48 89 c7             	mov    %rax,%rdi
 400a2cd:	e8 7d 05 00 00       	call   400a84f <serial_puts>
        gkcirclebufflogMgr.putsk(strbuff);
 400a2d2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 400a2d6:	48 8d 15 33 5d 7f 00 	lea    0x7f5d33(%rip),%rdx        # 4800010 <gkcirclebufflogMgr>
 400a2dd:	48 89 c6             	mov    %rax,%rsi
 400a2e0:	48 89 d7             	mov    %rdx,%rdi
 400a2e3:	e8 54 60 ff ff       	call   400033c <kcirclebufflogMgr::putsk(char*)>
        break;
 400a2e8:	90                   	nop
    default:
        DRAW_DEBUG_PRINT("Invalid character set type\n");
        return EINVAL;

    }
    return OS_SUCCESS;
 400a2e9:	b8 00 00 00 00       	mov    $0x0,%eax
 400a2ee:	eb 14                	jmp    400a304 <kputsSecure+0x13f>
        DRAW_DEBUG_PRINT("Invalid character set type\n");
 400a2f0:	48 8d 05 32 77 00 00 	lea    0x7732(%rip),%rax        # 4011a29 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0xb51>
 400a2f7:	48 89 c7             	mov    %rax,%rdi
 400a2fa:	e8 50 05 00 00       	call   400a84f <serial_puts>
        return EINVAL;
 400a2ff:	b8 16 00 00 00       	mov    $0x16,%eax
}
 400a304:	c9                   	leave
 400a305:	c3                   	ret

000000000400a306 <kpnumSecure>:
#endif
#ifdef KERNEL_MODE


int kpnumSecure(void* numptr, int format, int len)//有符号十进制的情况下只能处理1,2,4,8字节
{
 400a306:	55                   	push   %rbp
 400a307:	48 89 e5             	mov    %rsp,%rbp
 400a30a:	48 81 ec b0 00 00 00 	sub    $0xb0,%rsp
 400a311:	48 89 bd 58 ff ff ff 	mov    %rdi,-0xa8(%rbp)
 400a318:	89 b5 54 ff ff ff    	mov    %esi,-0xac(%rbp)
 400a31e:	89 95 50 ff ff ff    	mov    %edx,-0xb0(%rbp)
    /* 安全校验 */
    switch (format) {
 400a324:	83 bd 54 ff ff ff 01 	cmpl   $0x1,-0xac(%rbp)
 400a32b:	74 30                	je     400a35d <kpnumSecure+0x57>
 400a32d:	83 bd 54 ff ff ff 00 	cmpl   $0x0,-0xac(%rbp)
 400a334:	7e 0e                	jle    400a344 <kpnumSecure+0x3e>
 400a336:	8b 85 54 ff ff ff    	mov    -0xac(%rbp),%eax
 400a33c:	83 e8 03             	sub    $0x3,%eax
 400a33f:	83 f8 02             	cmp    $0x2,%eax
 400a342:	76 19                	jbe    400a35d <kpnumSecure+0x57>
    case UNDEC:
    case INDEC:
    case UNHEX:
        break;
    default:
        DRAW_DEBUG_PRINT("Invalid number format\n");
 400a344:	48 8d 05 fa 76 00 00 	lea    0x76fa(%rip),%rax        # 4011a45 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0xb6d>
 400a34b:	48 89 c7             	mov    %rax,%rdi
 400a34e:	e8 fc 04 00 00       	call   400a84f <serial_puts>
        return EINVAL;
 400a353:	b8 16 00 00 00       	mov    $0x16,%eax
 400a358:	e9 12 04 00 00       	jmp    400a76f <kpnumSecure+0x469>
        break;
 400a35d:	90                   	nop
    }

    if (len < 1 || len > 8) {
 400a35e:	83 bd 50 ff ff ff 00 	cmpl   $0x0,-0xb0(%rbp)
 400a365:	7e 09                	jle    400a370 <kpnumSecure+0x6a>
 400a367:	83 bd 50 ff ff ff 08 	cmpl   $0x8,-0xb0(%rbp)
 400a36e:	7e 19                	jle    400a389 <kpnumSecure+0x83>
        DRAW_DEBUG_PRINT("Invalid length, must be 1~8\n");
 400a370:	48 8d 05 e5 76 00 00 	lea    0x76e5(%rip),%rax        # 4011a5c <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0xb84>
 400a377:	48 89 c7             	mov    %rax,%rdi
 400a37a:	e8 d0 04 00 00       	call   400a84f <serial_puts>
        return EINVAL;
 400a37f:	b8 16 00 00 00       	mov    $0x16,%eax
 400a384:	e9 e6 03 00 00       	jmp    400a76f <kpnumSecure+0x469>
    }

    uint64_t num = 0;
 400a389:	48 c7 45 a8 00 00 00 	movq   $0x0,-0x58(%rbp)
 400a390:	00 
    unsigned char* src = (unsigned char*)numptr;
 400a391:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
 400a398:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    unsigned char* dst = (unsigned char*)&num;
 400a39c:	48 8d 45 a8          	lea    -0x58(%rbp),%rax
 400a3a0:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    
    // 复制数据到num的低字节部分
    for (int i = 0; i < len; i++) {
 400a3a4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
 400a3ab:	eb 23                	jmp    400a3d0 <kpnumSecure+0xca>
        dst[i] = src[i];
 400a3ad:	8b 45 fc             	mov    -0x4(%rbp),%eax
 400a3b0:	48 63 d0             	movslq %eax,%rdx
 400a3b3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
 400a3b7:	48 01 d0             	add    %rdx,%rax
 400a3ba:	8b 55 fc             	mov    -0x4(%rbp),%edx
 400a3bd:	48 63 ca             	movslq %edx,%rcx
 400a3c0:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
 400a3c4:	48 01 ca             	add    %rcx,%rdx
 400a3c7:	0f b6 00             	movzbl (%rax),%eax
 400a3ca:	88 02                	mov    %al,(%rdx)
    for (int i = 0; i < len; i++) {
 400a3cc:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
 400a3d0:	8b 45 fc             	mov    -0x4(%rbp),%eax
 400a3d3:	3b 85 50 ff ff ff    	cmp    -0xb0(%rbp),%eax
 400a3d9:	7c d2                	jl     400a3ad <kpnumSecure+0xa7>
    }

    char buf[70];  // 足够容纳所有格式的输出
    int buffer_index = sizeof(buf) - 1;  // 从缓冲区末尾开始填充
 400a3db:	c7 45 f8 45 00 00 00 	movl   $0x45,-0x8(%rbp)
    buf[buffer_index] = '\0';  // 字符串终止符
 400a3e2:	8b 45 f8             	mov    -0x8(%rbp),%eax
 400a3e5:	48 98                	cltq
 400a3e7:	c6 84 05 60 ff ff ff 	movb   $0x0,-0xa0(%rbp,%rax,1)
 400a3ee:	00 

    switch (format) {
 400a3ef:	83 bd 54 ff ff ff 05 	cmpl   $0x5,-0xac(%rbp)
 400a3f6:	0f 84 99 02 00 00    	je     400a695 <kpnumSecure+0x38f>
 400a3fc:	83 bd 54 ff ff ff 05 	cmpl   $0x5,-0xac(%rbp)
 400a403:	0f 8f 29 03 00 00    	jg     400a732 <kpnumSecure+0x42c>
 400a409:	83 bd 54 ff ff ff 04 	cmpl   $0x4,-0xac(%rbp)
 400a410:	0f 84 0c 01 00 00    	je     400a522 <kpnumSecure+0x21c>
 400a416:	83 bd 54 ff ff ff 04 	cmpl   $0x4,-0xac(%rbp)
 400a41d:	0f 8f 0f 03 00 00    	jg     400a732 <kpnumSecure+0x42c>
 400a423:	83 bd 54 ff ff ff 01 	cmpl   $0x1,-0xac(%rbp)
 400a42a:	74 0e                	je     400a43a <kpnumSecure+0x134>
 400a42c:	83 bd 54 ff ff ff 03 	cmpl   $0x3,-0xac(%rbp)
 400a433:	74 5e                	je     400a493 <kpnumSecure+0x18d>
 400a435:	e9 f8 02 00 00       	jmp    400a732 <kpnumSecure+0x42c>
    case UNBIN: {
        // 二进制输出：固定位数显示
        int total_bits = len * 8;
 400a43a:	8b 85 50 ff ff ff    	mov    -0xb0(%rbp),%eax
 400a440:	c1 e0 03             	shl    $0x3,%eax
 400a443:	89 45 b4             	mov    %eax,-0x4c(%rbp)
        for (int bit_pos = total_bits - 1; bit_pos >= 0; bit_pos--) {
 400a446:	8b 45 b4             	mov    -0x4c(%rbp),%eax
 400a449:	83 e8 01             	sub    $0x1,%eax
 400a44c:	89 45 f4             	mov    %eax,-0xc(%rbp)
 400a44f:	eb 37                	jmp    400a488 <kpnumSecure+0x182>
            buffer_index--;
 400a451:	83 6d f8 01          	subl   $0x1,-0x8(%rbp)
            buf[buffer_index] = (num & (1ULL << bit_pos)) ? '1' : '0';
 400a455:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
 400a459:	8b 45 f4             	mov    -0xc(%rbp),%eax
 400a45c:	89 c1                	mov    %eax,%ecx
 400a45e:	48 d3 ea             	shr    %cl,%rdx
 400a461:	48 89 d0             	mov    %rdx,%rax
 400a464:	83 e0 01             	and    $0x1,%eax
 400a467:	48 85 c0             	test   %rax,%rax
 400a46a:	74 07                	je     400a473 <kpnumSecure+0x16d>
 400a46c:	ba 31 00 00 00       	mov    $0x31,%edx
 400a471:	eb 05                	jmp    400a478 <kpnumSecure+0x172>
 400a473:	ba 30 00 00 00       	mov    $0x30,%edx
 400a478:	8b 45 f8             	mov    -0x8(%rbp),%eax
 400a47b:	48 98                	cltq
 400a47d:	88 94 05 60 ff ff ff 	mov    %dl,-0xa0(%rbp,%rax,1)
        for (int bit_pos = total_bits - 1; bit_pos >= 0; bit_pos--) {
 400a484:	83 6d f4 01          	subl   $0x1,-0xc(%rbp)
 400a488:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
 400a48c:	79 c3                	jns    400a451 <kpnumSecure+0x14b>
        }
        break;
 400a48e:	e9 9f 02 00 00       	jmp    400a732 <kpnumSecure+0x42c>
    }
    
    case UNDEC: {
        // 无符号十进制输出
        uint64_t value = num;
 400a493:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
 400a497:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
        if (value == 0) {
 400a49b:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
 400a4a0:	75 74                	jne    400a516 <kpnumSecure+0x210>
            buffer_index--;
 400a4a2:	83 6d f8 01          	subl   $0x1,-0x8(%rbp)
            buf[buffer_index] = '0';
 400a4a6:	8b 45 f8             	mov    -0x8(%rbp),%eax
 400a4a9:	48 98                	cltq
 400a4ab:	c6 84 05 60 ff ff ff 	movb   $0x30,-0xa0(%rbp,%rax,1)
 400a4b2:	30 
                buffer_index--;
                buf[buffer_index] = '0' + (value % 10);
                value /= 10;
            }
        }
        break;
 400a4b3:	e9 7a 02 00 00       	jmp    400a732 <kpnumSecure+0x42c>
                buffer_index--;
 400a4b8:	83 6d f8 01          	subl   $0x1,-0x8(%rbp)
                buf[buffer_index] = '0' + (value % 10);
 400a4bc:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
 400a4c0:	48 ba cd cc cc cc cc 	movabs $0xcccccccccccccccd,%rdx
 400a4c7:	cc cc cc 
 400a4ca:	48 89 c8             	mov    %rcx,%rax
 400a4cd:	48 f7 e2             	mul    %rdx
 400a4d0:	48 c1 ea 03          	shr    $0x3,%rdx
 400a4d4:	48 89 d0             	mov    %rdx,%rax
 400a4d7:	48 c1 e0 02          	shl    $0x2,%rax
 400a4db:	48 01 d0             	add    %rdx,%rax
 400a4de:	48 01 c0             	add    %rax,%rax
 400a4e1:	48 29 c1             	sub    %rax,%rcx
 400a4e4:	48 89 ca             	mov    %rcx,%rdx
 400a4e7:	89 d0                	mov    %edx,%eax
 400a4e9:	83 c0 30             	add    $0x30,%eax
 400a4ec:	89 c2                	mov    %eax,%edx
 400a4ee:	8b 45 f8             	mov    -0x8(%rbp),%eax
 400a4f1:	48 98                	cltq
 400a4f3:	88 94 05 60 ff ff ff 	mov    %dl,-0xa0(%rbp,%rax,1)
                value /= 10;
 400a4fa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 400a4fe:	48 ba cd cc cc cc cc 	movabs $0xcccccccccccccccd,%rdx
 400a505:	cc cc cc 
 400a508:	48 f7 e2             	mul    %rdx
 400a50b:	48 89 d0             	mov    %rdx,%rax
 400a50e:	48 c1 e8 03          	shr    $0x3,%rax
 400a512:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
            while (value) {
 400a516:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
 400a51b:	75 9b                	jne    400a4b8 <kpnumSecure+0x1b2>
        break;
 400a51d:	e9 10 02 00 00       	jmp    400a732 <kpnumSecure+0x42c>
         * 4. 将数字逐位转换为字符
         */
        
        // 符号扩展（将原始数据按当前长度扩展为完整的64位有符号值）
        int64_t s_val;
        switch(len) {
 400a522:	83 bd 50 ff ff ff 08 	cmpl   $0x8,-0xb0(%rbp)
 400a529:	74 57                	je     400a582 <kpnumSecure+0x27c>
 400a52b:	83 bd 50 ff ff ff 08 	cmpl   $0x8,-0xb0(%rbp)
 400a532:	7f 58                	jg     400a58c <kpnumSecure+0x286>
 400a534:	83 bd 50 ff ff ff 04 	cmpl   $0x4,-0xb0(%rbp)
 400a53b:	74 39                	je     400a576 <kpnumSecure+0x270>
 400a53d:	83 bd 50 ff ff ff 04 	cmpl   $0x4,-0xb0(%rbp)
 400a544:	7f 46                	jg     400a58c <kpnumSecure+0x286>
 400a546:	83 bd 50 ff ff ff 01 	cmpl   $0x1,-0xb0(%rbp)
 400a54d:	74 0b                	je     400a55a <kpnumSecure+0x254>
 400a54f:	83 bd 50 ff ff ff 02 	cmpl   $0x2,-0xb0(%rbp)
 400a556:	74 10                	je     400a568 <kpnumSecure+0x262>
 400a558:	eb 32                	jmp    400a58c <kpnumSecure+0x286>
            case 1: s_val = (int8_t)num; break;
 400a55a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
 400a55e:	48 0f be c0          	movsbq %al,%rax
 400a562:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
 400a566:	eb 3d                	jmp    400a5a5 <kpnumSecure+0x29f>
            case 2: s_val = (int16_t)num; break;
 400a568:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
 400a56c:	48 0f bf c0          	movswq %ax,%rax
 400a570:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
 400a574:	eb 2f                	jmp    400a5a5 <kpnumSecure+0x29f>
            case 4: s_val = (int32_t)num; break;
 400a576:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
 400a57a:	48 98                	cltq
 400a57c:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
 400a580:	eb 23                	jmp    400a5a5 <kpnumSecure+0x29f>
            case 8: s_val = (int64_t)num; break;
 400a582:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
 400a586:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
 400a58a:	eb 19                	jmp    400a5a5 <kpnumSecure+0x29f>
            default: 
                serial_puts("Invalid length for INDEC format\n");
 400a58c:	48 8d 05 ed 74 00 00 	lea    0x74ed(%rip),%rax        # 4011a80 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0xba8>
 400a593:	48 89 c7             	mov    %rax,%rdi
 400a596:	e8 b4 02 00 00       	call   400a84f <serial_puts>
                return EINVAL;
 400a59b:	b8 16 00 00 00       	mov    $0x16,%eax
 400a5a0:	e9 ca 01 00 00       	jmp    400a76f <kpnumSecure+0x469>
        }
        
        // 处理特殊边界情况：-2⁶³（无法直接取绝对值）
        if (len == 8 && num == 0x8000000000000000ULL) {
 400a5a5:	83 bd 50 ff ff ff 08 	cmpl   $0x8,-0xb0(%rbp)
 400a5ac:	75 2c                	jne    400a5da <kpnumSecure+0x2d4>
 400a5ae:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
 400a5b2:	48 b8 00 00 00 00 00 	movabs $0x8000000000000000,%rax
 400a5b9:	00 00 80 
 400a5bc:	48 39 c2             	cmp    %rax,%rdx
 400a5bf:	75 19                	jne    400a5da <kpnumSecure+0x2d4>
            kputsascii("-9223372036854775808");
 400a5c1:	48 8d 05 d9 74 00 00 	lea    0x74d9(%rip),%rax        # 4011aa1 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0xbc9>
 400a5c8:	48 89 c7             	mov    %rax,%rdi
 400a5cb:	e8 00 fb ff ff       	call   400a0d0 <kputsascii(char*)>
            return 0;
 400a5d0:	b8 00 00 00 00       	mov    $0x0,%eax
 400a5d5:	e9 95 01 00 00       	jmp    400a76f <kpnumSecure+0x469>
        }
        
        // 处理符号
        int is_negative = 0;
 400a5da:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%rbp)
        if (s_val < 0) {
 400a5e1:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
 400a5e6:	79 0b                	jns    400a5f3 <kpnumSecure+0x2ed>
            is_negative = 1;
 400a5e8:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%rbp)
            s_val = -s_val;
 400a5ef:	48 f7 5d e0          	negq   -0x20(%rbp)
        }
        
        // 数字转换（包括0的处理）
        int start_pos = buffer_index;
 400a5f3:	8b 45 f8             	mov    -0x8(%rbp),%eax
 400a5f6:	89 45 b8             	mov    %eax,-0x48(%rbp)
        do {
            buffer_index--;
 400a5f9:	83 6d f8 01          	subl   $0x1,-0x8(%rbp)
            buf[buffer_index] = '0' + (s_val % 10);
 400a5fd:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
 400a601:	48 ba 67 66 66 66 66 	movabs $0x6666666666666667,%rdx
 400a608:	66 66 66 
 400a60b:	48 89 c8             	mov    %rcx,%rax
 400a60e:	48 f7 ea             	imul   %rdx
 400a611:	48 c1 fa 02          	sar    $0x2,%rdx
 400a615:	48 89 c8             	mov    %rcx,%rax
 400a618:	48 c1 f8 3f          	sar    $0x3f,%rax
 400a61c:	48 29 c2             	sub    %rax,%rdx
 400a61f:	48 89 d0             	mov    %rdx,%rax
 400a622:	48 c1 e0 02          	shl    $0x2,%rax
 400a626:	48 01 d0             	add    %rdx,%rax
 400a629:	48 01 c0             	add    %rax,%rax
 400a62c:	48 29 c1             	sub    %rax,%rcx
 400a62f:	48 89 ca             	mov    %rcx,%rdx
 400a632:	89 d0                	mov    %edx,%eax
 400a634:	83 c0 30             	add    $0x30,%eax
 400a637:	89 c2                	mov    %eax,%edx
 400a639:	8b 45 f8             	mov    -0x8(%rbp),%eax
 400a63c:	48 98                	cltq
 400a63e:	88 94 05 60 ff ff ff 	mov    %dl,-0xa0(%rbp,%rax,1)
            s_val /= 10;
 400a645:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
 400a649:	48 ba 67 66 66 66 66 	movabs $0x6666666666666667,%rdx
 400a650:	66 66 66 
 400a653:	48 89 c8             	mov    %rcx,%rax
 400a656:	48 f7 ea             	imul   %rdx
 400a659:	48 89 d0             	mov    %rdx,%rax
 400a65c:	48 c1 f8 02          	sar    $0x2,%rax
 400a660:	48 c1 f9 3f          	sar    $0x3f,%rcx
 400a664:	48 89 ca             	mov    %rcx,%rdx
 400a667:	48 29 d0             	sub    %rdx,%rax
 400a66a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
        } while (s_val > 0);
 400a66e:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
 400a673:	7f 84                	jg     400a5f9 <kpnumSecure+0x2f3>
        
        // 添加符号（如果需要）
        if (is_negative) {
 400a675:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
 400a679:	0f 84 b2 00 00 00    	je     400a731 <kpnumSecure+0x42b>
            buffer_index--;
 400a67f:	83 6d f8 01          	subl   $0x1,-0x8(%rbp)
            buf[buffer_index] = '-';
 400a683:	8b 45 f8             	mov    -0x8(%rbp),%eax
 400a686:	48 98                	cltq
 400a688:	c6 84 05 60 ff ff ff 	movb   $0x2d,-0xa0(%rbp,%rax,1)
 400a68f:	2d 
        }
        break;
 400a690:	e9 9c 00 00 00       	jmp    400a731 <kpnumSecure+0x42b>
    }
    
    case UNHEX: {
        // 十六进制输出（智能省略前导零）
        unsigned char* bytes = (unsigned char*)&num;
 400a695:	48 8d 45 a8          	lea    -0x58(%rbp),%rax
 400a699:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
        buf[buffer_index]='0';
 400a69d:	8b 45 f8             	mov    -0x8(%rbp),%eax
 400a6a0:	48 98                	cltq
 400a6a2:	c6 84 05 60 ff ff ff 	movb   $0x30,-0xa0(%rbp,%rax,1)
 400a6a9:	30 
        buffer_index--;
 400a6aa:	83 6d f8 01          	subl   $0x1,-0x8(%rbp)
        
        for (int byte_idx = 0; byte_idx <len; byte_idx++) {
 400a6ae:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
 400a6b5:	eb 6d                	jmp    400a724 <kpnumSecure+0x41e>
            unsigned char byte = bytes[byte_idx];
 400a6b7:	8b 45 d8             	mov    -0x28(%rbp),%eax
 400a6ba:	48 63 d0             	movslq %eax,%rdx
 400a6bd:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
 400a6c1:	48 01 d0             	add    %rdx,%rax
 400a6c4:	0f b6 00             	movzbl (%rax),%eax
 400a6c7:	88 45 bf             	mov    %al,-0x41(%rbp)
            // 处理低4位
            unsigned char low_nibble = byte & 0x0F;
 400a6ca:	0f b6 45 bf          	movzbl -0x41(%rbp),%eax
 400a6ce:	83 e0 0f             	and    $0xf,%eax
 400a6d1:	88 45 be             	mov    %al,-0x42(%rbp)

                buffer_index--;
 400a6d4:	83 6d f8 01          	subl   $0x1,-0x8(%rbp)
                buf[buffer_index] = "0123456789ABCDEF"[low_nibble];
 400a6d8:	0f b6 45 be          	movzbl -0x42(%rbp),%eax
 400a6dc:	48 98                	cltq
 400a6de:	48 8d 15 d1 73 00 00 	lea    0x73d1(%rip),%rdx        # 4011ab6 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0xbde>
 400a6e5:	0f b6 14 10          	movzbl (%rax,%rdx,1),%edx
 400a6e9:	8b 45 f8             	mov    -0x8(%rbp),%eax
 400a6ec:	48 98                	cltq
 400a6ee:	88 94 05 60 ff ff ff 	mov    %dl,-0xa0(%rbp,%rax,1)

            // 处理高4位
            unsigned char high_nibble = byte >> 4;
 400a6f5:	0f b6 45 bf          	movzbl -0x41(%rbp),%eax
 400a6f9:	c0 e8 04             	shr    $0x4,%al
 400a6fc:	88 45 bd             	mov    %al,-0x43(%rbp)

                buffer_index--;
 400a6ff:	83 6d f8 01          	subl   $0x1,-0x8(%rbp)
                buf[buffer_index] = "0123456789ABCDEF"[high_nibble];
 400a703:	0f b6 45 bd          	movzbl -0x43(%rbp),%eax
 400a707:	48 98                	cltq
 400a709:	48 8d 15 a6 73 00 00 	lea    0x73a6(%rip),%rdx        # 4011ab6 <drawCharacterWithoutRendered(int, int, wchar_t)::Filterbitmasks+0xbde>
 400a710:	0f b6 14 10          	movzbl (%rax,%rdx,1),%edx
 400a714:	8b 45 f8             	mov    -0x8(%rbp),%eax
 400a717:	48 98                	cltq
 400a719:	88 94 05 60 ff ff ff 	mov    %dl,-0xa0(%rbp,%rax,1)
        for (int byte_idx = 0; byte_idx <len; byte_idx++) {
 400a720:	83 45 d8 01          	addl   $0x1,-0x28(%rbp)
 400a724:	8b 45 d8             	mov    -0x28(%rbp),%eax
 400a727:	3b 85 50 ff ff ff    	cmp    -0xb0(%rbp),%eax
 400a72d:	7c 88                	jl     400a6b7 <kpnumSecure+0x3b1>

            
            
        }

        break;
 400a72f:	eb 01                	jmp    400a732 <kpnumSecure+0x42c>
        break;
 400a731:	90                   	nop
    // 输出最终结果
#ifdef PRINT_OUT
    kputsascii(buf + buffer_index);
    
#endif
    SERIAL_PUTS(buf + buffer_index);
 400a732:	8b 45 f8             	mov    -0x8(%rbp),%eax
 400a735:	48 98                	cltq
 400a737:	48 8d 95 60 ff ff ff 	lea    -0xa0(%rbp),%rdx
 400a73e:	48 01 d0             	add    %rdx,%rax
 400a741:	48 89 c7             	mov    %rax,%rdi
 400a744:	e8 06 01 00 00       	call   400a84f <serial_puts>
    gkcirclebufflogMgr.putsk(buf + buffer_index);
 400a749:	8b 45 f8             	mov    -0x8(%rbp),%eax
 400a74c:	48 98                	cltq
 400a74e:	48 8d 95 60 ff ff ff 	lea    -0xa0(%rbp),%rdx
 400a755:	48 01 c2             	add    %rax,%rdx
 400a758:	48 8d 05 b1 58 7f 00 	lea    0x7f58b1(%rip),%rax        # 4800010 <gkcirclebufflogMgr>
 400a75f:	48 89 d6             	mov    %rdx,%rsi
 400a762:	48 89 c7             	mov    %rax,%rdi
 400a765:	e8 d2 5b ff ff       	call   400033c <kcirclebufflogMgr::putsk(char*)>
    return 0;
 400a76a:	b8 00 00 00 00       	mov    $0x0,%eax
}
 400a76f:	c9                   	leave
 400a770:	c3                   	ret

000000000400a771 <outb>:
#include <efi.h>
#include "PortDriver.h"
#define COM1_PORT 0x3F8
static inline void outb(UINT16 port, UINT8 value) {
 400a771:	55                   	push   %rbp
 400a772:	48 89 e5             	mov    %rsp,%rbp
 400a775:	89 fa                	mov    %edi,%edx
 400a777:	89 f0                	mov    %esi,%eax
 400a779:	66 89 55 fc          	mov    %dx,-0x4(%rbp)
 400a77d:	88 45 f8             	mov    %al,-0x8(%rbp)
    asm volatile ("outb %0, %1" : : "a"(value), "Nd"(port));
 400a780:	0f b6 45 f8          	movzbl -0x8(%rbp),%eax
 400a784:	0f b7 55 fc          	movzwl -0x4(%rbp),%edx
 400a788:	ee                   	out    %al,(%dx)
}
 400a789:	90                   	nop
 400a78a:	5d                   	pop    %rbp
 400a78b:	c3                   	ret

000000000400a78c <inb>:

// 端口输入函数(内联汇编)
static inline UINT8 inb(UINT16 port) {
 400a78c:	55                   	push   %rbp
 400a78d:	48 89 e5             	mov    %rsp,%rbp
 400a790:	89 f8                	mov    %edi,%eax
 400a792:	66 89 45 ec          	mov    %ax,-0x14(%rbp)
    UINT8 ret;
    asm volatile ("inb %1, %0" : "=a"(ret) : "Nd"(port));
 400a796:	0f b7 45 ec          	movzwl -0x14(%rbp),%eax
 400a79a:	89 c2                	mov    %eax,%edx
 400a79c:	ec                   	in     (%dx),%al
 400a79d:	88 45 ff             	mov    %al,-0x1(%rbp)
    return ret;
 400a7a0:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
}
 400a7a4:	5d                   	pop    %rbp
 400a7a5:	c3                   	ret

000000000400a7a6 <serial_init>:
// 初始化串口
void serial_init() {
 400a7a6:	55                   	push   %rbp
 400a7a7:	48 89 e5             	mov    %rsp,%rbp
    // 禁用中断
    outb(COM1_PORT + 1, 0x00);
 400a7aa:	be 00 00 00 00       	mov    $0x0,%esi
 400a7af:	bf f9 03 00 00       	mov    $0x3f9,%edi
 400a7b4:	e8 b8 ff ff ff       	call   400a771 <outb>
    
    // 设置波特率(115200)
    outb(COM1_PORT + 3, 0x80);    // 启用DLAB(除数锁存访问位)
 400a7b9:	be 80 00 00 00       	mov    $0x80,%esi
 400a7be:	bf fb 03 00 00       	mov    $0x3fb,%edi
 400a7c3:	e8 a9 ff ff ff       	call   400a771 <outb>
    outb(COM1_PORT + 0, 0x01);     // 设置除数为1 (低位)
 400a7c8:	be 01 00 00 00       	mov    $0x1,%esi
 400a7cd:	bf f8 03 00 00       	mov    $0x3f8,%edi
 400a7d2:	e8 9a ff ff ff       	call   400a771 <outb>
    outb(COM1_PORT + 1, 0x00);     // 设置除数为1 (高位)
 400a7d7:	be 00 00 00 00       	mov    $0x0,%esi
 400a7dc:	bf f9 03 00 00       	mov    $0x3f9,%edi
 400a7e1:	e8 8b ff ff ff       	call   400a771 <outb>
    
    // 8位数据，无奇偶校验，1位停止位
    outb(COM1_PORT + 3, 0x03);
 400a7e6:	be 03 00 00 00       	mov    $0x3,%esi
 400a7eb:	bf fb 03 00 00       	mov    $0x3fb,%edi
 400a7f0:	e8 7c ff ff ff       	call   400a771 <outb>
    
    // 启用FIFO，清除接收/发送FIFO缓冲区
    outb(COM1_PORT + 2, 0xC7);
 400a7f5:	be c7 00 00 00       	mov    $0xc7,%esi
 400a7fa:	bf fa 03 00 00       	mov    $0x3fa,%edi
 400a7ff:	e8 6d ff ff ff       	call   400a771 <outb>
    
    // 启用中断(可选)
   //outb(COM1_PORT + 1, 0x0F);
}
 400a804:	90                   	nop
 400a805:	5d                   	pop    %rbp
 400a806:	c3                   	ret

000000000400a807 <serial_is_transmit_empty>:
// 检查发送缓冲区是否为空
int serial_is_transmit_empty() {
 400a807:	55                   	push   %rbp
 400a808:	48 89 e5             	mov    %rsp,%rbp
    return inb(COM1_PORT + 5) & 0x20;
 400a80b:	bf fd 03 00 00       	mov    $0x3fd,%edi
 400a810:	e8 77 ff ff ff       	call   400a78c <inb>
 400a815:	0f b6 c0             	movzbl %al,%eax
 400a818:	83 e0 20             	and    $0x20,%eax
}
 400a81b:	5d                   	pop    %rbp
 400a81c:	c3                   	ret

000000000400a81d <serial_putc>:

// 发送一个字符
void serial_putc(char c) {
 400a81d:	55                   	push   %rbp
 400a81e:	48 89 e5             	mov    %rsp,%rbp
 400a821:	48 83 ec 08          	sub    $0x8,%rsp
 400a825:	89 f8                	mov    %edi,%eax
 400a827:	88 45 fc             	mov    %al,-0x4(%rbp)
    while (serial_is_transmit_empty() == 0);
 400a82a:	90                   	nop
 400a82b:	b8 00 00 00 00       	mov    $0x0,%eax
 400a830:	e8 d2 ff ff ff       	call   400a807 <serial_is_transmit_empty>
 400a835:	85 c0                	test   %eax,%eax
 400a837:	74 f2                	je     400a82b <serial_putc+0xe>
    outb(COM1_PORT, c);
 400a839:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
 400a83d:	0f b6 c0             	movzbl %al,%eax
 400a840:	89 c6                	mov    %eax,%esi
 400a842:	bf f8 03 00 00       	mov    $0x3f8,%edi
 400a847:	e8 25 ff ff ff       	call   400a771 <outb>
}
 400a84c:	90                   	nop
 400a84d:	c9                   	leave
 400a84e:	c3                   	ret

000000000400a84f <serial_puts>:

// 发送字符串
void serial_puts(const char* str) {
 400a84f:	55                   	push   %rbp
 400a850:	48 89 e5             	mov    %rsp,%rbp
 400a853:	48 83 ec 08          	sub    $0x8,%rsp
 400a857:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    while (*str) {
 400a85b:	eb 19                	jmp    400a876 <serial_puts+0x27>
        serial_putc(*str++);
 400a85d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 400a861:	48 8d 50 01          	lea    0x1(%rax),%rdx
 400a865:	48 89 55 f8          	mov    %rdx,-0x8(%rbp)
 400a869:	0f b6 00             	movzbl (%rax),%eax
 400a86c:	0f be c0             	movsbl %al,%eax
 400a86f:	89 c7                	mov    %eax,%edi
 400a871:	e8 a7 ff ff ff       	call   400a81d <serial_putc>
    while (*str) {
 400a876:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 400a87a:	0f b6 00             	movzbl (%rax),%eax
 400a87d:	84 c0                	test   %al,%al
 400a87f:	75 dc                	jne    400a85d <serial_puts+0xe>
    }
}
 400a881:	90                   	nop
 400a882:	90                   	nop
 400a883:	c9                   	leave
 400a884:	c3                   	ret
 400a885:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400a88c:	00 00 00 
 400a88f:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400a896:	00 00 00 
 400a899:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400a8a0:	00 00 00 
 400a8a3:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400a8aa:	00 00 00 
 400a8ad:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400a8b4:	00 00 00 
 400a8b7:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400a8be:	00 00 00 
 400a8c1:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400a8c8:	00 00 00 
 400a8cb:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400a8d2:	00 00 00 
 400a8d5:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400a8dc:	00 00 00 
 400a8df:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400a8e6:	00 00 00 
 400a8e9:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400a8f0:	00 00 00 
 400a8f3:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400a8fa:	00 00 00 
 400a8fd:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400a904:	00 00 00 
 400a907:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400a90e:	00 00 00 
 400a911:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400a918:	00 00 00 
 400a91b:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400a922:	00 00 00 
 400a925:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400a92c:	00 00 00 
 400a92f:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400a936:	00 00 00 
 400a939:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400a940:	00 00 00 
 400a943:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400a94a:	00 00 00 
 400a94d:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400a954:	00 00 00 
 400a957:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400a95e:	00 00 00 
 400a961:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400a968:	00 00 00 
 400a96b:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400a972:	00 00 00 
 400a975:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400a97c:	00 00 00 
 400a97f:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400a986:	00 00 00 
 400a989:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400a990:	00 00 00 
 400a993:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400a99a:	00 00 00 
 400a99d:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400a9a4:	00 00 00 
 400a9a7:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400a9ae:	00 00 00 
 400a9b1:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400a9b8:	00 00 00 
 400a9bb:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400a9c2:	00 00 00 
 400a9c5:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400a9cc:	00 00 00 
 400a9cf:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400a9d6:	00 00 00 
 400a9d9:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400a9e0:	00 00 00 
 400a9e3:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400a9ea:	00 00 00 
 400a9ed:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400a9f4:	00 00 00 
 400a9f7:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400a9fe:	00 00 00 
 400aa01:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400aa08:	00 00 00 
 400aa0b:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400aa12:	00 00 00 
 400aa15:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400aa1c:	00 00 00 
 400aa1f:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400aa26:	00 00 00 
 400aa29:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400aa30:	00 00 00 
 400aa33:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400aa3a:	00 00 00 
 400aa3d:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400aa44:	00 00 00 
 400aa47:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400aa4e:	00 00 00 
 400aa51:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400aa58:	00 00 00 
 400aa5b:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400aa62:	00 00 00 
 400aa65:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400aa6c:	00 00 00 
 400aa6f:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400aa76:	00 00 00 
 400aa79:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400aa80:	00 00 00 
 400aa83:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400aa8a:	00 00 00 
 400aa8d:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400aa94:	00 00 00 
 400aa97:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400aa9e:	00 00 00 
 400aaa1:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400aaa8:	00 00 00 
 400aaab:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400aab2:	00 00 00 
 400aab5:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400aabc:	00 00 00 
 400aabf:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400aac6:	00 00 00 
 400aac9:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400aad0:	00 00 00 
 400aad3:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400aada:	00 00 00 
 400aadd:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400aae4:	00 00 00 
 400aae7:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400aaee:	00 00 00 
 400aaf1:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400aaf8:	00 00 00 
 400aafb:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ab02:	00 00 00 
 400ab05:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ab0c:	00 00 00 
 400ab0f:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ab16:	00 00 00 
 400ab19:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ab20:	00 00 00 
 400ab23:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ab2a:	00 00 00 
 400ab2d:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ab34:	00 00 00 
 400ab37:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ab3e:	00 00 00 
 400ab41:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ab48:	00 00 00 
 400ab4b:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ab52:	00 00 00 
 400ab55:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ab5c:	00 00 00 
 400ab5f:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ab66:	00 00 00 
 400ab69:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ab70:	00 00 00 
 400ab73:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ab7a:	00 00 00 
 400ab7d:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ab84:	00 00 00 
 400ab87:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ab8e:	00 00 00 
 400ab91:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ab98:	00 00 00 
 400ab9b:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400aba2:	00 00 00 
 400aba5:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400abac:	00 00 00 
 400abaf:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400abb6:	00 00 00 
 400abb9:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400abc0:	00 00 00 
 400abc3:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400abca:	00 00 00 
 400abcd:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400abd4:	00 00 00 
 400abd7:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400abde:	00 00 00 
 400abe1:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400abe8:	00 00 00 
 400abeb:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400abf2:	00 00 00 
 400abf5:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400abfc:	00 00 00 
 400abff:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ac06:	00 00 00 
 400ac09:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ac10:	00 00 00 
 400ac13:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ac1a:	00 00 00 
 400ac1d:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ac24:	00 00 00 
 400ac27:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ac2e:	00 00 00 
 400ac31:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ac38:	00 00 00 
 400ac3b:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ac42:	00 00 00 
 400ac45:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ac4c:	00 00 00 
 400ac4f:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ac56:	00 00 00 
 400ac59:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ac60:	00 00 00 
 400ac63:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ac6a:	00 00 00 
 400ac6d:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ac74:	00 00 00 
 400ac77:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ac7e:	00 00 00 
 400ac81:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ac88:	00 00 00 
 400ac8b:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ac92:	00 00 00 
 400ac95:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ac9c:	00 00 00 
 400ac9f:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400aca6:	00 00 00 
 400aca9:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400acb0:	00 00 00 
 400acb3:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400acba:	00 00 00 
 400acbd:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400acc4:	00 00 00 
 400acc7:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400acce:	00 00 00 
 400acd1:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400acd8:	00 00 00 
 400acdb:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ace2:	00 00 00 
 400ace5:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400acec:	00 00 00 
 400acef:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400acf6:	00 00 00 
 400acf9:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ad00:	00 00 00 
 400ad03:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ad0a:	00 00 00 
 400ad0d:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ad14:	00 00 00 
 400ad17:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ad1e:	00 00 00 
 400ad21:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ad28:	00 00 00 
 400ad2b:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ad32:	00 00 00 
 400ad35:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ad3c:	00 00 00 
 400ad3f:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ad46:	00 00 00 
 400ad49:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ad50:	00 00 00 
 400ad53:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ad5a:	00 00 00 
 400ad5d:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ad64:	00 00 00 
 400ad67:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ad6e:	00 00 00 
 400ad71:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ad78:	00 00 00 
 400ad7b:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ad82:	00 00 00 
 400ad85:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ad8c:	00 00 00 
 400ad8f:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ad96:	00 00 00 
 400ad99:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ada0:	00 00 00 
 400ada3:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400adaa:	00 00 00 
 400adad:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400adb4:	00 00 00 
 400adb7:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400adbe:	00 00 00 
 400adc1:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400adc8:	00 00 00 
 400adcb:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400add2:	00 00 00 
 400add5:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400addc:	00 00 00 
 400addf:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ade6:	00 00 00 
 400ade9:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400adf0:	00 00 00 
 400adf3:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400adfa:	00 00 00 
 400adfd:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ae04:	00 00 00 
 400ae07:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ae0e:	00 00 00 
 400ae11:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ae18:	00 00 00 
 400ae1b:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ae22:	00 00 00 
 400ae25:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ae2c:	00 00 00 
 400ae2f:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ae36:	00 00 00 
 400ae39:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ae40:	00 00 00 
 400ae43:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ae4a:	00 00 00 
 400ae4d:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ae54:	00 00 00 
 400ae57:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ae5e:	00 00 00 
 400ae61:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ae68:	00 00 00 
 400ae6b:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ae72:	00 00 00 
 400ae75:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ae7c:	00 00 00 
 400ae7f:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ae86:	00 00 00 
 400ae89:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ae90:	00 00 00 
 400ae93:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400ae9a:	00 00 00 
 400ae9d:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400aea4:	00 00 00 
 400aea7:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400aeae:	00 00 00 
 400aeb1:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400aeb8:	00 00 00 
 400aebb:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400aec2:	00 00 00 
 400aec5:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400aecc:	00 00 00 
 400aecf:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400aed6:	00 00 00 
 400aed9:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400aee0:	00 00 00 
 400aee3:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400aeea:	00 00 00 
 400aeed:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400aef4:	00 00 00 
 400aef7:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400aefe:	00 00 00 
 400af01:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400af08:	00 00 00 
 400af0b:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400af12:	00 00 00 
 400af15:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400af1c:	00 00 00 
 400af1f:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400af26:	00 00 00 
 400af29:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400af30:	00 00 00 
 400af33:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400af3a:	00 00 00 
 400af3d:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400af44:	00 00 00 
 400af47:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400af4e:	00 00 00 
 400af51:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400af58:	00 00 00 
 400af5b:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400af62:	00 00 00 
 400af65:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400af6c:	00 00 00 
 400af6f:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400af76:	00 00 00 
 400af79:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400af80:	00 00 00 
 400af83:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400af8a:	00 00 00 
 400af8d:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400af94:	00 00 00 
 400af97:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400af9e:	00 00 00 
 400afa1:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400afa8:	00 00 00 
 400afab:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400afb2:	00 00 00 
 400afb5:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400afbc:	00 00 00 
 400afbf:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400afc6:	00 00 00 
 400afc9:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400afd0:	00 00 00 
 400afd3:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400afda:	00 00 00 
 400afdd:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400afe4:	00 00 00 
 400afe7:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400afee:	00 00 00 
 400aff1:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
 400aff8:	00 00 00 
 400affb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
