内核项目按照启动顺序有以下模块：
	1.最基础图形驱动
	1.1轮询阻塞式串口驱动
	1.2基于帧缓冲区的纯cpu图形驱动
	1.3字符位图控制器
	1.4内核shell控制器
	
	2.内存管理
	2.0内核对象池内存分配器
	在编译的时候就提前定义好一个4mb的堆空间，通过一个类来管，在位图空闲内存管理器进入静态/动态模式后就通过修改其中的flags通知工作模式改变
	构造函数负责初始化first_static_heap,以及设置flags里面的ableto_Expand为false
	静态模式下，当申请内存时，会从first_static_heap中申请，当释放内存时，会返回给first_static_heap
	动态模式下，会优先从first_static_heap中申请，当申请失败时，会使用位图空闲页管理器分配其它的堆内存块以及生成对应的堆节点
	不管哪种模式，申请内存都要调用内部接口is_space_available来遍历内存块块，判断是否可以申请
	这个函数会搜索堆内存块中某段内存是否可申请,若是则返回空指针
	 若否，则返回下一个可能的空闲内存块的起始地址
	2.1全局物理内存描述符表 &基础物理内存分配器
	从efi传来的EFI_MEM_DESCRIPTOR复制魔改而来，基于这个数据结构的基础物理内存分配器的外部接口有内核数据区分配/回收（只能在真正的空闲内存管理器没启用时使用），硬件物理地址空间分配声明服务
	2.1.1回收启动时服务内存：
	uefi传过来的内存描述符表需要经过一些处理才能更好的使用
	首先，传过来的表不一定是顺序的，需要按照起始物理地址从小到大排序
	其次，可能会存在物理内存空洞需要填充，而后面的位图分配器初始化的时候默认全部写0,只对使用的内存进行初始化，若存在内存空洞可能被位图页分配器使用，造成未定义行为，因此要补上这个漏洞
	接下来再说回收启动时服务内存，并且复制一份到内核堆区，根据规定的内核数据区/代码区/栈区基址标记相应“Loader ”内存为正确的类型
	接下来才能正确地收复loader内存
	然后标记基本内存服务可用
	2.2.物理页分层管理器
	首先我们规定这个空闲内存管理器最细粒度为4kb
	之前由于没有意识到可以提前在链接脚本中定义堆空间，因此只能使用位图空闲页管理器这种十分静态的数据结构，
	但是现在就可以使用更加动态的数据结构专职管理内存
	还是像之前的位图管理器，对于4kb的页，一般来说只配用一个bit来表示是否使用就行了
	但是在以上的大页块，就可以用完整的页结构体来表示
	
	2.4.内核空间页表
	根据全局物理内存描述符表另建新的页表系统，低地址段恒等映射物理内存，再将标记为内核数据/代码/栈的内存偏移映射到高128tb
	2.5.虚拟内存分配器
	3.驱动
	3.1.acpi子系统
	3.1.1 apic子系统
	以配置缺页异常中断，除0异常，段异常为目的配置apic子系统顺路再为后面硬件中断做好预留
	3.1.2 pcie子系统
	3.1.2.1 nvme硬盘驱动
	3.1.2.1.1 文件系统驱动
	3.1.2.2 显卡驱动（intel核显）
	3.2ps/2键盘驱动
	4.任务调度器
